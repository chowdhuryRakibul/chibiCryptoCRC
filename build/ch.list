
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002bb 	.word	0x080002bb
 8000010:	080002bb 	.word	0x080002bb
 8000014:	080002bb 	.word	0x080002bb
 8000018:	080002bb 	.word	0x080002bb
 800001c:	080002bb 	.word	0x080002bb
 8000020:	080002bb 	.word	0x080002bb
 8000024:	080002bb 	.word	0x080002bb
 8000028:	080002bb 	.word	0x080002bb
 800002c:	080022f1 	.word	0x080022f1
 8000030:	080002bb 	.word	0x080002bb
 8000034:	080002bb 	.word	0x080002bb
 8000038:	080002bb 	.word	0x080002bb
 800003c:	080002bb 	.word	0x080002bb
 8000040:	080002bb 	.word	0x080002bb
 8000044:	080002bb 	.word	0x080002bb
 8000048:	080002bb 	.word	0x080002bb
 800004c:	080002bb 	.word	0x080002bb
 8000050:	080002bb 	.word	0x080002bb
 8000054:	080002bb 	.word	0x080002bb
 8000058:	080002bb 	.word	0x080002bb
 800005c:	080002bb 	.word	0x080002bb
 8000060:	080002bb 	.word	0x080002bb
 8000064:	080002bb 	.word	0x080002bb
 8000068:	080002bb 	.word	0x080002bb
 800006c:	08003eb1 	.word	0x08003eb1
 8000070:	08003e81 	.word	0x08003e81
 8000074:	08003e51 	.word	0x08003e51
 8000078:	08003e21 	.word	0x08003e21
 800007c:	08003df1 	.word	0x08003df1
 8000080:	08003dc1 	.word	0x08003dc1
 8000084:	08003d91 	.word	0x08003d91
 8000088:	080002bb 	.word	0x080002bb
 800008c:	080002bb 	.word	0x080002bb
 8000090:	080002bb 	.word	0x080002bb
 8000094:	080002bb 	.word	0x080002bb
 8000098:	080002bb 	.word	0x080002bb
 800009c:	080002bb 	.word	0x080002bb
 80000a0:	080002bb 	.word	0x080002bb
 80000a4:	080002bb 	.word	0x080002bb
 80000a8:	080002bb 	.word	0x080002bb
 80000ac:	080002bb 	.word	0x080002bb
 80000b0:	08003af1 	.word	0x08003af1
 80000b4:	080002bb 	.word	0x080002bb
 80000b8:	080002bb 	.word	0x080002bb
 80000bc:	080002bb 	.word	0x080002bb
 80000c0:	080002bb 	.word	0x080002bb
 80000c4:	080002bb 	.word	0x080002bb
 80000c8:	080002bb 	.word	0x080002bb
 80000cc:	080002bb 	.word	0x080002bb
 80000d0:	080002bb 	.word	0x080002bb
 80000d4:	080002bb 	.word	0x080002bb
 80000d8:	080002bb 	.word	0x080002bb
 80000dc:	080002bb 	.word	0x080002bb
 80000e0:	080002bb 	.word	0x080002bb
 80000e4:	080002bb 	.word	0x080002bb
 80000e8:	080002bb 	.word	0x080002bb
 80000ec:	080002bb 	.word	0x080002bb
 80000f0:	080002bb 	.word	0x080002bb
 80000f4:	080002bb 	.word	0x080002bb
 80000f8:	080002bb 	.word	0x080002bb
 80000fc:	08003d61 	.word	0x08003d61
 8000100:	080002bb 	.word	0x080002bb
 8000104:	08003ba1 	.word	0x08003ba1
 8000108:	080002bb 	.word	0x080002bb
 800010c:	080002bb 	.word	0x080002bb
 8000110:	080002bb 	.word	0x080002bb
 8000114:	080002bb 	.word	0x080002bb
 8000118:	080002bb 	.word	0x080002bb
 800011c:	080002bb 	.word	0x080002bb
 8000120:	08003d31 	.word	0x08003d31
 8000124:	08003d01 	.word	0x08003d01
 8000128:	08003cd1 	.word	0x08003cd1
 800012c:	08003ca1 	.word	0x08003ca1
 8000130:	08003c71 	.word	0x08003c71
 8000134:	080002bb 	.word	0x080002bb
 8000138:	080002bb 	.word	0x080002bb
 800013c:	080002bb 	.word	0x080002bb
 8000140:	080002bb 	.word	0x080002bb
 8000144:	080002bb 	.word	0x080002bb
 8000148:	080002bb 	.word	0x080002bb
 800014c:	080002bb 	.word	0x080002bb
 8000150:	08003c41 	.word	0x08003c41
 8000154:	08003c11 	.word	0x08003c11
 8000158:	08003be1 	.word	0x08003be1
 800015c:	08003931 	.word	0x08003931
 8000160:	080002bb 	.word	0x080002bb
 8000164:	080002bb 	.word	0x080002bb
 8000168:	080002bb 	.word	0x080002bb
 800016c:	080002bb 	.word	0x080002bb
 8000170:	080002bb 	.word	0x080002bb
 8000174:	080002bb 	.word	0x080002bb
 8000178:	080002bb 	.word	0x080002bb
 800017c:	080002bb 	.word	0x080002bb
 8000180:	080002bb 	.word	0x080002bb
 8000184:	080002bb 	.word	0x080002bb
 8000188:	080002bb 	.word	0x080002bb
 800018c:	080002bb 	.word	0x080002bb
 8000190:	080002bb 	.word	0x080002bb
 8000194:	080002bb 	.word	0x080002bb
 8000198:	080002bb 	.word	0x080002bb
 800019c:	080002bb 	.word	0x080002bb
 80001a0:	080002bb 	.word	0x080002bb
 80001a4:	080002bb 	.word	0x080002bb
 80001a8:	080002bb 	.word	0x080002bb
 80001ac:	080002bb 	.word	0x080002bb
 80001b0:	080002bb 	.word	0x080002bb
 80001b4:	080002bb 	.word	0x080002bb
 80001b8:	080002bb 	.word	0x080002bb
 80001bc:	080002bb 	.word	0x080002bb
 80001c0:	080002bb 	.word	0x080002bb
 80001c4:	080002bb 	.word	0x080002bb
 80001c8:	080002bb 	.word	0x080002bb
 80001cc:	080002bb 	.word	0x080002bb
 80001d0:	080002bb 	.word	0x080002bb
 80001d4:	080002bb 	.word	0x080002bb
 80001d8:	080002bb 	.word	0x080002bb
 80001dc:	080002bb 	.word	0x080002bb

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4827      	ldr	r0, [pc, #156]	; (8000280 <endfiniloop+0x4>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4826      	ldr	r0, [pc, #152]	; (8000284 <endfiniloop+0x8>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ee:	4826      	ldr	r0, [pc, #152]	; (8000288 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f8:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001fa:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001fc:	f380 8814 	msr	CONTROL, r0
                isb
 8000200:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000204:	f003 feb4 	bl	8003f70 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000208:	f003 fa5a 	bl	80036c0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800020c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000210:	491e      	ldr	r1, [pc, #120]	; (800028c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 8000212:	4a1b      	ldr	r2, [pc, #108]	; (8000280 <endfiniloop+0x4>)

08000214 <msloop>:
msloop:
                cmp     r1, r2
 8000214:	4291      	cmp	r1, r2
                itt     lo
 8000216:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000218:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 800021c:	e7fa      	bcc.n	8000214 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800021e:	491c      	ldr	r1, [pc, #112]	; (8000290 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 8000220:	4a18      	ldr	r2, [pc, #96]	; (8000284 <endfiniloop+0x8>)

08000222 <psloop>:
psloop:
                cmp     r1, r2
 8000222:	4291      	cmp	r1, r2
                itt     lo
 8000224:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000226:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 800022a:	e7fa      	bcc.n	8000222 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 800022c:	4919      	ldr	r1, [pc, #100]	; (8000294 <endfiniloop+0x18>)
                ldr     r2, =__data_base__
 800022e:	4a1a      	ldr	r2, [pc, #104]	; (8000298 <endfiniloop+0x1c>)
                ldr     r3, =__data_end__
 8000230:	4b1a      	ldr	r3, [pc, #104]	; (800029c <endfiniloop+0x20>)

08000232 <dloop>:
dloop:
                cmp     r2, r3
 8000232:	429a      	cmp	r2, r3
                ittt    lo
 8000234:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000236:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800023a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800023e:	e7f8      	bcc.n	8000232 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000240:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000242:	4917      	ldr	r1, [pc, #92]	; (80002a0 <endfiniloop+0x24>)
                ldr     r2, =__bss_end__
 8000244:	4a17      	ldr	r2, [pc, #92]	; (80002a4 <endfiniloop+0x28>)

08000246 <bloop>:
bloop:
                cmp     r1, r2
 8000246:	4291      	cmp	r1, r2
                itt     lo
 8000248:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800024a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800024e:	e7fa      	bcc.n	8000246 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000250:	f003 fe46 	bl	8003ee0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000254:	f003 fe84 	bl	8003f60 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000258:	4c13      	ldr	r4, [pc, #76]	; (80002a8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end__
 800025a:	4d14      	ldr	r5, [pc, #80]	; (80002ac <endfiniloop+0x30>)

0800025c <initloop>:
initloop:
                cmp     r4, r5
 800025c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800025e:	da03      	bge.n	8000268 <endinitloop>
                ldr     r1, [r4], #4
 8000260:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000264:	4788      	blx	r1
                b       initloop
 8000266:	e7f9      	b.n	800025c <initloop>

08000268 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000268:	f002 fc12 	bl	8002a90 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800026c:	4c10      	ldr	r4, [pc, #64]	; (80002b0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end__
 800026e:	4d11      	ldr	r5, [pc, #68]	; (80002b4 <endfiniloop+0x38>)

08000270 <finiloop>:
finiloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000272:	da03      	bge.n	800027c <endfiniloop>
                ldr     r1, [r4], #4
 8000274:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000278:	4788      	blx	r1
                b       finiloop
 800027a:	e7f9      	b.n	8000270 <finiloop>

0800027c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800027c:	f003 be68 	b.w	8003f50 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000280:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000284:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000288:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000294:	0800465c 	.word	0x0800465c
                ldr     r2, =__data_base__
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800029c:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 80002a0:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 80002a4:	20001770 	.word	0x20001770
                ldr     r4, =__init_array_base__
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002c4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002c8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ca:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002d0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002d2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002d6:	4628      	mov	r0, r5
                blx     r4
 80002d8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002da:	2000      	movs	r0, #0
                bl      chThdExit
 80002dc:	f002 f818 	bl	8002310 <chThdExit>

080002e0 <_zombies>:
_zombies:       b       _zombies
 80002e0:	e7fe      	b.n	80002e0 <_zombies>

080002e2 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80002e2:	f002 f83d 	bl	8002360 <chSchDoReschedule>

080002e6 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002e6:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002e8:	e7fe      	b.n	80002e8 <_port_exit_from_isr+0x2>
	...

080002ec <memcpy>:
 80002ec:	4684      	mov	ip, r0
 80002ee:	ea41 0300 	orr.w	r3, r1, r0
 80002f2:	f013 0303 	ands.w	r3, r3, #3
 80002f6:	d16d      	bne.n	80003d4 <memcpy+0xe8>
 80002f8:	3a40      	subs	r2, #64	; 0x40
 80002fa:	d341      	bcc.n	8000380 <memcpy+0x94>
 80002fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000300:	f840 3b04 	str.w	r3, [r0], #4
 8000304:	f851 3b04 	ldr.w	r3, [r1], #4
 8000308:	f840 3b04 	str.w	r3, [r0], #4
 800030c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000310:	f840 3b04 	str.w	r3, [r0], #4
 8000314:	f851 3b04 	ldr.w	r3, [r1], #4
 8000318:	f840 3b04 	str.w	r3, [r0], #4
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000340:	f840 3b04 	str.w	r3, [r0], #4
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	f851 3b04 	ldr.w	r3, [r1], #4
 8000368:	f840 3b04 	str.w	r3, [r0], #4
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	f851 3b04 	ldr.w	r3, [r1], #4
 8000378:	f840 3b04 	str.w	r3, [r0], #4
 800037c:	3a40      	subs	r2, #64	; 0x40
 800037e:	d2bd      	bcs.n	80002fc <memcpy+0x10>
 8000380:	3230      	adds	r2, #48	; 0x30
 8000382:	d311      	bcc.n	80003a8 <memcpy+0xbc>
 8000384:	f851 3b04 	ldr.w	r3, [r1], #4
 8000388:	f840 3b04 	str.w	r3, [r0], #4
 800038c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000390:	f840 3b04 	str.w	r3, [r0], #4
 8000394:	f851 3b04 	ldr.w	r3, [r1], #4
 8000398:	f840 3b04 	str.w	r3, [r0], #4
 800039c:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a0:	f840 3b04 	str.w	r3, [r0], #4
 80003a4:	3a10      	subs	r2, #16
 80003a6:	d2ed      	bcs.n	8000384 <memcpy+0x98>
 80003a8:	320c      	adds	r2, #12
 80003aa:	d305      	bcc.n	80003b8 <memcpy+0xcc>
 80003ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b0:	f840 3b04 	str.w	r3, [r0], #4
 80003b4:	3a04      	subs	r2, #4
 80003b6:	d2f9      	bcs.n	80003ac <memcpy+0xc0>
 80003b8:	3204      	adds	r2, #4
 80003ba:	d008      	beq.n	80003ce <memcpy+0xe2>
 80003bc:	07d2      	lsls	r2, r2, #31
 80003be:	bf1c      	itt	ne
 80003c0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003c4:	f800 3b01 	strbne.w	r3, [r0], #1
 80003c8:	d301      	bcc.n	80003ce <memcpy+0xe2>
 80003ca:	880b      	ldrh	r3, [r1, #0]
 80003cc:	8003      	strh	r3, [r0, #0]
 80003ce:	4660      	mov	r0, ip
 80003d0:	4770      	bx	lr
 80003d2:	bf00      	nop
 80003d4:	2a08      	cmp	r2, #8
 80003d6:	d313      	bcc.n	8000400 <memcpy+0x114>
 80003d8:	078b      	lsls	r3, r1, #30
 80003da:	d08d      	beq.n	80002f8 <memcpy+0xc>
 80003dc:	f010 0303 	ands.w	r3, r0, #3
 80003e0:	d08a      	beq.n	80002f8 <memcpy+0xc>
 80003e2:	f1c3 0304 	rsb	r3, r3, #4
 80003e6:	1ad2      	subs	r2, r2, r3
 80003e8:	07db      	lsls	r3, r3, #31
 80003ea:	bf1c      	itt	ne
 80003ec:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003f0:	f800 3b01 	strbne.w	r3, [r0], #1
 80003f4:	d380      	bcc.n	80002f8 <memcpy+0xc>
 80003f6:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003fa:	f820 3b02 	strh.w	r3, [r0], #2
 80003fe:	e77b      	b.n	80002f8 <memcpy+0xc>
 8000400:	3a04      	subs	r2, #4
 8000402:	d3d9      	bcc.n	80003b8 <memcpy+0xcc>
 8000404:	3a01      	subs	r2, #1
 8000406:	f811 3b01 	ldrb.w	r3, [r1], #1
 800040a:	f800 3b01 	strb.w	r3, [r0], #1
 800040e:	d2f9      	bcs.n	8000404 <memcpy+0x118>
 8000410:	780b      	ldrb	r3, [r1, #0]
 8000412:	7003      	strb	r3, [r0, #0]
 8000414:	784b      	ldrb	r3, [r1, #1]
 8000416:	7043      	strb	r3, [r0, #1]
 8000418:	788b      	ldrb	r3, [r1, #2]
 800041a:	7083      	strb	r3, [r0, #2]
 800041c:	4660      	mov	r0, ip
 800041e:	4770      	bx	lr

08000420 <_pal_lld_setgroupmode.constprop.21>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8000420:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8000424:	2100      	movs	r1, #0

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8000426:	4c21      	ldr	r4, [pc, #132]	; (80004ac <_pal_lld_setgroupmode.constprop.21+0x8c>)
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8000428:	2502      	movs	r5, #2
      altrmask = altr << ((bit & 7) * 4);
 800042a:	f04f 0808 	mov.w	r8, #8
      m1 = 1 << bit;
 800042e:	f04f 0e01 	mov.w	lr, #1
      m2 = 3 << (bit * 2);
 8000432:	f04f 0c03 	mov.w	ip, #3
      m4 = 15 << ((bit & 7) * 4);
 8000436:	270f      	movs	r7, #15
 8000438:	e00d      	b.n	8000456 <_pal_lld_setgroupmode.constprop.21+0x36>
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800043a:	6a26      	ldr	r6, [r4, #32]
 800043c:	ea06 0909 	and.w	r9, r6, r9
 8000440:	ea49 0202 	orr.w	r2, r9, r2
 8000444:	6222      	str	r2, [r4, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8000446:	6822      	ldr	r2, [r4, #0]
 8000448:	4013      	ands	r3, r2
 800044a:	432b      	orrs	r3, r5
 800044c:	6023      	str	r3, [r4, #0]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 800044e:	0840      	lsrs	r0, r0, #1
 8000450:	d029      	beq.n	80004a6 <_pal_lld_setgroupmode.constprop.21+0x86>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8000452:	00ad      	lsls	r5, r5, #2
    bit++;
 8000454:	3101      	adds	r1, #1
      altrmask = altr << ((bit & 7) * 4);
 8000456:	f001 0207 	and.w	r2, r1, #7
 800045a:	0092      	lsls	r2, r2, #2
      m2 = 3 << (bit * 2);
 800045c:	004b      	lsls	r3, r1, #1
      m4 = 15 << ((bit & 7) * 4);
 800045e:	fa07 f902 	lsl.w	r9, r7, r2
      m2 = 3 << (bit * 2);
 8000462:	fa0c f303 	lsl.w	r3, ip, r3
    if ((mask & 1) != 0) {
 8000466:	f010 0f01 	tst.w	r0, #1
      m1 = 1 << bit;
 800046a:	fa0e f601 	lsl.w	r6, lr, r1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800046e:	ea6f 0303 	mvn.w	r3, r3
      altrmask = altr << ((bit & 7) * 4);
 8000472:	fa08 f202 	lsl.w	r2, r8, r2
 8000476:	ea6f 0909 	mvn.w	r9, r9
    if ((mask & 1) != 0) {
 800047a:	d0e8      	beq.n	800044e <_pal_lld_setgroupmode.constprop.21+0x2e>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800047c:	f8d4 a004 	ldr.w	sl, [r4, #4]
 8000480:	ea2a 0606 	bic.w	r6, sl, r6
 8000484:	6066      	str	r6, [r4, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8000486:	68a6      	ldr	r6, [r4, #8]
 8000488:	401e      	ands	r6, r3
 800048a:	60a6      	str	r6, [r4, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800048c:	68e6      	ldr	r6, [r4, #12]
        if (bit < 8)
 800048e:	2907      	cmp	r1, #7
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8000490:	ea06 0603 	and.w	r6, r6, r3
 8000494:	60e6      	str	r6, [r4, #12]
        if (bit < 8)
 8000496:	d9d0      	bls.n	800043a <_pal_lld_setgroupmode.constprop.21+0x1a>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8000498:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800049a:	ea06 0909 	and.w	r9, r6, r9
 800049e:	ea49 0202 	orr.w	r2, r9, r2
 80004a2:	6262      	str	r2, [r4, #36]	; 0x24
 80004a4:	e7cf      	b.n	8000446 <_pal_lld_setgroupmode.constprop.21+0x26>
  }
}
 80004a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004aa:	bf00      	nop
 80004ac:	40020800 	.word	0x40020800

080004b0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80004b0:	b430      	push	{r4, r5}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80004b2:	2320      	movs	r3, #32
 80004b4:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80004b8:	4c0b      	ldr	r4, [pc, #44]	; (80004e8 <chCoreAllocFromTop+0x38>)
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80004ba:	e9d4 3500 	ldrd	r3, r5, [r4]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80004be:	4249      	negs	r1, r1
 80004c0:	1a28      	subs	r0, r5, r0
 80004c2:	4008      	ands	r0, r1
  prev = p - offset;
 80004c4:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80004c6:	429a      	cmp	r2, r3
 80004c8:	d307      	bcc.n	80004da <chCoreAllocFromTop+0x2a>
 80004ca:	4295      	cmp	r5, r2
 80004cc:	d305      	bcc.n	80004da <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 80004ce:	6062      	str	r2, [r4, #4]
 80004d0:	2300      	movs	r3, #0
 80004d2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 80004d6:	bc30      	pop	{r4, r5}
 80004d8:	4770      	bx	lr
    return NULL;
 80004da:	2000      	movs	r0, #0
 80004dc:	2300      	movs	r3, #0
 80004de:	f383 8811 	msr	BASEPRI, r3
}
 80004e2:	bc30      	pop	{r4, r5}
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	20000ea0 	.word	0x20000ea0
 80004ec:	00000000 	.word	0x00000000

080004f0 <notify6>:

#if STM32_SERIAL_USE_USART6 || defined(__DOXYGEN__)
static void notify6(io_queue_t *qp) {

  (void)qp;
  USART6->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 80004f0:	4a02      	ldr	r2, [pc, #8]	; (80004fc <notify6+0xc>)
 80004f2:	68d3      	ldr	r3, [r2, #12]
 80004f4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80004f8:	60d3      	str	r3, [r2, #12]
}
 80004fa:	4770      	bx	lr
 80004fc:	40011400 	.word	0x40011400

08000500 <ff_wtoupper.part.2>:
	};


	if (uni < 0x10000) {	/* Is it in BMP? */
		uc = (WORD)uni;
		p = uc < 0x1000 ? cvt1 : cvt2;
 8000500:	4a27      	ldr	r2, [pc, #156]	; (80005a0 <ff_wtoupper.part.2+0xa0>)
 8000502:	4b28      	ldr	r3, [pc, #160]	; (80005a4 <ff_wtoupper.part.2+0xa4>)
 8000504:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
DWORD ff_wtoupper (	/* Returns up-converted code point */
 8000508:	b4f0      	push	{r4, r5, r6, r7}
		p = uc < 0x1000 ? cvt1 : cvt2;
 800050a:	f641 517d 	movw	r1, #7549	; 0x1d7d
DWORD ff_wtoupper (	/* Returns up-converted code point */
 800050e:	4606      	mov	r6, r0
		p = uc < 0x1000 ? cvt1 : cvt2;
 8000510:	bf3c      	itt	cc
 8000512:	4613      	movcc	r3, r2
 8000514:	2161      	movcc	r1, #97	; 0x61
		uc = (WORD)uni;
 8000516:	b280      	uxth	r0, r0
 8000518:	3304      	adds	r3, #4
 800051a:	e00d      	b.n	8000538 <ff_wtoupper.part.2+0x38>
		for (;;) {
			bc = *p++;								/* Get the block base */
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 800051c:	4288      	cmp	r0, r1
 800051e:	d30e      	bcc.n	800053e <ff_wtoupper.part.2+0x3e>
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8000520:	f833 2c02 	ldrh.w	r2, [r3, #-2]
 8000524:	b2d4      	uxtb	r4, r2
			if (uc < bc + nc) {	/* In the block? */
 8000526:	1865      	adds	r5, r4, r1
 8000528:	42ae      	cmp	r6, r5
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 800052a:	ea4f 2212 	mov.w	r2, r2, lsr #8
			if (uc < bc + nc) {	/* In the block? */
 800052e:	db08      	blt.n	8000542 <ff_wtoupper.part.2+0x42>
 8000530:	3304      	adds	r3, #4
				case 7: uc -= 80; break;			/* Shift -80 */
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
				}
				break;
			}
			if (cmd == 0) p += nc;	/* Skip table if needed */
 8000532:	b17a      	cbz	r2, 8000554 <ff_wtoupper.part.2+0x54>
 8000534:	f833 1c04 	ldrh.w	r1, [r3, #-4]
			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8000538:	461f      	mov	r7, r3
			if (bc == 0 || uc < bc) break;			/* Not matched? */
 800053a:	2900      	cmp	r1, #0
 800053c:	d1ee      	bne.n	800051c <ff_wtoupper.part.2+0x1c>
		}
		uni = uc;
	}

	return uni;
}
 800053e:	bcf0      	pop	{r4, r5, r6, r7}
 8000540:	4770      	bx	lr
				switch (cmd) {
 8000542:	2a08      	cmp	r2, #8
 8000544:	d8fb      	bhi.n	800053e <ff_wtoupper.part.2+0x3e>
 8000546:	e8df f002 	tbb	[pc, r2]
 800054a:	120e      	.short	0x120e
 800054c:	211e1b18 	.word	0x211e1b18
 8000550:	2724      	.short	0x2724
 8000552:	0a          	.byte	0x0a
 8000553:	00          	.byte	0x00
			if (cmd == 0) p += nc;	/* Skip table if needed */
 8000554:	eb07 0344 	add.w	r3, r7, r4, lsl #1
 8000558:	f837 1014 	ldrh.w	r1, [r7, r4, lsl #1]
 800055c:	e7dc      	b.n	8000518 <ff_wtoupper.part.2+0x18>
				case 8:	uc -= 0x1C60; break;		/* Shift -0x1C60 */
 800055e:	f5a0 50e3 	sub.w	r0, r0, #7264	; 0x1c60
 8000562:	b280      	uxth	r0, r0
 8000564:	e7eb      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 0:	uc = p[uc - bc]; break;		/* Table conversion */
 8000566:	1a71      	subs	r1, r6, r1
 8000568:	f833 0011 	ldrh.w	r0, [r3, r1, lsl #1]
 800056c:	e7e7      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 1:	uc -= (uc - bc) & 1; break;	/* Case pairs */
 800056e:	1a41      	subs	r1, r0, r1
 8000570:	f001 0301 	and.w	r3, r1, #1
 8000574:	1ac0      	subs	r0, r0, r3
 8000576:	b280      	uxth	r0, r0
 8000578:	e7e1      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 2: uc -= 16; break;			/* Shift -16 */
 800057a:	3810      	subs	r0, #16
 800057c:	b280      	uxth	r0, r0
 800057e:	e7de      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 3:	uc -= 32; break;			/* Shift -32 */
 8000580:	3820      	subs	r0, #32
 8000582:	b280      	uxth	r0, r0
 8000584:	e7db      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 4:	uc -= 48; break;			/* Shift -48 */
 8000586:	3830      	subs	r0, #48	; 0x30
 8000588:	b280      	uxth	r0, r0
 800058a:	e7d8      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 5:	uc -= 26; break;			/* Shift -26 */
 800058c:	381a      	subs	r0, #26
 800058e:	b280      	uxth	r0, r0
 8000590:	e7d5      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 6:	uc += 8; break;				/* Shift +8 */
 8000592:	3008      	adds	r0, #8
 8000594:	b280      	uxth	r0, r0
 8000596:	e7d2      	b.n	800053e <ff_wtoupper.part.2+0x3e>
				case 7: uc -= 80; break;			/* Shift -80 */
 8000598:	3850      	subs	r0, #80	; 0x50
 800059a:	b280      	uxth	r0, r0
 800059c:	e7cf      	b.n	800053e <ff_wtoupper.part.2+0x3e>
 800059e:	bf00      	nop
 80005a0:	08004124 	.word	0x08004124
 80005a4:	08004318 	.word	0x08004318
	...

080005b0 <mem_cpy.part.0>:
/*-----------------------------------------------------------------------*/
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static void mem_cpy (void* dst, const void* src, UINT cnt)
 80005b0:	440a      	add	r2, r1
 80005b2:	3801      	subs	r0, #1
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

	if (cnt != 0) {
		do {
			*d++ = *s++;
 80005b4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80005b8:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
 80005bc:	4291      	cmp	r1, r2
 80005be:	d1f9      	bne.n	80005b4 <mem_cpy.part.0+0x4>
	}
}
 80005c0:	4770      	bx	lr
 80005c2:	bf00      	nop
	...

080005d0 <get_ldnumber>:
#if FF_STR_VOLUME_ID		/* Find string volume ID */
	const char *sp;
	char c;
#endif

	tt = tp = *path;
 80005d0:	6801      	ldr	r1, [r0, #0]
	if (!tp) return vol;	/* Invalid path name? */
 80005d2:	b1d9      	cbz	r1, 800060c <get_ldnumber+0x3c>
 80005d4:	460a      	mov	r2, r1
 80005d6:	e001      	b.n	80005dc <get_ldnumber+0xc>
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
 80005d8:	2b3a      	cmp	r3, #58	; 0x3a
 80005da:	d005      	beq.n	80005e8 <get_ldnumber+0x18>
 80005dc:	f812 3b01 	ldrb.w	r3, [r2], #1
 80005e0:	2b1f      	cmp	r3, #31
 80005e2:	d8f9      	bhi.n	80005d8 <get_ldnumber+0x8>
#if FF_FS_RPATH != 0
	vol = CurrVol;	/* Default drive is current drive */
#else
	vol = 0;		/* Default drive is 0 */
#endif
	return vol;		/* Return the default drive */
 80005e4:	2000      	movs	r0, #0
}
 80005e6:	4770      	bx	lr
{
 80005e8:	b410      	push	{r4}
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
 80005ea:	780b      	ldrb	r3, [r1, #0]
 80005ec:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 80005f0:	2c09      	cmp	r4, #9
 80005f2:	d808      	bhi.n	8000606 <get_ldnumber+0x36>
 80005f4:	3102      	adds	r1, #2
 80005f6:	428a      	cmp	r2, r1
 80005f8:	d105      	bne.n	8000606 <get_ldnumber+0x36>
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
 80005fa:	2b30      	cmp	r3, #48	; 0x30
 80005fc:	d103      	bne.n	8000606 <get_ldnumber+0x36>
			*path = tt;		/* Snip the drive prefix off */
 80005fe:	6002      	str	r2, [r0, #0]
 8000600:	2000      	movs	r0, #0
}
 8000602:	bc10      	pop	{r4}
 8000604:	4770      	bx	lr
	if (!tp) return vol;	/* Invalid path name? */
 8000606:	f04f 30ff 	mov.w	r0, #4294967295
 800060a:	e7fa      	b.n	8000602 <get_ldnumber+0x32>
 800060c:	f04f 30ff 	mov.w	r0, #4294967295
 8000610:	4770      	bx	lr
 8000612:	bf00      	nop
	...

08000620 <sdc_lld_is_write_protected>:
bool sdc_lld_sync(SDCDriver *sdcp) {

  /* CHTODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
}
 8000620:	2000      	movs	r0, #0
 8000622:	4770      	bx	lr
	...

08000630 <disk_initialize>:
    BYTE pdrv         /* Physical drive number (0..) */
)
{
  DSTATUS stat;

  switch (pdrv) {
 8000630:	b928      	cbnz	r0, 800063e <disk_initialize+0xe>
    return stat;
#else
  case SDC:
    stat = 0;
    /* It is initialized externally, just reads the status.*/
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
 8000632:	4b04      	ldr	r3, [pc, #16]	; (8000644 <disk_initialize+0x14>)
 8000634:	7918      	ldrb	r0, [r3, #4]
    if (sdcIsWriteProtected(&FATFS_HAL_DEVICE))
      stat |=  STA_PROTECT;
    return stat;
#endif
  }
  return STA_NOINIT;
 8000636:	3805      	subs	r0, #5
 8000638:	bf18      	it	ne
 800063a:	2001      	movne	r0, #1
 800063c:	4770      	bx	lr
 800063e:	2001      	movs	r0, #1
}
 8000640:	4770      	bx	lr
 8000642:	bf00      	nop
 8000644:	20000884 	.word	0x20000884
	...

08000650 <_port_irq_epilogue>:
 8000650:	2320      	movs	r3, #32
 8000652:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000656:	4b0d      	ldr	r3, [pc, #52]	; (800068c <_port_irq_epilogue+0x3c>)
 8000658:	685b      	ldr	r3, [r3, #4]
 800065a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800065e:	d102      	bne.n	8000666 <_port_irq_epilogue+0x16>
 8000660:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000664:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000666:	f3ef 8309 	mrs	r3, PSP
    s_psp -= sizeof (struct port_extctx);
 800066a:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 800066c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8000670:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8000672:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8000676:	4a06      	ldr	r2, [pc, #24]	; (8000690 <_port_irq_epilogue+0x40>)
 8000678:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800067a:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
 800067c:	6889      	ldr	r1, [r1, #8]
 800067e:	6892      	ldr	r2, [r2, #8]
 8000680:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
 8000682:	bf8c      	ite	hi
 8000684:	4a03      	ldrhi	r2, [pc, #12]	; (8000694 <_port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
 8000686:	4a04      	ldrls	r2, [pc, #16]	; (8000698 <_port_irq_epilogue+0x48>)
 8000688:	619a      	str	r2, [r3, #24]
 800068a:	4770      	bx	lr
 800068c:	e000ed00 	.word	0xe000ed00
 8000690:	20000d04 	.word	0x20000d04
 8000694:	080002e3 	.word	0x080002e3
 8000698:	080002e6 	.word	0x080002e6
 800069c:	00000000 	.word	0x00000000

080006a0 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80006a0:	4b08      	ldr	r3, [pc, #32]	; (80006c4 <chCoreAllocAlignedI+0x24>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80006a2:	b410      	push	{r4}
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80006a4:	e9d3 4200 	ldrd	r4, r2, [r3]
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80006a8:	4249      	negs	r1, r1
 80006aa:	1a10      	subs	r0, r2, r0
 80006ac:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80006ae:	42a0      	cmp	r0, r4
 80006b0:	d304      	bcc.n	80006bc <chCoreAllocAlignedI+0x1c>
 80006b2:	4282      	cmp	r2, r0
 80006b4:	d302      	bcc.n	80006bc <chCoreAllocAlignedI+0x1c>
  ch_memcore.topmem = prev;
 80006b6:	6058      	str	r0, [r3, #4]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 80006b8:	bc10      	pop	{r4}
 80006ba:	4770      	bx	lr
    return NULL;
 80006bc:	2000      	movs	r0, #0
 80006be:	bc10      	pop	{r4}
 80006c0:	4770      	bx	lr
 80006c2:	bf00      	nop
 80006c4:	20000ea0 	.word	0x20000ea0
	...

080006d0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80006d0:	4b0e      	ldr	r3, [pc, #56]	; (800070c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80006d2:	4a0f      	ldr	r2, [pc, #60]	; (8000710 <chTMStopMeasurementX+0x40>)
 80006d4:	685b      	ldr	r3, [r3, #4]
  tmp->n++;
 80006d6:	68c1      	ldr	r1, [r0, #12]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80006d8:	b4f0      	push	{r4, r5, r6, r7}
  tmp->last = (now - tmp->last) - offset;
 80006da:	6884      	ldr	r4, [r0, #8]
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80006dc:	6f56      	ldr	r6, [r2, #116]	; 0x74
  if (tmp->last > tmp->worst) {
 80006de:	6842      	ldr	r2, [r0, #4]
  tmp->last = (now - tmp->last) - offset;
 80006e0:	1b1b      	subs	r3, r3, r4
  tmp->cumulative += (rttime_t)tmp->last;
 80006e2:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 80006e6:	1b9b      	subs	r3, r3, r6
  tmp->cumulative += (rttime_t)tmp->last;
 80006e8:	18e6      	adds	r6, r4, r3
 80006ea:	f145 0700 	adc.w	r7, r5, #0
  if (tmp->last > tmp->worst) {
 80006ee:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 80006f0:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 80006f2:	bf88      	it	hi
 80006f4:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 80006f6:	3101      	adds	r1, #1
  if (tmp->last < tmp->best) {
 80006f8:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
 80006fa:	e9c0 6704 	strd	r6, r7, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 80006fe:	e9c0 3102 	strd	r3, r1, [r0, #8]
    tmp->best = tmp->last;
 8000702:	bf38      	it	cc
 8000704:	6003      	strcc	r3, [r0, #0]
}
 8000706:	bcf0      	pop	{r4, r5, r6, r7}
 8000708:	4770      	bx	lr
 800070a:	bf00      	nop
 800070c:	e0001000 	.word	0xe0001000
 8000710:	20000d04 	.word	0x20000d04
	...

08000720 <chTMStartMeasurementX>:
 8000720:	4b01      	ldr	r3, [pc, #4]	; (8000728 <chTMStartMeasurementX+0x8>)
 8000722:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8000724:	6083      	str	r3, [r0, #8]
}
 8000726:	4770      	bx	lr
 8000728:	e0001000 	.word	0xe0001000
 800072c:	00000000 	.word	0x00000000

08000730 <wakeup>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000730:	2320      	movs	r3, #32
 8000732:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 8000736:	f890 3020 	ldrb.w	r3, [r0, #32]
 800073a:	2b07      	cmp	r3, #7
 800073c:	d80e      	bhi.n	800075c <wakeup+0x2c>
 800073e:	e8df f003 	tbb	[pc, r3]
 8000742:	0d28      	.short	0x0d28
 8000744:	0408240d 	.word	0x0408240d
 8000748:	080d      	.short	0x080d
    chSemFastSignalI(tp->u.wtsemp);
 800074a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800074c:	6893      	ldr	r3, [r2, #8]
 800074e:	3301      	adds	r3, #1
 8000750:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8000752:	e9d0 2300 	ldrd	r2, r3, [r0]
 8000756:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000758:	6802      	ldr	r2, [r0, #0]
 800075a:	6053      	str	r3, [r2, #4]
static void wakeup(void *p) {
 800075c:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 800075e:	2200      	movs	r2, #0
  tp->u.rdymsg = MSG_TIMEOUT;
 8000760:	f04f 34ff 	mov.w	r4, #4294967295
  } while (cp->prio >= tp->prio);
 8000764:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000766:	4b0d      	ldr	r3, [pc, #52]	; (800079c <wakeup+0x6c>)
  tp->u.rdymsg = MSG_TIMEOUT;
 8000768:	6244      	str	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 800076a:	f880 2020 	strb.w	r2, [r0, #32]
    cp = cp->queue.next;
 800076e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000770:	689a      	ldr	r2, [r3, #8]
 8000772:	428a      	cmp	r2, r1
 8000774:	d2fb      	bcs.n	800076e <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
 8000776:	685a      	ldr	r2, [r3, #4]
 8000778:	2100      	movs	r1, #0
 800077a:	e9c0 3200 	strd	r3, r2, [r0]
  tp->queue.prev->queue.next = tp;
 800077e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000780:	6058      	str	r0, [r3, #4]
 8000782:	f381 8811 	msr	BASEPRI, r1
}
 8000786:	bc10      	pop	{r4}
 8000788:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 800078a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800078c:	2200      	movs	r2, #0
 800078e:	601a      	str	r2, [r3, #0]
 8000790:	e7e4      	b.n	800075c <wakeup+0x2c>
 8000792:	2300      	movs	r3, #0
 8000794:	f383 8811 	msr	BASEPRI, r3
 8000798:	4770      	bx	lr
 800079a:	bf00      	nop
 800079c:	20000d04 	.word	0x20000d04

080007a0 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 80007a0:	4601      	mov	r1, r0
  tp->state = CH_STATE_READY;
 80007a2:	2200      	movs	r2, #0
  cp = (thread_t *)&ch.rlist.queue;
 80007a4:	4b07      	ldr	r3, [pc, #28]	; (80007c4 <chSchReadyI+0x24>)
  } while (cp->prio >= tp->prio);
 80007a6:	6880      	ldr	r0, [r0, #8]
  tp->state = CH_STATE_READY;
 80007a8:	f881 2020 	strb.w	r2, [r1, #32]
    cp = cp->queue.next;
 80007ac:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80007ae:	689a      	ldr	r2, [r3, #8]
 80007b0:	4282      	cmp	r2, r0
 80007b2:	d2fb      	bcs.n	80007ac <chSchReadyI+0xc>
  tp->queue.prev             = cp->queue.prev;
 80007b4:	685a      	ldr	r2, [r3, #4]
}
 80007b6:	4608      	mov	r0, r1
  tp->queue.prev             = cp->queue.prev;
 80007b8:	e9c1 3200 	strd	r3, r2, [r1]
  tp->queue.prev->queue.next = tp;
 80007bc:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 80007be:	6059      	str	r1, [r3, #4]
}
 80007c0:	4770      	bx	lr
 80007c2:	bf00      	nop
 80007c4:	20000d04 	.word	0x20000d04
	...

080007d0 <chEvtBroadcastFlagsI.constprop.23>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80007d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80007d2:	4f16      	ldr	r7, [pc, #88]	; (800082c <chEvtBroadcastFlagsI.constprop.23+0x5c>)
 80007d4:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80007d8:	42bc      	cmp	r4, r7
 80007da:	d020      	beq.n	800081e <chEvtBroadcastFlagsI.constprop.23+0x4e>
 80007dc:	4605      	mov	r5, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 80007de:	2600      	movs	r6, #0
 80007e0:	e004      	b.n	80007ec <chEvtBroadcastFlagsI.constprop.23+0x1c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80007e2:	2a0b      	cmp	r2, #11
 80007e4:	d01c      	beq.n	8000820 <chEvtBroadcastFlagsI.constprop.23+0x50>
    elp = elp->next;
 80007e6:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80007e8:	42bc      	cmp	r4, r7
 80007ea:	d018      	beq.n	800081e <chEvtBroadcastFlagsI.constprop.23+0x4e>
    elp->flags |= flags;
 80007ec:	68e3      	ldr	r3, [r4, #12]
 80007ee:	432b      	orrs	r3, r5
 80007f0:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80007f2:	b115      	cbz	r5, 80007fa <chEvtBroadcastFlagsI.constprop.23+0x2a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 80007f4:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 80007f6:	421d      	tst	r5, r3
 80007f8:	d0f5      	beq.n	80007e6 <chEvtBroadcastFlagsI.constprop.23+0x16>
  tp->epending |= events;
 80007fa:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 80007fe:	6b41      	ldr	r1, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000800:	f890 2020 	ldrb.w	r2, [r0, #32]
  tp->epending |= events;
 8000804:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 8000806:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 8000808:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
 800080a:	d1ea      	bne.n	80007e2 <chEvtBroadcastFlagsI.constprop.23+0x12>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800080c:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 800080e:	4213      	tst	r3, r2
 8000810:	d0e9      	beq.n	80007e6 <chEvtBroadcastFlagsI.constprop.23+0x16>
    tp->u.rdymsg = MSG_OK;
 8000812:	6246      	str	r6, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000814:	f7ff ffc4 	bl	80007a0 <chSchReadyI>
    elp = elp->next;
 8000818:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 800081a:	42bc      	cmp	r4, r7
 800081c:	d1e6      	bne.n	80007ec <chEvtBroadcastFlagsI.constprop.23+0x1c>
}
 800081e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8000820:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 8000822:	ea32 0303 	bics.w	r3, r2, r3
 8000826:	d1de      	bne.n	80007e6 <chEvtBroadcastFlagsI.constprop.23+0x16>
 8000828:	e7f3      	b.n	8000812 <chEvtBroadcastFlagsI.constprop.23+0x42>
 800082a:	bf00      	nop
 800082c:	20000808 	.word	0x20000808

08000830 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000830:	e7fe      	b.n	8000830 <_idle_thread>
 8000832:	bf00      	nop
	...

08000840 <sdc_lld_is_card_inserted>:
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {

  (void)sdcp;
  /* CHTODO: Fill the implementation.*/
  return true;
}
 8000840:	2001      	movs	r0, #1
 8000842:	4770      	bx	lr
	...

08000850 <sdc_lld_collect_errors.isra.0>:
  if (sta & SDIO_STA_CCRCFAIL)
 8000850:	f001 0301 	and.w	r3, r1, #1
  if (sta & SDIO_STA_DCRCFAIL)
 8000854:	078a      	lsls	r2, r1, #30
    errors |= SDC_DATA_CRC_ERROR;
 8000856:	bf48      	it	mi
 8000858:	f043 0302 	orrmi.w	r3, r3, #2
  if (sta & SDIO_STA_CTIMEOUT)
 800085c:	074a      	lsls	r2, r1, #29
    errors |= SDC_COMMAND_TIMEOUT;
 800085e:	bf48      	it	mi
 8000860:	f043 0308 	orrmi.w	r3, r3, #8
  if (sta & SDIO_STA_DTIMEOUT)
 8000864:	070a      	lsls	r2, r1, #28
    errors |= SDC_DATA_TIMEOUT;
 8000866:	bf48      	it	mi
 8000868:	f043 0304 	orrmi.w	r3, r3, #4
  if (sta & SDIO_STA_TXUNDERR)
 800086c:	06ca      	lsls	r2, r1, #27
    errors |= SDC_TX_UNDERRUN;
 800086e:	bf48      	it	mi
 8000870:	f043 0310 	orrmi.w	r3, r3, #16
  if (sta & SDIO_STA_RXOVERR)
 8000874:	068a      	lsls	r2, r1, #26
    errors |= SDC_RX_OVERRUN;
 8000876:	bf48      	it	mi
 8000878:	f043 0320 	orrmi.w	r3, r3, #32
  if (sta & SDIO_STA_STBITERR)
 800087c:	058a      	lsls	r2, r1, #22
  sdcp->errors |= errors;
 800087e:	6802      	ldr	r2, [r0, #0]
    errors |= SDC_STARTBIT_ERROR;
 8000880:	bf48      	it	mi
 8000882:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
  sdcp->errors |= errors;
 8000886:	4313      	orrs	r3, r2
 8000888:	6003      	str	r3, [r0, #0]
}
 800088a:	4770      	bx	lr
 800088c:	0000      	movs	r0, r0
	...

08000890 <sdc_lld_send_cmd_long_crc>:
                               uint32_t *resp) {
 8000890:	b510      	push	{r4, lr}
  sdcp->sdio->ARG = arg;
 8000892:	6c84      	ldr	r4, [r0, #72]	; 0x48
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_WAITRESP_1 |
 8000894:	f441 6198 	orr.w	r1, r1, #1216	; 0x4c0
  sdcp->sdio->ARG = arg;
 8000898:	60a2      	str	r2, [r4, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_WAITRESP_1 |
 800089a:	60e1      	str	r1, [r4, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 800089c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800089e:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 80008a2:	d0fb      	beq.n	800089c <sdc_lld_send_cmd_long_crc+0xc>
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 80008a4:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (STM32_SDIO_STA_ERROR_MASK)) != 0) {
 80008a6:	f011 023f 	ands.w	r2, r1, #63	; 0x3f
 80008aa:	d109      	bne.n	80008c0 <sdc_lld_send_cmd_long_crc+0x30>
  *resp++ = sdcp->sdio->RESP4;
 80008ac:	6a21      	ldr	r1, [r4, #32]
 80008ae:	6019      	str	r1, [r3, #0]
  *resp++ = sdcp->sdio->RESP3;
 80008b0:	69e1      	ldr	r1, [r4, #28]
 80008b2:	6059      	str	r1, [r3, #4]
  *resp++ = sdcp->sdio->RESP2;
 80008b4:	69a1      	ldr	r1, [r4, #24]
 80008b6:	6099      	str	r1, [r3, #8]
  *resp   = sdcp->sdio->RESP1;
 80008b8:	6961      	ldr	r1, [r4, #20]
 80008ba:	60d9      	str	r1, [r3, #12]
  return HAL_SUCCESS;
 80008bc:	4610      	mov	r0, r2
}
 80008be:	bd10      	pop	{r4, pc}
    sdc_lld_collect_errors(sdcp, sta);
 80008c0:	3034      	adds	r0, #52	; 0x34
 80008c2:	f7ff ffc5 	bl	8000850 <sdc_lld_collect_errors.isra.0>
    return HAL_FAILED;
 80008c6:	2001      	movs	r0, #1
}
 80008c8:	bd10      	pop	{r4, pc}
 80008ca:	bf00      	nop
 80008cc:	0000      	movs	r0, r0
	...

080008d0 <sdc_lld_send_cmd_short_crc>:
                                uint32_t *resp) {
 80008d0:	b510      	push	{r4, lr}
  sdcp->sdio->ARG = arg;
 80008d2:	6c84      	ldr	r4, [r0, #72]	; 0x48
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 80008d4:	f441 6188 	orr.w	r1, r1, #1088	; 0x440
  sdcp->sdio->ARG = arg;
 80008d8:	60a2      	str	r2, [r4, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 80008da:	60e1      	str	r1, [r4, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 80008dc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80008de:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 80008e2:	d0fb      	beq.n	80008dc <sdc_lld_send_cmd_short_crc+0xc>
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL);
 80008e4:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (SDIO_STA_CTIMEOUT | SDIO_STA_CCRCFAIL)) != 0) {
 80008e6:	f011 0205 	ands.w	r2, r1, #5
 80008ea:	d103      	bne.n	80008f4 <sdc_lld_send_cmd_short_crc+0x24>
  *resp = sdcp->sdio->RESP1;
 80008ec:	6961      	ldr	r1, [r4, #20]
 80008ee:	6019      	str	r1, [r3, #0]
  return HAL_SUCCESS;
 80008f0:	4610      	mov	r0, r2
}
 80008f2:	bd10      	pop	{r4, pc}
    sdc_lld_collect_errors(sdcp, sta);
 80008f4:	3034      	adds	r0, #52	; 0x34
 80008f6:	f7ff ffab 	bl	8000850 <sdc_lld_collect_errors.isra.0>
    return HAL_FAILED;
 80008fa:	2001      	movs	r0, #1
}
 80008fc:	bd10      	pop	{r4, pc}
 80008fe:	bf00      	nop

08000900 <sdc_lld_init>:
void sdc_lld_init(void) {
 8000900:	b430      	push	{r4, r5}
 *
 * @init
 */
void sdcObjectInit(SDCDriver *sdcp) {

  sdcp->vmt      = &sdc_vmt;
 8000902:	4b0c      	ldr	r3, [pc, #48]	; (8000934 <sdc_lld_init+0x34>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000904:	490c      	ldr	r1, [pc, #48]	; (8000938 <sdc_lld_init+0x38>)
 8000906:	4a0d      	ldr	r2, [pc, #52]	; (800093c <sdc_lld_init+0x3c>)
 8000908:	601a      	str	r2, [r3, #0]
  SDCD1.sdio   = SDIO;
 800090a:	4d0d      	ldr	r5, [pc, #52]	; (8000940 <sdc_lld_init+0x40>)
 800090c:	649d      	str	r5, [r3, #72]	; 0x48
  sdcp->state    = BLK_STOP;
 800090e:	2201      	movs	r2, #1
 8000910:	2490      	movs	r4, #144	; 0x90
 8000912:	711a      	strb	r2, [r3, #4]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000914:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000918:	f881 4331 	strb.w	r4, [r1, #817]	; 0x331
  sdcp->errors   = SDC_NO_ERROR;
 800091c:	2200      	movs	r2, #0
 800091e:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000920:	bc30      	pop	{r4, r5}
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000922:	f8c1 0184 	str.w	r0, [r1, #388]	; 0x184
  sdcp->config   = NULL;
 8000926:	62da      	str	r2, [r3, #44]	; 0x2c
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000928:	6048      	str	r0, [r1, #4]
  sdcp->capacity = 0;
 800092a:	629a      	str	r2, [r3, #40]	; 0x28
  SDCD1.thread = NULL;
 800092c:	63da      	str	r2, [r3, #60]	; 0x3c
  SDCD1.dma    = NULL;
 800092e:	645a      	str	r2, [r3, #68]	; 0x44
}
 8000930:	4770      	bx	lr
 8000932:	bf00      	nop
 8000934:	20000884 	.word	0x20000884
 8000938:	e000e100 	.word	0xe000e100
 800093c:	0800450c 	.word	0x0800450c
 8000940:	40012c00 	.word	0x40012c00
	...

08000950 <sdc_lld_error_cleanup>:
                                  uint32_t *resp) {
 8000950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sta = sdcp->sdio->STA;
 8000954:	e9d0 3511 	ldrd	r3, r5, [r0, #68]	; 0x44
                                  uint32_t *resp) {
 8000958:	4606      	mov	r6, r0
  dmaStreamClearInterrupt(sdcp->dma);
 800095a:	7a58      	ldrb	r0, [r3, #9]
  uint32_t sta = sdcp->sdio->STA;
 800095c:	f8d5 e034 	ldr.w	lr, [r5, #52]	; 0x34
  dmaStreamDisable(sdcp->dma);
 8000960:	e9d3 3c00 	ldrd	r3, ip, [r3]
  dmaStreamClearInterrupt(sdcp->dma);
 8000964:	243d      	movs	r4, #61	; 0x3d
 8000966:	fa04 f000 	lsl.w	r0, r4, r0
 800096a:	f8cc 0000 	str.w	r0, [ip]
  dmaStreamDisable(sdcp->dma);
 800096e:	681c      	ldr	r4, [r3, #0]
 8000970:	f024 041f 	bic.w	r4, r4, #31
                                  uint32_t *resp) {
 8000974:	4688      	mov	r8, r1
 8000976:	4617      	mov	r7, r2
  dmaStreamDisable(sdcp->dma);
 8000978:	601c      	str	r4, [r3, #0]
 800097a:	681c      	ldr	r4, [r3, #0]
 800097c:	f014 0401 	ands.w	r4, r4, #1
 8000980:	d1fb      	bne.n	800097a <sdc_lld_error_cleanup+0x2a>
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8000982:	4b0c      	ldr	r3, [pc, #48]	; (80009b4 <sdc_lld_error_cleanup+0x64>)
  dmaStreamDisable(sdcp->dma);
 8000984:	f8cc 0000 	str.w	r0, [ip]
  sdc_lld_collect_errors(sdcp, sta);
 8000988:	4671      	mov	r1, lr
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 800098a:	63ab      	str	r3, [r5, #56]	; 0x38
  sdc_lld_collect_errors(sdcp, sta);
 800098c:	f106 0034 	add.w	r0, r6, #52	; 0x34
  sdcp->sdio->MASK  = 0;
 8000990:	63ec      	str	r4, [r5, #60]	; 0x3c
  sdcp->sdio->DCTRL = 0;
 8000992:	62ec      	str	r4, [r5, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 8000994:	f7ff ff5c 	bl	8000850 <sdc_lld_collect_errors.isra.0>
  if (n > 1)
 8000998:	f1b8 0f01 	cmp.w	r8, #1
 800099c:	d907      	bls.n	80009ae <sdc_lld_error_cleanup+0x5e>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800099e:	463b      	mov	r3, r7
 80009a0:	4622      	mov	r2, r4
 80009a2:	4630      	mov	r0, r6
 80009a4:	210c      	movs	r1, #12
}
 80009a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 80009aa:	f7ff bf91 	b.w	80008d0 <sdc_lld_send_cmd_short_crc>
}
 80009ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80009b2:	bf00      	nop
 80009b4:	00c007ff 	.word	0x00c007ff
	...

080009c0 <_ctl>:
#else
    break;
#endif
  }
  return MSG_OK;
}
 80009c0:	2000      	movs	r0, #0
 80009c2:	4770      	bx	lr
	...

080009d0 <sdcGetInfo>:
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 80009d0:	7903      	ldrb	r3, [r0, #4]
 80009d2:	2b05      	cmp	r3, #5
 80009d4:	d001      	beq.n	80009da <sdcGetInfo+0xa>
    return HAL_FAILED;
 80009d6:	2001      	movs	r0, #1

  bdip->blk_num = sdcp->capacity;
  bdip->blk_size = MMCSD_BLOCK_SIZE;

  return HAL_SUCCESS;
}
 80009d8:	4770      	bx	lr
  bdip->blk_num = sdcp->capacity;
 80009da:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80009dc:	604b      	str	r3, [r1, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 80009de:	f44f 7300 	mov.w	r3, #512	; 0x200
 80009e2:	600b      	str	r3, [r1, #0]
  return HAL_SUCCESS;
 80009e4:	2000      	movs	r0, #0
 80009e6:	4770      	bx	lr
	...

080009f0 <sdcSync>:
  if (sdcp->state != BLK_READY) {
 80009f0:	7900      	ldrb	r0, [r0, #4]
}
 80009f2:	3805      	subs	r0, #5
 80009f4:	bf18      	it	ne
 80009f6:	2001      	movne	r0, #1
 80009f8:	4770      	bx	lr
 80009fa:	bf00      	nop

080009fc <_mmcsd_get_capacity>:
  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 80009fc:	68c3      	ldr	r3, [r0, #12]
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 80009fe:	0f9b      	lsrs	r3, r3, #30
 8000a00:	d00a      	beq.n	8000a18 <_mmcsd_get_capacity+0x1c>
 8000a02:	2b01      	cmp	r3, #1
 8000a04:	d11a      	bne.n	8000a3c <_mmcsd_get_capacity+0x40>
           ((data[endidx] & endmask) << (32U - startoff));
 8000a06:	6883      	ldr	r3, [r0, #8]
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000a08:	88c2      	ldrh	r2, [r0, #6]
           ((data[endidx] & endmask) << (32U - startoff));
 8000a0a:	0418      	lsls	r0, r3, #16
 8000a0c:	f400 107c 	and.w	r0, r0, #4128768	; 0x3f0000
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000a10:	4310      	orrs	r0, r2
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8000a12:	3001      	adds	r0, #1
 8000a14:	0280      	lsls	r0, r0, #10
 8000a16:	4770      	bx	lr
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000a18:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
           ((data[endidx] & endmask) << (32U - startoff));
 8000a1c:	f640 70fc 	movw	r0, #4092	; 0xffc
 8000a20:	ea00 0083 	and.w	r0, r0, r3, lsl #2
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000a24:	ea40 7092 	orr.w	r0, r0, r2, lsr #30
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8000a28:	f3c2 32c2 	ubfx	r2, r2, #15, #3
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8000a2c:	3202      	adds	r2, #2
 8000a2e:	3001      	adds	r0, #1
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8000a30:	f3c3 4303 	ubfx	r3, r3, #16, #4
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8000a34:	4090      	lsls	r0, r2
 8000a36:	3b09      	subs	r3, #9
 8000a38:	4098      	lsls	r0, r3
 8000a3a:	4770      	bx	lr
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
 8000a3c:	2000      	movs	r0, #0
}
 8000a3e:	4770      	bx	lr

08000a40 <chSchGoSleepS>:
  thread_t *otp = currp;
 8000a40:	4b08      	ldr	r3, [pc, #32]	; (8000a64 <chSchGoSleepS+0x24>)
 8000a42:	6999      	ldr	r1, [r3, #24]
  thread_t *tp = tqp->next;
 8000a44:	681a      	ldr	r2, [r3, #0]
void chSchGoSleepS(tstate_t newstate) {
 8000a46:	b410      	push	{r4}
  otp->state = newstate;
 8000a48:	f881 0020 	strb.w	r0, [r1, #32]
  tqp->next             = tp->queue.next;
 8000a4c:	6810      	ldr	r0, [r2, #0]
 8000a4e:	6018      	str	r0, [r3, #0]
  currp->state = CH_STATE_CURRENT;
 8000a50:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000a52:	6043      	str	r3, [r0, #4]
 8000a54:	f882 4020 	strb.w	r4, [r2, #32]
  chSysSwitch(currp, otp);
 8000a58:	4610      	mov	r0, r2
}
 8000a5a:	bc10      	pop	{r4}
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000a5c:	619a      	str	r2, [r3, #24]
  chSysSwitch(currp, otp);
 8000a5e:	f7ff bc2f 	b.w	80002c0 <_port_switch>
 8000a62:	bf00      	nop
 8000a64:	20000d04 	.word	0x20000d04
	...

08000a70 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000a70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8000a72:	4a37      	ldr	r2, [pc, #220]	; (8000b50 <chMtxLockS+0xe0>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8000a74:	6883      	ldr	r3, [r0, #8]
  thread_t *ctp = currp;
 8000a76:	6995      	ldr	r5, [r2, #24]
  if (mp->owner != NULL) {
 8000a78:	2b00      	cmp	r3, #0
 8000a7a:	d040      	beq.n	8000afe <chMtxLockS+0x8e>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8000a7c:	68a9      	ldr	r1, [r5, #8]
 8000a7e:	689a      	ldr	r2, [r3, #8]
 8000a80:	4291      	cmp	r1, r2
 8000a82:	4604      	mov	r4, r0
 8000a84:	d907      	bls.n	8000a96 <chMtxLockS+0x26>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000a86:	f893 2020 	ldrb.w	r2, [r3, #32]
        tp->prio = ctp->prio;
 8000a8a:	6099      	str	r1, [r3, #8]
        switch (tp->state) {
 8000a8c:	2a06      	cmp	r2, #6
 8000a8e:	d03b      	beq.n	8000b08 <chMtxLockS+0x98>
 8000a90:	2a07      	cmp	r2, #7
 8000a92:	d015      	beq.n	8000ac0 <chMtxLockS+0x50>
 8000a94:	b342      	cbz	r2, 8000ae8 <chMtxLockS+0x78>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 8000a96:	4626      	mov	r6, r4
 8000a98:	4623      	mov	r3, r4
 8000a9a:	e003      	b.n	8000aa4 <chMtxLockS+0x34>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000a9c:	6899      	ldr	r1, [r3, #8]
 8000a9e:	68aa      	ldr	r2, [r5, #8]
 8000aa0:	4291      	cmp	r1, r2
 8000aa2:	d32a      	bcc.n	8000afa <chMtxLockS+0x8a>
    cp = cp->queue.next;
 8000aa4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000aa6:	429c      	cmp	r4, r3
 8000aa8:	d1f8      	bne.n	8000a9c <chMtxLockS+0x2c>
  tp->queue.prev             = cp->queue.prev;
 8000aaa:	6873      	ldr	r3, [r6, #4]
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000aac:	2006      	movs	r0, #6
 8000aae:	e9c5 6300 	strd	r6, r3, [r5]
  tp->queue.prev->queue.next = tp;
 8000ab2:	601d      	str	r5, [r3, #0]
  cp->queue.prev             = tp;
 8000ab4:	6075      	str	r5, [r6, #4]
      ctp->u.wtmtxp = mp;
 8000ab6:	626c      	str	r4, [r5, #36]	; 0x24
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 8000ab8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      chSchGoSleepS(CH_STATE_WTMTX);
 8000abc:	f7ff bfc0 	b.w	8000a40 <chSchGoSleepS>
  tp->queue.prev->queue.next = tp->queue.next;
 8000ac0:	e9d3 0200 	ldrd	r0, r2, [r3]
 8000ac4:	6010      	str	r0, [r2, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000ac6:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8000ac8:	6818      	ldr	r0, [r3, #0]
 8000aca:	6042      	str	r2, [r0, #4]
 8000acc:	4632      	mov	r2, r6
 8000ace:	e002      	b.n	8000ad6 <chMtxLockS+0x66>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000ad0:	6890      	ldr	r0, [r2, #8]
 8000ad2:	4288      	cmp	r0, r1
 8000ad4:	d332      	bcc.n	8000b3c <chMtxLockS+0xcc>
    cp = cp->queue.next;
 8000ad6:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000ad8:	4296      	cmp	r6, r2
 8000ada:	d1f9      	bne.n	8000ad0 <chMtxLockS+0x60>
  tp->queue.prev             = cp->queue.prev;
 8000adc:	6872      	ldr	r2, [r6, #4]
 8000ade:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8000ae2:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8000ae4:	6073      	str	r3, [r6, #4]
 8000ae6:	e7d6      	b.n	8000a96 <chMtxLockS+0x26>
  tp->queue.prev->queue.next = tp->queue.next;
 8000ae8:	e9d3 1200 	ldrd	r1, r2, [r3]
 8000aec:	6011      	str	r1, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000aee:	6819      	ldr	r1, [r3, #0]
          (void) chSchReadyI(queue_dequeue(tp));
 8000af0:	4618      	mov	r0, r3
 8000af2:	604a      	str	r2, [r1, #4]
 8000af4:	f7ff fe54 	bl	80007a0 <chSchReadyI>
 8000af8:	e7cd      	b.n	8000a96 <chMtxLockS+0x26>
    cp = cp->queue.next;
 8000afa:	461e      	mov	r6, r3
 8000afc:	e7d5      	b.n	8000aaa <chMtxLockS+0x3a>
    mp->next = ctp->mtxlist;
 8000afe:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8000b00:	e9c0 5302 	strd	r5, r3, [r0, #8]
    ctp->mtxlist = mp;
 8000b04:	63a8      	str	r0, [r5, #56]	; 0x38
}
 8000b06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  tp->queue.prev->queue.next = tp->queue.next;
 8000b08:	e9d3 0200 	ldrd	r0, r2, [r3]
 8000b0c:	6010      	str	r0, [r2, #0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000b0e:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8000b10:	6818      	ldr	r0, [r3, #0]
 8000b12:	4637      	mov	r7, r6
 8000b14:	6042      	str	r2, [r0, #4]
 8000b16:	4632      	mov	r2, r6
 8000b18:	e002      	b.n	8000b20 <chMtxLockS+0xb0>
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000b1a:	6890      	ldr	r0, [r2, #8]
 8000b1c:	4288      	cmp	r0, r1
 8000b1e:	d314      	bcc.n	8000b4a <chMtxLockS+0xda>
    cp = cp->queue.next;
 8000b20:	6812      	ldr	r2, [r2, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000b22:	4296      	cmp	r6, r2
 8000b24:	d1f9      	bne.n	8000b1a <chMtxLockS+0xaa>
  tp->queue.prev             = cp->queue.prev;
 8000b26:	687a      	ldr	r2, [r7, #4]
      while (tp->prio < ctp->prio) {
 8000b28:	68a9      	ldr	r1, [r5, #8]
 8000b2a:	e9c3 7200 	strd	r7, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8000b2e:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8000b30:	607b      	str	r3, [r7, #4]
          tp = tp->u.wtmtxp->owner;
 8000b32:	68b3      	ldr	r3, [r6, #8]
      while (tp->prio < ctp->prio) {
 8000b34:	689a      	ldr	r2, [r3, #8]
 8000b36:	428a      	cmp	r2, r1
 8000b38:	d3a5      	bcc.n	8000a86 <chMtxLockS+0x16>
 8000b3a:	e7ac      	b.n	8000a96 <chMtxLockS+0x26>
    cp = cp->queue.next;
 8000b3c:	4616      	mov	r6, r2
  tp->queue.prev             = cp->queue.prev;
 8000b3e:	6872      	ldr	r2, [r6, #4]
 8000b40:	e9c3 6200 	strd	r6, r2, [r3]
  tp->queue.prev->queue.next = tp;
 8000b44:	6013      	str	r3, [r2, #0]
  cp->queue.prev             = tp;
 8000b46:	6073      	str	r3, [r6, #4]
 8000b48:	e7a5      	b.n	8000a96 <chMtxLockS+0x26>
    cp = cp->queue.next;
 8000b4a:	4617      	mov	r7, r2
 8000b4c:	e7eb      	b.n	8000b26 <chMtxLockS+0xb6>
 8000b4e:	bf00      	nop
 8000b50:	20000d04 	.word	0x20000d04
	...

08000b60 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000b60:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (TIME_INFINITE != timeout) {
 8000b62:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000b64:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
 8000b66:	d04c      	beq.n	8000c02 <chSchGoSleepTimeoutS+0xa2>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8000b68:	4c41      	ldr	r4, [pc, #260]	; (8000c70 <chSchGoSleepTimeoutS+0x110>)
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b6a:	4625      	mov	r5, r4
 8000b6c:	2902      	cmp	r1, #2
 8000b6e:	f855 2f1c 	ldr.w	r2, [r5, #28]!
  vtp->par = par;
 8000b72:	69a3      	ldr	r3, [r4, #24]
 8000b74:	9305      	str	r3, [sp, #20]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000b76:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
 8000b7a:	4607      	mov	r7, r0
 8000b7c:	bf38      	it	cc
 8000b7e:	2102      	movcc	r1, #2
  vtp->func = vtfunc;
 8000b80:	483c      	ldr	r0, [pc, #240]	; (8000c74 <chSchGoSleepTimeoutS+0x114>)
 8000b82:	f8dc 3024 	ldr.w	r3, [ip, #36]	; 0x24
 8000b86:	9004      	str	r0, [sp, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000b88:	42aa      	cmp	r2, r5
 8000b8a:	d05b      	beq.n	8000c44 <chSchGoSleepTimeoutS+0xe4>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8000b8c:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8000b8e:	6890      	ldr	r0, [r2, #8]
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000b90:	1b9b      	subs	r3, r3, r6
 8000b92:	1859      	adds	r1, r3, r1

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8000b94:	d32f      	bcc.n	8000bf6 <chSchGoSleepTimeoutS+0x96>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
 8000b96:	6812      	ldr	r2, [r2, #0]
      delta -= p->delta;
 8000b98:	1a09      	subs	r1, r1, r0
 8000b9a:	6890      	ldr	r0, [r2, #8]
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000b9c:	4281      	cmp	r1, r0
 8000b9e:	d904      	bls.n	8000baa <chSchGoSleepTimeoutS+0x4a>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
    p = p->next;
 8000ba0:	6812      	ldr	r2, [r2, #0]
    delta -= p->delta;
 8000ba2:	1a09      	subs	r1, r1, r0
  while (p->delta < delta) {
 8000ba4:	6890      	ldr	r0, [r2, #8]
 8000ba6:	4288      	cmp	r0, r1
 8000ba8:	d3fa      	bcc.n	8000ba0 <chSchGoSleepTimeoutS+0x40>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000baa:	6853      	ldr	r3, [r2, #4]
 8000bac:	9302      	str	r3, [sp, #8]
  vtp->prev->next = vtp;
 8000bae:	ae01      	add	r6, sp, #4
  vtp->next = p;
 8000bb0:	9201      	str	r2, [sp, #4]
  vtp->prev->next = vtp;
 8000bb2:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
 8000bb4:	6056      	str	r6, [r2, #4]
  vtp->delta = delta;
 8000bb6:	9103      	str	r1, [sp, #12]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8000bb8:	6893      	ldr	r3, [r2, #8]
 8000bba:	1a59      	subs	r1, r3, r1

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8000bbc:	f04f 33ff 	mov.w	r3, #4294967295
  p->delta -= delta;
 8000bc0:	6091      	str	r1, [r2, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 8000bc2:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 8000bc4:	4638      	mov	r0, r7
 8000bc6:	f7ff ff3b 	bl	8000a40 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000bca:	9b04      	ldr	r3, [sp, #16]
 8000bcc:	b17b      	cbz	r3, 8000bee <chSchGoSleepTimeoutS+0x8e>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000bce:	69e2      	ldr	r2, [r4, #28]
 8000bd0:	9b01      	ldr	r3, [sp, #4]
 8000bd2:	42b2      	cmp	r2, r6
 8000bd4:	d01c      	beq.n	8000c10 <chSchGoSleepTimeoutS+0xb0>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000bd6:	9a02      	ldr	r2, [sp, #8]
 8000bd8:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8000bda:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;
 8000bdc:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000bde:	42ab      	cmp	r3, r5
    vtp->next->prev = vtp->prev;
 8000be0:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8000be2:	9104      	str	r1, [sp, #16]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000be4:	d003      	beq.n	8000bee <chSchGoSleepTimeoutS+0x8e>
      vtp->next->delta += vtp->delta;
 8000be6:	689a      	ldr	r2, [r3, #8]
 8000be8:	9903      	ldr	r1, [sp, #12]
 8000bea:	440a      	add	r2, r1
 8000bec:	609a      	str	r2, [r3, #8]
  return currp->u.rdymsg;
 8000bee:	69a3      	ldr	r3, [r4, #24]
}
 8000bf0:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000bf2:	b007      	add	sp, #28
 8000bf4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (delta < p->delta) {
 8000bf6:	4281      	cmp	r1, r0
 8000bf8:	d2d0      	bcs.n	8000b9c <chSchGoSleepTimeoutS+0x3c>
  return systime + (systime_t)interval;
 8000bfa:	440e      	add	r6, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000bfc:	f8cc 6034 	str.w	r6, [ip, #52]	; 0x34
 8000c00:	e7cc      	b.n	8000b9c <chSchGoSleepTimeoutS+0x3c>
 8000c02:	4c1b      	ldr	r4, [pc, #108]	; (8000c70 <chSchGoSleepTimeoutS+0x110>)
    chSchGoSleepS(newstate);
 8000c04:	f7ff ff1c 	bl	8000a40 <chSchGoSleepS>
  return currp->u.rdymsg;
 8000c08:	69a3      	ldr	r3, [r4, #24]
}
 8000c0a:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000c0c:	b007      	add	sp, #28
 8000c0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8000c10:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000c12:	42ab      	cmp	r3, r5
  ch.vtlist.next = vtp->next;
 8000c14:	61e3      	str	r3, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000c16:	605d      	str	r5, [r3, #4]
  vtp->func = NULL;
 8000c18:	9204      	str	r2, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000c1a:	d024      	beq.n	8000c66 <chSchGoSleepTimeoutS+0x106>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000c1c:	689a      	ldr	r2, [r3, #8]
 8000c1e:	9803      	ldr	r0, [sp, #12]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8000c20:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
 8000c22:	4402      	add	r2, r0
  return (systime_t)STM32_ST_TIM->CNT;
 8000c24:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000c28:	609a      	str	r2, [r3, #8]
 8000c2a:	6a43      	ldr	r3, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8000c2c:	1a5b      	subs	r3, r3, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000c2e:	429a      	cmp	r2, r3
 8000c30:	d9dd      	bls.n	8000bee <chSchGoSleepTimeoutS+0x8e>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000c32:	1ad0      	subs	r0, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8000c34:	2801      	cmp	r0, #1
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8000c36:	bf98      	it	ls
 8000c38:	1c9a      	addls	r2, r3, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c3a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
 8000c3e:	440a      	add	r2, r1
 8000c40:	635a      	str	r2, [r3, #52]	; 0x34
 8000c42:	e7d4      	b.n	8000bee <chSchGoSleepTimeoutS+0x8e>
      ch.vtlist.lasttime = now;
 8000c44:	62a3      	str	r3, [r4, #40]	; 0x28
 8000c46:	18c8      	adds	r0, r1, r3
      ch.vtlist.next = vtp;
 8000c48:	ae01      	add	r6, sp, #4
  STM32_ST_TIM->SR     = 0;
 8000c4a:	2200      	movs	r2, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c4c:	2302      	movs	r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8000c4e:	e9cd 5501 	strd	r5, r5, [sp, #4]
      vtp->delta = delay;
 8000c52:	9103      	str	r1, [sp, #12]
      ch.vtlist.prev = vtp;
 8000c54:	e9c4 6607 	strd	r6, r6, [r4, #28]
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000c58:	f8cc 0034 	str.w	r0, [ip, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000c5c:	f8cc 2010 	str.w	r2, [ip, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c60:	f8cc 300c 	str.w	r3, [ip, #12]
 8000c64:	e7ae      	b.n	8000bc4 <chSchGoSleepTimeoutS+0x64>
  STM32_ST_TIM->DIER = 0U;
 8000c66:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000c6a:	60da      	str	r2, [r3, #12]
 8000c6c:	e7bf      	b.n	8000bee <chSchGoSleepTimeoutS+0x8e>
 8000c6e:	bf00      	nop
 8000c70:	20000d04 	.word	0x20000d04
 8000c74:	08000731 	.word	0x08000731
	...

08000c80 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000c80:	b161      	cbz	r1, 8000c9c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000c82:	4b08      	ldr	r3, [pc, #32]	; (8000ca4 <chThdEnqueueTimeoutS+0x24>)
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8000c84:	b410      	push	{r4}
 8000c86:	4602      	mov	r2, r0
  tp->queue.prev             = tqp->prev;
 8000c88:	6844      	ldr	r4, [r0, #4]
  queue_insert(currp, tqp);
 8000c8a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000c8c:	2004      	movs	r0, #4
 8000c8e:	e9c3 2400 	strd	r2, r4, [r3]
  tp->queue.prev->queue.next = tp;
 8000c92:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8000c94:	6053      	str	r3, [r2, #4]
}
 8000c96:	bc10      	pop	{r4}
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000c98:	f7ff bf62 	b.w	8000b60 <chSchGoSleepTimeoutS>
}
 8000c9c:	f04f 30ff 	mov.w	r0, #4294967295
 8000ca0:	4770      	bx	lr
 8000ca2:	bf00      	nop
 8000ca4:	20000d04 	.word	0x20000d04
	...

08000cb0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000cb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000cb2:	4604      	mov	r4, r0
 8000cb4:	460f      	mov	r7, r1
 8000cb6:	4616      	mov	r6, r2
 8000cb8:	2320      	movs	r3, #32
 8000cba:	f383 8811 	msr	BASEPRI, r3
 8000cbe:	e003      	b.n	8000cc8 <oqPutTimeout+0x18>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
 8000cc0:	f7ff ffde 	bl	8000c80 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000cc4:	2800      	cmp	r0, #0
 8000cc6:	db18      	blt.n	8000cfa <oqPutTimeout+0x4a>
  while (oqIsFullI(oqp)) {
 8000cc8:	68a5      	ldr	r5, [r4, #8]
 8000cca:	4631      	mov	r1, r6
 8000ccc:	4620      	mov	r0, r4
 8000cce:	2d00      	cmp	r5, #0
 8000cd0:	d0f6      	beq.n	8000cc0 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000cd2:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000cd4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000cd6:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000cd8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000cda:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8000cdc:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000cde:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000ce0:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8000ce4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000ce6:	bf24      	itt	cs
 8000ce8:	68e3      	ldrcs	r3, [r4, #12]
 8000cea:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000cec:	69e3      	ldr	r3, [r4, #28]
 8000cee:	b103      	cbz	r3, 8000cf2 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 8000cf0:	4798      	blx	r3
 8000cf2:	2000      	movs	r0, #0
 8000cf4:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000cf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000cfa:	f385 8811 	msr	BASEPRI, r5
 8000cfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000d00 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000d00:	3030      	adds	r0, #48	; 0x30
 8000d02:	f7ff bfd5 	b.w	8000cb0 <oqPutTimeout>
 8000d06:	bf00      	nop
	...

08000d10 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000d10:	3030      	adds	r0, #48	; 0x30
 8000d12:	f04f 32ff 	mov.w	r2, #4294967295
 8000d16:	f7ff bfcb 	b.w	8000cb0 <oqPutTimeout>
 8000d1a:	bf00      	nop
 8000d1c:	0000      	movs	r0, r0
	...

08000d20 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000d20:	b570      	push	{r4, r5, r6, lr}
 8000d22:	2320      	movs	r3, #32
 8000d24:	4604      	mov	r4, r0
 8000d26:	460e      	mov	r6, r1
 8000d28:	f383 8811 	msr	BASEPRI, r3
 8000d2c:	e003      	b.n	8000d36 <iqGetTimeout+0x16>
 8000d2e:	f7ff ffa7 	bl	8000c80 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 8000d32:	2800      	cmp	r0, #0
 8000d34:	db1a      	blt.n	8000d6c <iqGetTimeout+0x4c>
  while (iqIsEmptyI(iqp)) {
 8000d36:	68a5      	ldr	r5, [r4, #8]
 8000d38:	4631      	mov	r1, r6
 8000d3a:	4620      	mov	r0, r4
 8000d3c:	2d00      	cmp	r5, #0
 8000d3e:	d0f6      	beq.n	8000d2e <iqGetTimeout+0xe>
  b = *iqp->q_rdptr++;
 8000d40:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
 8000d42:	68a3      	ldr	r3, [r4, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d44:	6920      	ldr	r0, [r4, #16]
  b = *iqp->q_rdptr++;
 8000d46:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8000d48:	3b01      	subs	r3, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8000d4a:	4282      	cmp	r2, r0
  iqp->q_counter--;
 8000d4c:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000d4e:	61a2      	str	r2, [r4, #24]
    iqp->q_rdptr = iqp->q_buffer;
 8000d50:	bf28      	it	cs
 8000d52:	68e3      	ldrcs	r3, [r4, #12]
  b = *iqp->q_rdptr++;
 8000d54:	780d      	ldrb	r5, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000d56:	bf28      	it	cs
 8000d58:	61a3      	strcs	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
 8000d5a:	69e3      	ldr	r3, [r4, #28]
 8000d5c:	b10b      	cbz	r3, 8000d62 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 8000d5e:	4620      	mov	r0, r4
 8000d60:	4798      	blx	r3
 8000d62:	2300      	movs	r3, #0
 8000d64:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8000d68:	4628      	mov	r0, r5
}
 8000d6a:	bd70      	pop	{r4, r5, r6, pc}
 8000d6c:	f385 8811 	msr	BASEPRI, r5
 8000d70:	bd70      	pop	{r4, r5, r6, pc}
 8000d72:	bf00      	nop
	...

08000d80 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000d80:	300c      	adds	r0, #12
 8000d82:	f7ff bfcd 	b.w	8000d20 <iqGetTimeout>
 8000d86:	bf00      	nop
	...

08000d90 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000d90:	300c      	adds	r0, #12
 8000d92:	f04f 31ff 	mov.w	r1, #4294967295
 8000d96:	f7ff bfc3 	b.w	8000d20 <iqGetTimeout>
 8000d9a:	bf00      	nop
 8000d9c:	0000      	movs	r0, r0
	...

08000da0 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
 8000da0:	b508      	push	{r3, lr}
 8000da2:	4601      	mov	r1, r0
 8000da4:	2320      	movs	r3, #32
 8000da6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8000daa:	2008      	movs	r0, #8
 8000dac:	f7ff fed8 	bl	8000b60 <chSchGoSleepTimeoutS>
 8000db0:	2300      	movs	r3, #0
 8000db2:	f383 8811 	msr	BASEPRI, r3
}
 8000db6:	bd08      	pop	{r3, pc}
	...

08000dc0 <_sdc_wait_for_transfer_state>:
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8000dc0:	b530      	push	{r4, r5, lr}
        MMCSD_R1_ERROR(resp[0])) {
 8000dc2:	4d0e      	ldr	r5, [pc, #56]	; (8000dfc <_sdc_wait_for_transfer_state+0x3c>)
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8000dc4:	b083      	sub	sp, #12
 8000dc6:	4604      	mov	r4, r0
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8000dc8:	ab01      	add	r3, sp, #4
 8000dca:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000dcc:	210d      	movs	r1, #13
 8000dce:	4620      	mov	r0, r4
 8000dd0:	f7ff fd7e 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8000dd4:	b978      	cbnz	r0, 8000df6 <_sdc_wait_for_transfer_state+0x36>
        MMCSD_R1_ERROR(resp[0])) {
 8000dd6:	9b01      	ldr	r3, [sp, #4]
                                   sdcp->rca, resp) ||
 8000dd8:	422b      	tst	r3, r5
    switch (MMCSD_R1_STS(resp[0])) {
 8000dda:	f3c3 2243 	ubfx	r2, r3, #9, #4
                                   sdcp->rca, resp) ||
 8000dde:	d109      	bne.n	8000df4 <_sdc_wait_for_transfer_state+0x34>
    switch (MMCSD_R1_STS(resp[0])) {
 8000de0:	2a04      	cmp	r2, #4
 8000de2:	d008      	beq.n	8000df6 <_sdc_wait_for_transfer_state+0x36>
  chThdSleep(delay);
 8000de4:	f04f 000a 	mov.w	r0, #10
 8000de8:	d304      	bcc.n	8000df4 <_sdc_wait_for_transfer_state+0x34>
 8000dea:	2a07      	cmp	r2, #7
 8000dec:	d802      	bhi.n	8000df4 <_sdc_wait_for_transfer_state+0x34>
 8000dee:	f7ff ffd7 	bl	8000da0 <chThdSleep>
 8000df2:	e7e9      	b.n	8000dc8 <_sdc_wait_for_transfer_state+0x8>
      return HAL_FAILED;
 8000df4:	2001      	movs	r0, #1
}
 8000df6:	b003      	add	sp, #12
 8000df8:	bd30      	pop	{r4, r5, pc}
 8000dfa:	bf00      	nop
 8000dfc:	fdffe008 	.word	0xfdffe008

08000e00 <sdcDisconnect>:
 8000e00:	2220      	movs	r2, #32
 8000e02:	f382 8811 	msr	BASEPRI, r2
  if (sdcp->state == BLK_ACTIVE) {
 8000e06:	7902      	ldrb	r2, [r0, #4]
 8000e08:	2a02      	cmp	r2, #2
 8000e0a:	d013      	beq.n	8000e34 <sdcDisconnect+0x34>
bool sdcDisconnect(SDCDriver *sdcp) {
 8000e0c:	b538      	push	{r3, r4, r5, lr}
  sdcp->state = BLK_DISCONNECTING;
 8000e0e:	2304      	movs	r3, #4
 8000e10:	4604      	mov	r4, r0
 8000e12:	7103      	strb	r3, [r0, #4]
 8000e14:	2500      	movs	r5, #0
 8000e16:	f385 8811 	msr	BASEPRI, r5
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8000e1a:	f7ff ffd1 	bl	8000dc0 <_sdc_wait_for_transfer_state>
  sdcp->sdio->CLKCR = 0;
 8000e1e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    sdcp->state = BLK_ACTIVE;
 8000e20:	2202      	movs	r2, #2
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8000e22:	b918      	cbnz	r0, 8000e2c <sdcDisconnect+0x2c>
 8000e24:	6058      	str	r0, [r3, #4]
  sdcp->sdio->POWER = 0;
 8000e26:	6018      	str	r0, [r3, #0]
  sdcp->state = BLK_ACTIVE;
 8000e28:	7122      	strb	r2, [r4, #4]
}
 8000e2a:	bd38      	pop	{r3, r4, r5, pc}
  sdcp->sdio->CLKCR = 0;
 8000e2c:	605d      	str	r5, [r3, #4]
  sdcp->sdio->POWER = 0;
 8000e2e:	601d      	str	r5, [r3, #0]
    sdcp->state = BLK_ACTIVE;
 8000e30:	7122      	strb	r2, [r4, #4]
}
 8000e32:	bd38      	pop	{r3, r4, r5, pc}
 8000e34:	2000      	movs	r0, #0
 8000e36:	f380 8811 	msr	BASEPRI, r0
 8000e3a:	4770      	bx	lr
 8000e3c:	0000      	movs	r0, r0
	...

08000e40 <sdc_lld_wait_transaction_end>:
                                         uint32_t *resp) {
 8000e40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000e44:	2320      	movs	r3, #32
 8000e46:	4606      	mov	r6, r0
 8000e48:	460f      	mov	r7, r1
 8000e4a:	4690      	mov	r8, r2
 8000e4c:	f383 8811 	msr	BASEPRI, r3
  if (sdcp->sdio->MASK != 0)
 8000e50:	6c84      	ldr	r4, [r0, #72]	; 0x48
 8000e52:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000e54:	bb13      	cbnz	r3, 8000e9c <sdc_lld_wait_transaction_end+0x5c>
  if ((sdcp->sdio->STA & SDIO_STA_DATAEND) == 0) {
 8000e56:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8000e58:	f410 7080 	ands.w	r0, r0, #256	; 0x100
 8000e5c:	d019      	beq.n	8000e92 <sdc_lld_wait_transaction_end+0x52>
  while (sdcp->dma->stream->CR & STM32_DMA_CR_EN)
 8000e5e:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000e60:	681d      	ldr	r5, [r3, #0]
 8000e62:	6828      	ldr	r0, [r5, #0]
 8000e64:	f010 0001 	ands.w	r0, r0, #1
 8000e68:	d1fb      	bne.n	8000e62 <sdc_lld_wait_transaction_end+0x22>
  dmaStreamClearInterrupt(sdcp->dma);
 8000e6a:	7a59      	ldrb	r1, [r3, #9]
 8000e6c:	685a      	ldr	r2, [r3, #4]
  sdcp->sdio->ICR = STM32_SDIO_ICR_ALL_FLAGS;
 8000e6e:	4b11      	ldr	r3, [pc, #68]	; (8000eb4 <sdc_lld_wait_transaction_end+0x74>)
  dmaStreamClearInterrupt(sdcp->dma);
 8000e70:	253d      	movs	r5, #61	; 0x3d
 8000e72:	408d      	lsls	r5, r1
 8000e74:	6015      	str	r5, [r2, #0]
  sdcp->sdio->ICR = STM32_SDIO_ICR_ALL_FLAGS;
 8000e76:	63a3      	str	r3, [r4, #56]	; 0x38
  sdcp->sdio->DCTRL = 0;
 8000e78:	62e0      	str	r0, [r4, #44]	; 0x2c
 8000e7a:	f380 8811 	msr	BASEPRI, r0
  if (n > 1)
 8000e7e:	2f01      	cmp	r7, #1
 8000e80:	d90a      	bls.n	8000e98 <sdc_lld_wait_transaction_end+0x58>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8000e82:	4643      	mov	r3, r8
 8000e84:	4602      	mov	r2, r0
 8000e86:	210c      	movs	r1, #12
 8000e88:	4630      	mov	r0, r6
}
 8000e8a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 8000e8e:	f7ff bd1f 	b.w	80008d0 <sdc_lld_send_cmd_short_crc>
 8000e92:	f380 8811 	msr	BASEPRI, r0
    return HAL_FAILED;
 8000e96:	2001      	movs	r0, #1
}
 8000e98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return ch.rlist.current;
 8000e9c:	4a06      	ldr	r2, [pc, #24]	; (8000eb8 <sdc_lld_wait_transaction_end+0x78>)
  *trp = tp;
 8000e9e:	4603      	mov	r3, r0
 8000ea0:	6992      	ldr	r2, [r2, #24]
 8000ea2:	f843 2f3c 	str.w	r2, [r3, #60]!
    chSchGoSleepS(newstate);
 8000ea6:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 8000ea8:	6253      	str	r3, [r2, #36]	; 0x24
 8000eaa:	f7ff fdc9 	bl	8000a40 <chSchGoSleepS>
 8000eae:	6cb4      	ldr	r4, [r6, #72]	; 0x48
 8000eb0:	e7d1      	b.n	8000e56 <sdc_lld_wait_transaction_end+0x16>
 8000eb2:	bf00      	nop
 8000eb4:	00c007ff 	.word	0x00c007ff
 8000eb8:	20000d04 	.word	0x20000d04
 8000ebc:	00000000 	.word	0x00000000

08000ec0 <sdc_lld_write_aligned.part.5>:
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
 8000ec0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000ec2:	4604      	mov	r4, r0
 8000ec4:	461d      	mov	r5, r3
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 8000ec6:	e9d0 0310 	ldrd	r0, r3, [r0, #64]	; 0x40
  dmaStreamSetMemory0(sdcp->dma, buf);
 8000eca:	681b      	ldr	r3, [r3, #0]
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8000ecc:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
  dmaStreamSetMemory0(sdcp->dma, buf);
 8000ed0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 8000ed2:	026f      	lsls	r7, r5, #9
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 8000ed4:	f040 0040 	orr.w	r0, r0, #64	; 0x40
  dmaStreamSetTransactionSize(sdcp->dma,
 8000ed8:	08ba      	lsrs	r2, r7, #2
 8000eda:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 8000edc:	6018      	str	r0, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 8000ede:	681e      	ldr	r6, [r3, #0]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8000ee0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  dmaStreamEnable(sdcp->dma);
 8000ee2:	f046 0601 	orr.w	r6, r6, #1
 8000ee6:	601e      	str	r6, [r3, #0]
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8000ee8:	f01c 0f10 	tst.w	ip, #16
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 8000eec:	4b19      	ldr	r3, [pc, #100]	; (8000f54 <sdc_lld_write_aligned.part.5+0x94>)
 8000eee:	6383      	str	r3, [r0, #56]	; 0x38
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
 8000ef0:	b083      	sub	sp, #12
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8000ef2:	f240 331a 	movw	r3, #794	; 0x31a
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
 8000ef6:	460a      	mov	r2, r1
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8000ef8:	ae01      	add	r6, sp, #4
    startblk *= MMCSD_BLOCK_SIZE;
 8000efa:	bf08      	it	eq
 8000efc:	024a      	lsleq	r2, r1, #9
  if (n > 1) {
 8000efe:	2d01      	cmp	r5, #1
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8000f00:	63c3      	str	r3, [r0, #60]	; 0x3c
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 8000f02:	6287      	str	r7, [r0, #40]	; 0x28
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8000f04:	4633      	mov	r3, r6
  if (n > 1) {
 8000f06:	d919      	bls.n	8000f3c <sdc_lld_write_aligned.part.5+0x7c>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 8000f08:	2119      	movs	r1, #25
 8000f0a:	4620      	mov	r0, r4
 8000f0c:	f7ff fce0 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8000f10:	b960      	cbnz	r0, 8000f2c <sdc_lld_write_aligned.part.5+0x6c>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8000f12:	9a01      	ldr	r2, [sp, #4]
 8000f14:	4b10      	ldr	r3, [pc, #64]	; (8000f58 <sdc_lld_write_aligned.part.5+0x98>)
 8000f16:	4013      	ands	r3, r2
 8000f18:	b943      	cbnz	r3, 8000f2c <sdc_lld_write_aligned.part.5+0x6c>
  sdcp->sdio->DCTRL = SDIO_DCTRL_DBLOCKSIZE_3 |
 8000f1a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000f1c:	2299      	movs	r2, #153	; 0x99
 8000f1e:	62da      	str	r2, [r3, #44]	; 0x2c
  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == true)
 8000f20:	4629      	mov	r1, r5
 8000f22:	4632      	mov	r2, r6
 8000f24:	4620      	mov	r0, r4
 8000f26:	f7ff ff8b 	bl	8000e40 <sdc_lld_wait_transaction_end>
 8000f2a:	b128      	cbz	r0, 8000f38 <sdc_lld_write_aligned.part.5+0x78>
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 8000f2c:	4620      	mov	r0, r4
 8000f2e:	4632      	mov	r2, r6
 8000f30:	4629      	mov	r1, r5
 8000f32:	f7ff fd0d 	bl	8000950 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8000f36:	2001      	movs	r0, #1
}
 8000f38:	b003      	add	sp, #12
 8000f3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 8000f3c:	2118      	movs	r1, #24
 8000f3e:	4620      	mov	r0, r4
 8000f40:	f7ff fcc6 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8000f44:	2800      	cmp	r0, #0
 8000f46:	d1f1      	bne.n	8000f2c <sdc_lld_write_aligned.part.5+0x6c>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8000f48:	9a01      	ldr	r2, [sp, #4]
 8000f4a:	4b03      	ldr	r3, [pc, #12]	; (8000f58 <sdc_lld_write_aligned.part.5+0x98>)
 8000f4c:	4013      	ands	r3, r2
 8000f4e:	2b00      	cmp	r3, #0
 8000f50:	d0e3      	beq.n	8000f1a <sdc_lld_write_aligned.part.5+0x5a>
 8000f52:	e7eb      	b.n	8000f2c <sdc_lld_write_aligned.part.5+0x6c>
 8000f54:	00c007ff 	.word	0x00c007ff
 8000f58:	fdffe008 	.word	0xfdffe008
 8000f5c:	00000000 	.word	0x00000000

08000f60 <sdcWrite>:
              const uint8_t *buf, uint32_t n) {
 8000f60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000f64:	460e      	mov	r6, r1
  if ((startblk + n - 1U) > sdcp->capacity) {
 8000f66:	6a87      	ldr	r7, [r0, #40]	; 0x28
 8000f68:	1e59      	subs	r1, r3, #1
 8000f6a:	4431      	add	r1, r6
 8000f6c:	42b9      	cmp	r1, r7
              const uint8_t *buf, uint32_t n) {
 8000f6e:	b083      	sub	sp, #12
 8000f70:	4604      	mov	r4, r0
  if ((startblk + n - 1U) > sdcp->capacity) {
 8000f72:	d907      	bls.n	8000f84 <sdcWrite+0x24>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8000f74:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000f76:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000f7a:	6343      	str	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 8000f7c:	2001      	movs	r0, #1
}
 8000f7e:	b003      	add	sp, #12
 8000f80:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000f84:	4615      	mov	r5, r2
  sdcp->state = BLK_WRITING;
 8000f86:	2207      	movs	r2, #7
 8000f88:	7102      	strb	r2, [r0, #4]
  if (((unsigned)buf & 3) != 0) {
 8000f8a:	07aa      	lsls	r2, r5, #30
 8000f8c:	d027      	beq.n	8000fde <sdcWrite+0x7e>
    for (i = 0; i < blocks; i++) {
 8000f8e:	b323      	cbz	r3, 8000fda <sdcWrite+0x7a>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 8000f90:	4f1a      	ldr	r7, [pc, #104]	; (8000ffc <sdcWrite+0x9c>)
  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 8000f92:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8001000 <sdcWrite+0xa0>
 8000f96:	eb06 0903 	add.w	r9, r6, r3
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 8000f9a:	4629      	mov	r1, r5
 8000f9c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000fa0:	4638      	mov	r0, r7
 8000fa2:	f7ff f9a3 	bl	80002ec <memcpy>
  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 8000fa6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  if (_sdc_wait_for_transfer_state(sdcp))
 8000fa8:	4620      	mov	r0, r4
  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 8000faa:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
      buf += MMCSD_BLOCK_SIZE;
 8000fae:	f505 7500 	add.w	r5, r5, #512	; 0x200
  if (_sdc_wait_for_transfer_state(sdcp))
 8000fb2:	f7ff ff05 	bl	8000dc0 <_sdc_wait_for_transfer_state>
 8000fb6:	b128      	cbz	r0, 8000fc4 <sdcWrite+0x64>
        return HAL_FAILED;
 8000fb8:	2001      	movs	r0, #1
  sdcp->state = BLK_READY;
 8000fba:	2305      	movs	r3, #5
 8000fbc:	7123      	strb	r3, [r4, #4]
}
 8000fbe:	b003      	add	sp, #12
 8000fc0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000fc4:	4631      	mov	r1, r6
 8000fc6:	2301      	movs	r3, #1
 8000fc8:	463a      	mov	r2, r7
 8000fca:	4620      	mov	r0, r4
 8000fcc:	f7ff ff78 	bl	8000ec0 <sdc_lld_write_aligned.part.5>
      startblk++;
 8000fd0:	3601      	adds	r6, #1
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 8000fd2:	2800      	cmp	r0, #0
 8000fd4:	d1f0      	bne.n	8000fb8 <sdcWrite+0x58>
    for (i = 0; i < blocks; i++) {
 8000fd6:	454e      	cmp	r6, r9
 8000fd8:	d1df      	bne.n	8000f9a <sdcWrite+0x3a>
    return HAL_SUCCESS;
 8000fda:	2000      	movs	r0, #0
 8000fdc:	e7ed      	b.n	8000fba <sdcWrite+0x5a>
  sdcp->sdio->DTIMER = STM32_SDC_WRITE_TIMEOUT;
 8000fde:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8000fe0:	4907      	ldr	r1, [pc, #28]	; (8001000 <sdcWrite+0xa0>)
 8000fe2:	6251      	str	r1, [r2, #36]	; 0x24
 8000fe4:	9301      	str	r3, [sp, #4]
  if (_sdc_wait_for_transfer_state(sdcp))
 8000fe6:	f7ff feeb 	bl	8000dc0 <_sdc_wait_for_transfer_state>
 8000fea:	9b01      	ldr	r3, [sp, #4]
 8000fec:	2800      	cmp	r0, #0
 8000fee:	d1e3      	bne.n	8000fb8 <sdcWrite+0x58>
 8000ff0:	462a      	mov	r2, r5
 8000ff2:	4631      	mov	r1, r6
 8000ff4:	4620      	mov	r0, r4
 8000ff6:	f7ff ff63 	bl	8000ec0 <sdc_lld_write_aligned.part.5>
 8000ffa:	e7de      	b.n	8000fba <sdcWrite+0x5a>
 8000ffc:	20001570 	.word	0x20001570
 8001000:	016e3600 	.word	0x016e3600
	...

08001010 <disk_write>:
    const BYTE *buff, /* Data to be written */
    DWORD sector,     /* Sector address (LBA) */
    UINT count        /* Number of sectors to write (1..255) */
)
{
  switch (pdrv) {
 8001010:	b968      	cbnz	r0, 800102e <disk_write+0x1e>
{
 8001012:	b410      	push	{r4}
    if (mmcStopSequentialWrite(&FATFS_HAL_DEVICE))
        return RES_ERROR;
    return RES_OK;
#else
  case SDC:
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
 8001014:	4807      	ldr	r0, [pc, #28]	; (8001034 <disk_write+0x24>)
 8001016:	4614      	mov	r4, r2
 8001018:	7902      	ldrb	r2, [r0, #4]
 800101a:	2a05      	cmp	r2, #5
 800101c:	d002      	beq.n	8001024 <disk_write+0x14>
      return RES_NOTRDY;
 800101e:	2003      	movs	r0, #3
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
}
 8001020:	bc10      	pop	{r4}
 8001022:	4770      	bx	lr
    if (sdcWrite(&FATFS_HAL_DEVICE, sector, buff, count))
 8001024:	460a      	mov	r2, r1
 8001026:	4621      	mov	r1, r4
}
 8001028:	bc10      	pop	{r4}
    if (sdcWrite(&FATFS_HAL_DEVICE, sector, buff, count))
 800102a:	f7ff bf99 	b.w	8000f60 <sdcWrite>
  return RES_PARERR;
 800102e:	2004      	movs	r0, #4
}
 8001030:	4770      	bx	lr
 8001032:	bf00      	nop
 8001034:	20000884 	.word	0x20000884
	...

08001040 <sync_window.part.5>:
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 8001040:	b570      	push	{r4, r5, r6, lr}
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 8001042:	f100 0634 	add.w	r6, r0, #52	; 0x34
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 8001046:	4604      	mov	r4, r0
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write back the window */
 8001048:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800104a:	7840      	ldrb	r0, [r0, #1]
 800104c:	4631      	mov	r1, r6
 800104e:	2301      	movs	r3, #1
 8001050:	f7ff ffde 	bl	8001010 <disk_write>
 8001054:	b960      	cbnz	r0, 8001070 <sync_window.part.5+0x30>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 8001056:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8001058:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800105a:	69e2      	ldr	r2, [r4, #28]
			fs->wflag = 0;	/* Clear window dirty flag */
 800105c:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
 800105e:	1acb      	subs	r3, r1, r3
 8001060:	4293      	cmp	r3, r2
 8001062:	4605      	mov	r5, r0
 8001064:	d202      	bcs.n	800106c <sync_window.part.5+0x2c>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8001066:	78a3      	ldrb	r3, [r4, #2]
 8001068:	2b02      	cmp	r3, #2
 800106a:	d003      	beq.n	8001074 <sync_window.part.5+0x34>
	FRESULT res = FR_OK;
 800106c:	4628      	mov	r0, r5
}
 800106e:	bd70      	pop	{r4, r5, r6, pc}
			res = FR_DISK_ERR;
 8001070:	2001      	movs	r0, #1
}
 8001072:	bd70      	pop	{r4, r5, r6, pc}
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
 8001074:	440a      	add	r2, r1
 8001076:	7860      	ldrb	r0, [r4, #1]
 8001078:	4631      	mov	r1, r6
 800107a:	2301      	movs	r3, #1
 800107c:	f7ff ffc8 	bl	8001010 <disk_write>
	FRESULT res = FR_OK;
 8001080:	4628      	mov	r0, r5
}
 8001082:	bd70      	pop	{r4, r5, r6, pc}
	...

08001090 <sdc_lld_read_aligned.part.4>:
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
 8001090:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001092:	4604      	mov	r4, r0
 8001094:	461d      	mov	r5, r3
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 8001096:	e9d0 0310 	ldrd	r0, r3, [r0, #64]	; 0x40
  dmaStreamSetMemory0(sdcp->dma, buf);
 800109a:	681b      	ldr	r3, [r3, #0]
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800109c:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
  dmaStreamSetMemory0(sdcp->dma, buf);
 80010a0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 80010a2:	026f      	lsls	r7, r5, #9
 80010a4:	08ba      	lsrs	r2, r7, #2
 80010a6:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 80010a8:	6018      	str	r0, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 80010aa:	681e      	ldr	r6, [r3, #0]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80010ac:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  dmaStreamEnable(sdcp->dma);
 80010ae:	f046 0601 	orr.w	r6, r6, #1
 80010b2:	601e      	str	r6, [r3, #0]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80010b4:	4b1a      	ldr	r3, [pc, #104]	; (8001120 <sdc_lld_read_aligned.part.4+0x90>)
 80010b6:	6383      	str	r3, [r0, #56]	; 0x38
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 80010b8:	f01c 0f10 	tst.w	ip, #16
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 80010bc:	f240 332a 	movw	r3, #810	; 0x32a
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
 80010c0:	b083      	sub	sp, #12
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 80010c2:	63c3      	str	r3, [r0, #60]	; 0x3c
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
 80010c4:	460a      	mov	r2, r1
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 80010c6:	f04f 039b 	mov.w	r3, #155	; 0x9b
    startblk *= MMCSD_BLOCK_SIZE;
 80010ca:	bf08      	it	eq
 80010cc:	024a      	lsleq	r2, r1, #9
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 80010ce:	ae01      	add	r6, sp, #4
  if (n > 1) {
 80010d0:	2d01      	cmp	r5, #1
  sdcp->sdio->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 80010d2:	6287      	str	r7, [r0, #40]	; 0x28
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 80010d4:	62c3      	str	r3, [r0, #44]	; 0x2c
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 80010d6:	4633      	mov	r3, r6
  if (n > 1) {
 80010d8:	d916      	bls.n	8001108 <sdc_lld_read_aligned.part.4+0x78>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 80010da:	2112      	movs	r1, #18
 80010dc:	4620      	mov	r0, r4
 80010de:	f7ff fbf7 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 80010e2:	b948      	cbnz	r0, 80010f8 <sdc_lld_read_aligned.part.4+0x68>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 80010e4:	9a01      	ldr	r2, [sp, #4]
 80010e6:	4b0f      	ldr	r3, [pc, #60]	; (8001124 <sdc_lld_read_aligned.part.4+0x94>)
 80010e8:	4013      	ands	r3, r2
 80010ea:	b92b      	cbnz	r3, 80010f8 <sdc_lld_read_aligned.part.4+0x68>
  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == true)
 80010ec:	4632      	mov	r2, r6
 80010ee:	4629      	mov	r1, r5
 80010f0:	4620      	mov	r0, r4
 80010f2:	f7ff fea5 	bl	8000e40 <sdc_lld_wait_transaction_end>
 80010f6:	b128      	cbz	r0, 8001104 <sdc_lld_read_aligned.part.4+0x74>
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 80010f8:	4620      	mov	r0, r4
 80010fa:	4632      	mov	r2, r6
 80010fc:	4629      	mov	r1, r5
 80010fe:	f7ff fc27 	bl	8000950 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8001102:	2001      	movs	r0, #1
}
 8001104:	b003      	add	sp, #12
 8001106:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 8001108:	2111      	movs	r1, #17
 800110a:	4620      	mov	r0, r4
 800110c:	f7ff fbe0 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001110:	2800      	cmp	r0, #0
 8001112:	d1f1      	bne.n	80010f8 <sdc_lld_read_aligned.part.4+0x68>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8001114:	9a01      	ldr	r2, [sp, #4]
 8001116:	4b03      	ldr	r3, [pc, #12]	; (8001124 <sdc_lld_read_aligned.part.4+0x94>)
 8001118:	4013      	ands	r3, r2
 800111a:	2b00      	cmp	r3, #0
 800111c:	d0e6      	beq.n	80010ec <sdc_lld_read_aligned.part.4+0x5c>
 800111e:	e7eb      	b.n	80010f8 <sdc_lld_read_aligned.part.4+0x68>
 8001120:	00c007ff 	.word	0x00c007ff
 8001124:	fdffe008 	.word	0xfdffe008
	...

08001130 <sdcRead>:
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8001130:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001134:	460e      	mov	r6, r1
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001136:	6a87      	ldr	r7, [r0, #40]	; 0x28
 8001138:	1e59      	subs	r1, r3, #1
 800113a:	4431      	add	r1, r6
 800113c:	42b9      	cmp	r1, r7
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 800113e:	b083      	sub	sp, #12
 8001140:	4604      	mov	r4, r0
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001142:	d907      	bls.n	8001154 <sdcRead+0x24>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8001144:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001146:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800114a:	6343      	str	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 800114c:	2001      	movs	r0, #1
}
 800114e:	b003      	add	sp, #12
 8001150:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001154:	4615      	mov	r5, r2
  sdcp->state = BLK_READING;
 8001156:	2206      	movs	r2, #6
 8001158:	7102      	strb	r2, [r0, #4]
  if (((unsigned)buf & 3) != 0) {
 800115a:	07aa      	lsls	r2, r5, #30
 800115c:	d026      	beq.n	80011ac <sdcRead+0x7c>
    for (i = 0; i < blocks; i++) {
 800115e:	b31b      	cbz	r3, 80011a8 <sdcRead+0x78>
  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 8001160:	4f1a      	ldr	r7, [pc, #104]	; (80011cc <sdcRead+0x9c>)
 8001162:	f8df 906c 	ldr.w	r9, [pc, #108]	; 80011d0 <sdcRead+0xa0>
 8001166:	eb06 0803 	add.w	r8, r6, r3
 800116a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  if (_sdc_wait_for_transfer_state(sdcp))
 800116c:	4620      	mov	r0, r4
  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 800116e:	625f      	str	r7, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
 8001170:	f7ff fe26 	bl	8000dc0 <_sdc_wait_for_transfer_state>
 8001174:	b128      	cbz	r0, 8001182 <sdcRead+0x52>
        return HAL_FAILED;
 8001176:	2001      	movs	r0, #1
  sdcp->state = BLK_READY;
 8001178:	2305      	movs	r3, #5
 800117a:	7123      	strb	r3, [r4, #4]
}
 800117c:	b003      	add	sp, #12
 800117e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001182:	4631      	mov	r1, r6
 8001184:	464a      	mov	r2, r9
 8001186:	2301      	movs	r3, #1
 8001188:	4620      	mov	r0, r4
 800118a:	f7ff ff81 	bl	8001090 <sdc_lld_read_aligned.part.4>
      startblk++;
 800118e:	3601      	adds	r6, #1
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 8001190:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001194:	4649      	mov	r1, r9
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 8001196:	2800      	cmp	r0, #0
 8001198:	d1ed      	bne.n	8001176 <sdcRead+0x46>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 800119a:	4628      	mov	r0, r5
 800119c:	f7ff f8a6 	bl	80002ec <memcpy>
    for (i = 0; i < blocks; i++) {
 80011a0:	4546      	cmp	r6, r8
      buf += MMCSD_BLOCK_SIZE;
 80011a2:	f505 7500 	add.w	r5, r5, #512	; 0x200
    for (i = 0; i < blocks; i++) {
 80011a6:	d1e0      	bne.n	800116a <sdcRead+0x3a>
    return HAL_SUCCESS;
 80011a8:	2000      	movs	r0, #0
 80011aa:	e7e5      	b.n	8001178 <sdcRead+0x48>
  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 80011ac:	6c82      	ldr	r2, [r0, #72]	; 0x48
 80011ae:	4907      	ldr	r1, [pc, #28]	; (80011cc <sdcRead+0x9c>)
 80011b0:	6251      	str	r1, [r2, #36]	; 0x24
 80011b2:	9301      	str	r3, [sp, #4]
  if (_sdc_wait_for_transfer_state(sdcp))
 80011b4:	f7ff fe04 	bl	8000dc0 <_sdc_wait_for_transfer_state>
 80011b8:	9b01      	ldr	r3, [sp, #4]
 80011ba:	2800      	cmp	r0, #0
 80011bc:	d1db      	bne.n	8001176 <sdcRead+0x46>
 80011be:	462a      	mov	r2, r5
 80011c0:	4631      	mov	r1, r6
 80011c2:	4620      	mov	r0, r4
 80011c4:	f7ff ff64 	bl	8001090 <sdc_lld_read_aligned.part.4>
 80011c8:	e7d6      	b.n	8001178 <sdcRead+0x48>
 80011ca:	bf00      	nop
 80011cc:	016e3600 	.word	0x016e3600
 80011d0:	20001570 	.word	0x20001570
	...

080011e0 <disk_read>:
  switch (pdrv) {
 80011e0:	b968      	cbnz	r0, 80011fe <disk_read+0x1e>
{
 80011e2:	b410      	push	{r4}
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
 80011e4:	4807      	ldr	r0, [pc, #28]	; (8001204 <disk_read+0x24>)
 80011e6:	4614      	mov	r4, r2
 80011e8:	7902      	ldrb	r2, [r0, #4]
 80011ea:	2a05      	cmp	r2, #5
 80011ec:	d002      	beq.n	80011f4 <disk_read+0x14>
      return RES_NOTRDY;
 80011ee:	2003      	movs	r0, #3
}
 80011f0:	bc10      	pop	{r4}
 80011f2:	4770      	bx	lr
    if (sdcRead(&FATFS_HAL_DEVICE, sector, buff, count))
 80011f4:	460a      	mov	r2, r1
 80011f6:	4621      	mov	r1, r4
}
 80011f8:	bc10      	pop	{r4}
    if (sdcRead(&FATFS_HAL_DEVICE, sector, buff, count))
 80011fa:	f7ff bf99 	b.w	8001130 <sdcRead>
  return RES_PARERR;
 80011fe:	2004      	movs	r0, #4
}
 8001200:	4770      	bx	lr
 8001202:	bf00      	nop
 8001204:	20000884 	.word	0x20000884
	...

08001210 <move_window.part.6>:
static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 8001210:	b538      	push	{r3, r4, r5, lr}
	if (fs->wflag) {	/* Is the disk access window dirty */
 8001212:	78c3      	ldrb	r3, [r0, #3]
static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 8001214:	4604      	mov	r4, r0
 8001216:	460d      	mov	r5, r1
	if (fs->wflag) {	/* Is the disk access window dirty */
 8001218:	b113      	cbz	r3, 8001220 <move_window.part.6+0x10>
 800121a:	f7ff ff11 	bl	8001040 <sync_window.part.5>
		if (res == FR_OK) {			/* Fill sector window with new data */
 800121e:	b970      	cbnz	r0, 800123e <move_window.part.6+0x2e>
			if (disk_read(fs->pdrv, fs->win, sector, 1) != RES_OK) {
 8001220:	462a      	mov	r2, r5
 8001222:	2301      	movs	r3, #1
 8001224:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8001228:	7860      	ldrb	r0, [r4, #1]
 800122a:	f7ff ffd9 	bl	80011e0 <disk_read>
				res = FR_DISK_ERR;
 800122e:	2800      	cmp	r0, #0
 8001230:	bf18      	it	ne
 8001232:	f04f 35ff 	movne.w	r5, #4294967295
			fs->winsect = sector;
 8001236:	6325      	str	r5, [r4, #48]	; 0x30
				res = FR_DISK_ERR;
 8001238:	bf0c      	ite	eq
 800123a:	2000      	moveq	r0, #0
 800123c:	2001      	movne	r0, #1
}
 800123e:	bd38      	pop	{r3, r4, r5, pc}

08001240 <get_fat.isra.9>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8001240:	2901      	cmp	r1, #1
 8001242:	d92c      	bls.n	800129e <get_fat.isra.9+0x5e>
 8001244:	6982      	ldr	r2, [r0, #24]
 8001246:	4291      	cmp	r1, r2
static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 8001248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800124a:	4606      	mov	r6, r0
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 800124c:	d225      	bcs.n	800129a <get_fat.isra.9+0x5a>
		switch (fs->fs_type) {
 800124e:	7803      	ldrb	r3, [r0, #0]
 8001250:	2b02      	cmp	r3, #2
 8001252:	460c      	mov	r4, r1
 8001254:	d03b      	beq.n	80012ce <get_fat.isra.9+0x8e>
 8001256:	2b03      	cmp	r3, #3
 8001258:	d023      	beq.n	80012a2 <get_fat.isra.9+0x62>
 800125a:	2b01      	cmp	r3, #1
 800125c:	d11d      	bne.n	800129a <get_fat.isra.9+0x5a>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800125e:	6a43      	ldr	r3, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001260:	f8d0 c030 	ldr.w	ip, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;
 8001264:	eb01 0751 	add.w	r7, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001268:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800126c:	4561      	cmp	r1, ip
 800126e:	d14a      	bne.n	8001306 <get_fat.isra.9+0xc6>
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 8001270:	f3c7 0208 	ubfx	r2, r7, #0, #9
 8001274:	3701      	adds	r7, #1
 8001276:	4432      	add	r2, r6
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8001278:	eb03 2157 	add.w	r1, r3, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 800127c:	4561      	cmp	r1, ip
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
 800127e:	f892 5034 	ldrb.w	r5, [r2, #52]	; 0x34
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001282:	d148      	bne.n	8001316 <get_fat.isra.9+0xd6>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 8001284:	f3c7 0308 	ubfx	r3, r7, #0, #9
 8001288:	4433      	add	r3, r6
 800128a:	f893 0034 	ldrb.w	r0, [r3, #52]	; 0x34
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 800128e:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
 8001290:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 8001294:	d545      	bpl.n	8001322 <get_fat.isra.9+0xe2>
 8001296:	0900      	lsrs	r0, r0, #4
}
 8001298:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = 1;	/* Internal error */
 800129a:	2001      	movs	r0, #1
}
 800129c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		val = 1;	/* Internal error */
 800129e:	2001      	movs	r0, #1
}
 80012a0:	4770      	bx	lr
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80012a2:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 80012a4:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80012a6:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 80012aa:	4299      	cmp	r1, r3
 80012ac:	d126      	bne.n	80012fc <get_fat.isra.9+0xbc>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 80012ae:	00a1      	lsls	r1, r4, #2
 80012b0:	f106 0334 	add.w	r3, r6, #52	; 0x34
 80012b4:	f401 71fe 	and.w	r1, r1, #508	; 0x1fc
 80012b8:	185a      	adds	r2, r3, r1
	rv = rv << 8 | ptr[0];
 80012ba:	5c58      	ldrb	r0, [r3, r1]
	rv = rv << 8 | ptr[2];
 80012bc:	8851      	ldrh	r1, [r2, #2]
	rv = rv << 8 | ptr[1];
 80012be:	7853      	ldrb	r3, [r2, #1]
 80012c0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 80012c4:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
 80012c8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
}
 80012cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80012ce:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 80012d0:	6b03      	ldr	r3, [r0, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80012d2:	eb01 2114 	add.w	r1, r1, r4, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 80012d6:	4299      	cmp	r1, r3
 80012d8:	d005      	beq.n	80012e6 <get_fat.isra.9+0xa6>
 80012da:	f7ff ff99 	bl	8001210 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 80012de:	b110      	cbz	r0, 80012e6 <get_fat.isra.9+0xa6>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80012e0:	f04f 30ff 	mov.w	r0, #4294967295
}
 80012e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 80012e6:	0061      	lsls	r1, r4, #1
 80012e8:	f106 0334 	add.w	r3, r6, #52	; 0x34
 80012ec:	f401 71ff 	and.w	r1, r1, #510	; 0x1fe
 80012f0:	185a      	adds	r2, r3, r1
	rv = rv << 8 | ptr[0];
 80012f2:	5c58      	ldrb	r0, [r3, r1]
 80012f4:	7853      	ldrb	r3, [r2, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
 80012f6:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
 80012fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80012fc:	f7ff ff88 	bl	8001210 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8001300:	2800      	cmp	r0, #0
 8001302:	d0d4      	beq.n	80012ae <get_fat.isra.9+0x6e>
 8001304:	e7ec      	b.n	80012e0 <get_fat.isra.9+0xa0>
 8001306:	f7ff ff83 	bl	8001210 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800130a:	2800      	cmp	r0, #0
 800130c:	d1e8      	bne.n	80012e0 <get_fat.isra.9+0xa0>
 800130e:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8001310:	f8d6 c030 	ldr.w	ip, [r6, #48]	; 0x30
 8001314:	e7ac      	b.n	8001270 <get_fat.isra.9+0x30>
 8001316:	4630      	mov	r0, r6
 8001318:	f7ff ff7a 	bl	8001210 <move_window.part.6>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 800131c:	2800      	cmp	r0, #0
 800131e:	d0b1      	beq.n	8001284 <get_fat.isra.9+0x44>
 8001320:	e7de      	b.n	80012e0 <get_fat.isra.9+0xa0>
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
 8001322:	f3c0 000b 	ubfx	r0, r0, #0, #12
}
 8001326:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08001330 <dir_sdi>:
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 8001330:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8001334:	d229      	bcs.n	800138a <dir_sdi+0x5a>
 8001336:	06ca      	lsls	r2, r1, #27
{
 8001338:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800133a:	460c      	mov	r4, r1
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 800133c:	d123      	bne.n	8001386 <dir_sdi+0x56>
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 800133e:	6881      	ldr	r1, [r0, #8]
	dp->dptr = ofs;				/* Set current offset */
 8001340:	6104      	str	r4, [r0, #16]
 8001342:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 8001344:	6806      	ldr	r6, [r0, #0]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 8001346:	bb19      	cbnz	r1, 8001390 <dir_sdi+0x60>
 8001348:	7833      	ldrb	r3, [r6, #0]
 800134a:	2b02      	cmp	r3, #2
 800134c:	d901      	bls.n	8001352 <dir_sdi+0x22>
		clst = fs->dirbase;
 800134e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 8001350:	b9eb      	cbnz	r3, 800138e <dir_sdi+0x5e>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
 8001352:	8933      	ldrh	r3, [r6, #8]
 8001354:	ebb3 1f54 	cmp.w	r3, r4, lsr #5
 8001358:	d915      	bls.n	8001386 <dir_sdi+0x56>
		dp->sect = fs->dirbase;
 800135a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800135c:	61ab      	str	r3, [r5, #24]
	dp->clust = clst;					/* Current cluster# */
 800135e:	6169      	str	r1, [r5, #20]
	if (dp->sect == 0) return FR_INT_ERR;
 8001360:	b18b      	cbz	r3, 8001386 <dir_sdi+0x56>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8001362:	f3c4 0208 	ubfx	r2, r4, #0, #9
 8001366:	3634      	adds	r6, #52	; 0x34
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8001368:	eb03 2454 	add.w	r4, r3, r4, lsr #9
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 800136c:	4416      	add	r6, r2
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 800136e:	e9c5 4606 	strd	r4, r6, [r5, #24]
	return FR_OK;
 8001372:	2000      	movs	r0, #0
}
 8001374:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001376:	69b3      	ldr	r3, [r6, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8001378:	3b02      	subs	r3, #2
	clst -= 2;		/* Cluster number is origin from 2 */
 800137a:	1e8a      	subs	r2, r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800137c:	429a      	cmp	r2, r3
 800137e:	d31e      	bcc.n	80013be <dir_sdi+0x8e>
		dp->sect = clst2sect(fs, clst);
 8001380:	2300      	movs	r3, #0
 8001382:	e9c5 1305 	strd	r1, r3, [r5, #20]
		return FR_INT_ERR;
 8001386:	2002      	movs	r0, #2
}
 8001388:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return FR_INT_ERR;
 800138a:	2002      	movs	r0, #2
}
 800138c:	4770      	bx	lr
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
 800138e:	4619      	mov	r1, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 8001390:	8977      	ldrh	r7, [r6, #10]
 8001392:	027f      	lsls	r7, r7, #9
		while (ofs >= csz) {				/* Follow cluster chain */
 8001394:	42bc      	cmp	r4, r7
 8001396:	d3ee      	bcc.n	8001376 <dir_sdi+0x46>
 8001398:	4630      	mov	r0, r6
 800139a:	e007      	b.n	80013ac <dir_sdi+0x7c>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 800139c:	2801      	cmp	r0, #1
 800139e:	d9f2      	bls.n	8001386 <dir_sdi+0x56>
 80013a0:	69b3      	ldr	r3, [r6, #24]
 80013a2:	4283      	cmp	r3, r0
 80013a4:	d9ef      	bls.n	8001386 <dir_sdi+0x56>
		while (ofs >= csz) {				/* Follow cluster chain */
 80013a6:	42a7      	cmp	r7, r4
 80013a8:	d8e6      	bhi.n	8001378 <dir_sdi+0x48>
 80013aa:	6828      	ldr	r0, [r5, #0]
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80013ac:	f7ff ff48 	bl	8001240 <get_fat.isra.9>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80013b0:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80013b2:	4601      	mov	r1, r0
			ofs -= csz;
 80013b4:	eba4 0407 	sub.w	r4, r4, r7
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80013b8:	d1f0      	bne.n	800139c <dir_sdi+0x6c>
 80013ba:	2001      	movs	r0, #1
}
 80013bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 80013be:	8973      	ldrh	r3, [r6, #10]
 80013c0:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 80013c2:	fb02 0303 	mla	r3, r2, r3, r0
		dp->sect = clst2sect(fs, clst);
 80013c6:	61ab      	str	r3, [r5, #24]
 80013c8:	e7c9      	b.n	800135e <dir_sdi+0x2e>
 80013ca:	bf00      	nop
 80013cc:	0000      	movs	r0, r0
	...

080013d0 <put_fat.part.8>:
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 80013d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		switch (fs->fs_type) {
 80013d4:	7803      	ldrb	r3, [r0, #0]
 80013d6:	2b02      	cmp	r3, #2
static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 80013d8:	4604      	mov	r4, r0
 80013da:	460d      	mov	r5, r1
 80013dc:	4616      	mov	r6, r2
		switch (fs->fs_type) {
 80013de:	d058      	beq.n	8001492 <put_fat.part.8+0xc2>
 80013e0:	2b03      	cmp	r3, #3
 80013e2:	d037      	beq.n	8001454 <put_fat.part.8+0x84>
 80013e4:	2b01      	cmp	r3, #1
 80013e6:	d002      	beq.n	80013ee <put_fat.part.8+0x1e>
	FRESULT res = FR_INT_ERR;
 80013e8:	2002      	movs	r0, #2
}
 80013ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80013ee:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 80013f0:	6b03      	ldr	r3, [r0, #48]	; 0x30
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
 80013f2:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80013f6:	eb01 2157 	add.w	r1, r1, r7, lsr #9
	if (sector != fs->winsect) {	/* Window offset changed? */
 80013fa:	4299      	cmp	r1, r3
 80013fc:	d162      	bne.n	80014c4 <put_fat.part.8+0xf4>
			p = fs->win + bc++ % SS(fs);
 80013fe:	f107 0801 	add.w	r8, r7, #1
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 8001402:	07eb      	lsls	r3, r5, #31
			p = fs->win + bc++ % SS(fs);
 8001404:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8001408:	ea4f 2158 	mov.w	r1, r8, lsr #9
 800140c:	f104 0934 	add.w	r9, r4, #52	; 0x34
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 8001410:	d562      	bpl.n	80014d8 <put_fat.part.8+0x108>
 8001412:	f819 3007 	ldrb.w	r3, [r9, r7]
 8001416:	f003 030f 	and.w	r3, r3, #15
 800141a:	ea43 1306 	orr.w	r3, r3, r6, lsl #4
 800141e:	f809 3007 	strb.w	r3, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8001422:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001424:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8001426:	4411      	add	r1, r2
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001428:	4299      	cmp	r1, r3
			fs->wflag = 1;
 800142a:	f04f 0201 	mov.w	r2, #1
 800142e:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001430:	d004      	beq.n	800143c <put_fat.part.8+0x6c>
 8001432:	4620      	mov	r0, r4
 8001434:	f7ff feec 	bl	8001210 <move_window.part.6>
			if (res != FR_OK) break;
 8001438:	2800      	cmp	r0, #0
 800143a:	d1d6      	bne.n	80013ea <put_fat.part.8+0x1a>
			p = fs->win + bc % SS(fs);
 800143c:	f3c8 0808 	ubfx	r8, r8, #0, #9
 8001440:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 8001442:	f3c6 1607 	ubfx	r6, r6, #4, #8
			fs->wflag = 1;
 8001446:	2301      	movs	r3, #1
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 8001448:	f888 6000 	strb.w	r6, [r8]
			fs->wflag = 1;
 800144c:	70e3      	strb	r3, [r4, #3]
 800144e:	2000      	movs	r0, #0
}
 8001450:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8001454:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001456:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8001458:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
	if (sector != fs->winsect) {	/* Window offset changed? */
 800145c:	4299      	cmp	r1, r3
 800145e:	d136      	bne.n	80014ce <put_fat.part.8+0xfe>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8001460:	00ad      	lsls	r5, r5, #2
 8001462:	f104 0134 	add.w	r1, r4, #52	; 0x34
 8001466:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
 800146a:	194b      	adds	r3, r1, r5
 800146c:	f026 4670 	bic.w	r6, r6, #4026531840	; 0xf0000000
	rv = rv << 8 | ptr[2];
 8001470:	885a      	ldrh	r2, [r3, #2]
	rv = rv << 8 | ptr[0];
 8001472:	0412      	lsls	r2, r2, #16
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8001474:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 8001478:	4332      	orrs	r2, r6
	*ptr++ = (BYTE)val; val >>= 8;
 800147a:	554a      	strb	r2, [r1, r5]
 800147c:	0a16      	lsrs	r6, r2, #8
	*ptr++ = (BYTE)val; val >>= 8;
 800147e:	0c10      	lsrs	r0, r2, #16
			fs->wflag = 1;
 8001480:	2101      	movs	r1, #1
	*ptr++ = (BYTE)val; val >>= 8;
 8001482:	0e12      	lsrs	r2, r2, #24
 8001484:	7098      	strb	r0, [r3, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 8001486:	705e      	strb	r6, [r3, #1]
	*ptr++ = (BYTE)val;
 8001488:	70da      	strb	r2, [r3, #3]
			fs->wflag = 1;
 800148a:	70e1      	strb	r1, [r4, #3]
 800148c:	2000      	movs	r0, #0
}
 800148e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8001492:	6a41      	ldr	r1, [r0, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001494:	6b03      	ldr	r3, [r0, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8001496:	eb01 2115 	add.w	r1, r1, r5, lsr #8
	if (sector != fs->winsect) {	/* Window offset changed? */
 800149a:	4299      	cmp	r1, r3
 800149c:	d003      	beq.n	80014a6 <put_fat.part.8+0xd6>
 800149e:	f7ff feb7 	bl	8001210 <move_window.part.6>
			if (res != FR_OK) break;
 80014a2:	2800      	cmp	r0, #0
 80014a4:	d1a1      	bne.n	80013ea <put_fat.part.8+0x1a>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
 80014a6:	006d      	lsls	r5, r5, #1
 80014a8:	f104 0334 	add.w	r3, r4, #52	; 0x34
 80014ac:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
 80014b0:	195a      	adds	r2, r3, r5
	*ptr++ = (BYTE)val; val >>= 8;
 80014b2:	555e      	strb	r6, [r3, r5]
 80014b4:	f3c6 2107 	ubfx	r1, r6, #8, #8
			fs->wflag = 1;
 80014b8:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 80014ba:	7051      	strb	r1, [r2, #1]
			fs->wflag = 1;
 80014bc:	70e3      	strb	r3, [r4, #3]
 80014be:	2000      	movs	r0, #0
}
 80014c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80014c4:	f7ff fea4 	bl	8001210 <move_window.part.6>
			if (res != FR_OK) break;
 80014c8:	2800      	cmp	r0, #0
 80014ca:	d098      	beq.n	80013fe <put_fat.part.8+0x2e>
 80014cc:	e78d      	b.n	80013ea <put_fat.part.8+0x1a>
 80014ce:	f7ff fe9f 	bl	8001210 <move_window.part.6>
			if (res != FR_OK) break;
 80014d2:	2800      	cmp	r0, #0
 80014d4:	d0c4      	beq.n	8001460 <put_fat.part.8+0x90>
 80014d6:	e788      	b.n	80013ea <put_fat.part.8+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Put 1st byte */
 80014d8:	f809 6007 	strb.w	r6, [r9, r7]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80014dc:	6a62      	ldr	r2, [r4, #36]	; 0x24
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014de:	6b23      	ldr	r3, [r4, #48]	; 0x30
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 80014e0:	4411      	add	r1, r2
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014e2:	4299      	cmp	r1, r3
			fs->wflag = 1;
 80014e4:	f04f 0201 	mov.w	r2, #1
 80014e8:	70e2      	strb	r2, [r4, #3]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80014ea:	d10a      	bne.n	8001502 <put_fat.part.8+0x132>
			p = fs->win + bc % SS(fs);
 80014ec:	f3c8 0808 	ubfx	r8, r8, #0, #9
 80014f0:	44c8      	add	r8, r9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Put 2nd byte */
 80014f2:	f3c6 2203 	ubfx	r2, r6, #8, #4
 80014f6:	f898 3000 	ldrb.w	r3, [r8]
 80014fa:	f023 060f 	bic.w	r6, r3, #15
 80014fe:	4316      	orrs	r6, r2
 8001500:	e7a1      	b.n	8001446 <put_fat.part.8+0x76>
 8001502:	4620      	mov	r0, r4
 8001504:	f7ff fe84 	bl	8001210 <move_window.part.6>
			if (res != FR_OK) break;
 8001508:	2800      	cmp	r0, #0
 800150a:	f47f af6e 	bne.w	80013ea <put_fat.part.8+0x1a>
 800150e:	e7ed      	b.n	80014ec <put_fat.part.8+0x11c>

08001510 <check_fs>:
static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,			/* Filesystem object */
	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8001510:	f04f 33ff 	mov.w	r3, #4294967295
 8001514:	2200      	movs	r2, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001516:	4299      	cmp	r1, r3
{
 8001518:	b510      	push	{r4, lr}
 800151a:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 800151c:	70c2      	strb	r2, [r0, #3]
 800151e:	6303      	str	r3, [r0, #48]	; 0x30
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001520:	d121      	bne.n	8001566 <check_fs+0x56>
	rv = rv << 8 | ptr[0];
 8001522:	f894 1233 	ldrb.w	r1, [r4, #563]	; 0x233
 8001526:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 800152a:	f64a 2255 	movw	r2, #43605	; 0xaa55
	rv = rv << 8 | ptr[0];
 800152e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 8001532:	4293      	cmp	r3, r2
 8001534:	d115      	bne.n	8001562 <check_fs+0x52>

#if FF_FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* Check if exFAT VBR */
#endif
	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
 8001536:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800153a:	2beb      	cmp	r3, #235	; 0xeb
 800153c:	d003      	beq.n	8001546 <check_fs+0x36>
 800153e:	3318      	adds	r3, #24
 8001540:	b2db      	uxtb	r3, r3
 8001542:	2b01      	cmp	r3, #1
 8001544:	d82a      	bhi.n	800159c <check_fs+0x8c>
	} while (--cnt && r == 0);
 8001546:	f894 306a 	ldrb.w	r3, [r4, #106]	; 0x6a
 800154a:	2b46      	cmp	r3, #70	; 0x46
 800154c:	d111      	bne.n	8001572 <check_fs+0x62>
 800154e:	f894 306b 	ldrb.w	r3, [r4, #107]	; 0x6b
 8001552:	2b41      	cmp	r3, #65	; 0x41
 8001554:	d10d      	bne.n	8001572 <check_fs+0x62>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 8001556:	f894 306c 	ldrb.w	r3, [r4, #108]	; 0x6c
 800155a:	2b54      	cmp	r3, #84	; 0x54
 800155c:	d109      	bne.n	8001572 <check_fs+0x62>
 800155e:	2000      	movs	r0, #0
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
	}
	return 2;	/* Valid BS but not FAT */
}
 8001560:	bd10      	pop	{r4, pc}
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 8001562:	2003      	movs	r0, #3
}
 8001564:	bd10      	pop	{r4, pc}
 8001566:	f7ff fe53 	bl	8001210 <move_window.part.6>
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 800156a:	2800      	cmp	r0, #0
 800156c:	d0d9      	beq.n	8001522 <check_fs+0x12>
 800156e:	2004      	movs	r0, #4
}
 8001570:	bd10      	pop	{r4, pc}
		r = *d++ - *s++;
 8001572:	f894 3086 	ldrb.w	r3, [r4, #134]	; 0x86
 8001576:	490a      	ldr	r1, [pc, #40]	; (80015a0 <check_fs+0x90>)
 8001578:	f104 0287 	add.w	r2, r4, #135	; 0x87
 800157c:	3b46      	subs	r3, #70	; 0x46
 800157e:	348b      	adds	r4, #139	; 0x8b
	} while (--cnt && r == 0);
 8001580:	b963      	cbnz	r3, 800159c <check_fs+0x8c>
		r = *d++ - *s++;
 8001582:	f812 3b01 	ldrb.w	r3, [r2], #1
 8001586:	f811 0f01 	ldrb.w	r0, [r1, #1]!
	} while (--cnt && r == 0);
 800158a:	42a2      	cmp	r2, r4
		r = *d++ - *s++;
 800158c:	eba3 0300 	sub.w	r3, r3, r0
	} while (--cnt && r == 0);
 8001590:	d1f6      	bne.n	8001580 <check_fs+0x70>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
 8001592:	2b00      	cmp	r3, #0
 8001594:	bf14      	ite	ne
 8001596:	2002      	movne	r0, #2
 8001598:	2000      	moveq	r0, #0
}
 800159a:	bd10      	pop	{r4, pc}
	return 2;	/* Valid BS but not FAT */
 800159c:	2002      	movs	r0, #2
}
 800159e:	bd10      	pop	{r4, pc}
 80015a0:	080040dc 	.word	0x080040dc
	...

080015b0 <find_volume>:
static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
	const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
	BYTE mode					/* !=0: Check write protection for write access */
)
{
 80015b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 80015b4:	2300      	movs	r3, #0
{
 80015b6:	b084      	sub	sp, #16
	*rfs = 0;
 80015b8:	600b      	str	r3, [r1, #0]
{
 80015ba:	460d      	mov	r5, r1
	vol = get_ldnumber(path);
 80015bc:	f7ff f808 	bl	80005d0 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 80015c0:	1e02      	subs	r2, r0, #0
 80015c2:	f2c0 80c8 	blt.w	8001756 <find_volume+0x1a6>

	/* Check if the filesystem object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
 80015c6:	4bbd      	ldr	r3, [pc, #756]	; (80018bc <find_volume+0x30c>)
 80015c8:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 80015cc:	2c00      	cmp	r4, #0
 80015ce:	f000 80e8 	beq.w	80017a2 <find_volume+0x1f2>
#if FF_FS_REENTRANT
	if (!lock_fs(fs)) return FR_TIMEOUT;	/* Lock the volume */
#endif
	*rfs = fs;							/* Return pointer to the filesystem object */
 80015d2:	602c      	str	r4, [r5, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
 80015d4:	7823      	ldrb	r3, [r4, #0]
 80015d6:	b143      	cbz	r3, 80015ea <find_volume+0x3a>
		stat = disk_status(fs->pdrv);
 80015d8:	7860      	ldrb	r0, [r4, #1]
 80015da:	f7ff f829 	bl	8000630 <disk_initialize>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 80015de:	f010 0001 	ands.w	r0, r0, #1
 80015e2:	d102      	bne.n	80015ea <find_volume+0x3a>
#endif
#if FF_FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
#endif
	return FR_OK;
}
 80015e4:	b004      	add	sp, #16
 80015e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 80015ea:	b2d0      	uxtb	r0, r2
	fs->fs_type = 0;					/* Clear the filesystem object */
 80015ec:	2300      	movs	r3, #0
	fs->pdrv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 80015ee:	7060      	strb	r0, [r4, #1]
	fs->fs_type = 0;					/* Clear the filesystem object */
 80015f0:	7023      	strb	r3, [r4, #0]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
 80015f2:	f7ff f81d 	bl	8000630 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 80015f6:	f010 0501 	ands.w	r5, r0, #1
 80015fa:	f040 80ae 	bne.w	800175a <find_volume+0x1aa>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 80015fe:	4629      	mov	r1, r5
 8001600:	4620      	mov	r0, r4
 8001602:	f7ff ff85 	bl	8001510 <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 8001606:	2802      	cmp	r0, #2
 8001608:	f000 80a9 	beq.w	800175e <find_volume+0x1ae>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800160c:	2804      	cmp	r0, #4
 800160e:	f000 80d1 	beq.w	80017b4 <find_volume+0x204>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8001612:	2801      	cmp	r0, #1
 8001614:	f200 80c3 	bhi.w	800179e <find_volume+0x1ee>
	rv = rv << 8 | ptr[0];
 8001618:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 800161c:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 8001620:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8001624:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001628:	f040 80b9 	bne.w	800179e <find_volume+0x1ee>
	rv = rv << 8 | ptr[0];
 800162c:	f894 204b 	ldrb.w	r2, [r4, #75]	; 0x4b
 8001630:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8001634:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 8001638:	d109      	bne.n	800164e <find_volume+0x9e>
	rv = rv << 8 | ptr[2];
 800163a:	f8b4 105a 	ldrh.w	r1, [r4, #90]	; 0x5a
	rv = rv << 8 | ptr[1];
 800163e:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
	rv = rv << 8 | ptr[0];
 8001642:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
	rv = rv << 8 | ptr[1];
 8001646:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	rv = rv << 8 | ptr[0];
 800164a:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 800164e:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
		fs->fsize = fasize;
 8001652:	61e3      	str	r3, [r4, #28]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8001654:	1e51      	subs	r1, r2, #1
 8001656:	2901      	cmp	r1, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8001658:	70a2      	strb	r2, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 800165a:	f200 80a0 	bhi.w	800179e <find_volume+0x1ee>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 800165e:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 8001662:	b288      	uxth	r0, r1
 8001664:	8160      	strh	r0, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8001666:	2800      	cmp	r0, #0
 8001668:	f000 8099 	beq.w	800179e <find_volume+0x1ee>
 800166c:	1e48      	subs	r0, r1, #1
 800166e:	4208      	tst	r0, r1
 8001670:	f040 8095 	bne.w	800179e <find_volume+0x1ee>
	rv = rv << 8 | ptr[0];
 8001674:	f894 0046 	ldrb.w	r0, [r4, #70]	; 0x46
 8001678:	f894 6045 	ldrb.w	r6, [r4, #69]	; 0x45
 800167c:	ea46 2600 	orr.w	r6, r6, r0, lsl #8
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8001680:	0730      	lsls	r0, r6, #28
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 8001682:	8126      	strh	r6, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8001684:	f040 808b 	bne.w	800179e <find_volume+0x1ee>
	rv = rv << 8 | ptr[0];
 8001688:	f894 7048 	ldrb.w	r7, [r4, #72]	; 0x48
 800168c:	f894 0047 	ldrb.w	r0, [r4, #71]	; 0x47
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8001690:	ea50 2007 	orrs.w	r0, r0, r7, lsl #8
 8001694:	d109      	bne.n	80016aa <find_volume+0xfa>
	rv = rv << 8 | ptr[2];
 8001696:	f8b4 c056 	ldrh.w	ip, [r4, #86]	; 0x56
	rv = rv << 8 | ptr[1];
 800169a:	f894 7055 	ldrb.w	r7, [r4, #85]	; 0x55
	rv = rv << 8 | ptr[0];
 800169e:	f894 0054 	ldrb.w	r0, [r4, #84]	; 0x54
	rv = rv << 8 | ptr[1];
 80016a2:	ea47 270c 	orr.w	r7, r7, ip, lsl #8
	rv = rv << 8 | ptr[0];
 80016a6:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
	rv = rv << 8 | ptr[0];
 80016aa:	f894 c043 	ldrb.w	ip, [r4, #67]	; 0x43
 80016ae:	f894 7042 	ldrb.w	r7, [r4, #66]	; 0x42
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 80016b2:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
 80016b6:	d072      	beq.n	800179e <find_volume+0x1ee>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 80016b8:	fb03 f202 	mul.w	r2, r3, r2
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 80016bc:	eb07 1c16 	add.w	ip, r7, r6, lsr #4
 80016c0:	eb0c 0e02 	add.w	lr, ip, r2
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 80016c4:	4570      	cmp	r0, lr
 80016c6:	d36a      	bcc.n	800179e <find_volume+0x1ee>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 80016c8:	eba0 000e 	sub.w	r0, r0, lr
 80016cc:	fbb0 f1f1 	udiv	r1, r0, r1
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 80016d0:	2900      	cmp	r1, #0
 80016d2:	d064      	beq.n	800179e <find_volume+0x1ee>
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
 80016d4:	487a      	ldr	r0, [pc, #488]	; (80018c0 <find_volume+0x310>)
 80016d6:	4281      	cmp	r1, r0
 80016d8:	d861      	bhi.n	800179e <find_volume+0x1ee>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 80016da:	f64f 70f5 	movw	r0, #65525	; 0xfff5
 80016de:	4281      	cmp	r1, r0
 80016e0:	d96a      	bls.n	80017b8 <find_volume+0x208>
	rv = rv << 8 | ptr[0];
 80016e2:	f894 805f 	ldrb.w	r8, [r4, #95]	; 0x5f
 80016e6:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
		fs->volbase = bsect;							/* Volume start sector */
 80016ea:	6225      	str	r5, [r4, #32]
 80016ec:	3102      	adds	r1, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80016ee:	442f      	add	r7, r5
		fs->database = bsect + sysect;					/* Data start sector */
 80016f0:	eb0e 0005 	add.w	r0, lr, r5
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 80016f4:	ea52 2208 	orrs.w	r2, r2, r8, lsl #8
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 80016f8:	61a1      	str	r1, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80016fa:	6267      	str	r7, [r4, #36]	; 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 80016fc:	62e0      	str	r0, [r4, #44]	; 0x2c
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 80016fe:	d14e      	bne.n	800179e <find_volume+0x1ee>
			if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 8001700:	2e00      	cmp	r6, #0
 8001702:	d14c      	bne.n	800179e <find_volume+0x1ee>
	rv = rv << 8 | ptr[2];
 8001704:	f8b4 2062 	ldrh.w	r2, [r4, #98]	; 0x62
	rv = rv << 8 | ptr[1];
 8001708:	f894 6061 	ldrb.w	r6, [r4, #97]	; 0x61
	rv = rv << 8 | ptr[0];
 800170c:	f894 0060 	ldrb.w	r0, [r4, #96]	; 0x60
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8001710:	0089      	lsls	r1, r1, #2
	rv = rv << 8 | ptr[1];
 8001712:	ea46 2602 	orr.w	r6, r6, r2, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8001716:	f201 12ff 	addw	r2, r1, #511	; 0x1ff
	rv = rv << 8 | ptr[0];
 800171a:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800171e:	ebb3 2f52 	cmp.w	r3, r2, lsr #9
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 8001722:	62a0      	str	r0, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8001724:	d33b      	bcc.n	800179e <find_volume+0x1ee>
	rv = rv << 8 | ptr[0];
 8001726:	f894 1065 	ldrb.w	r1, [r4, #101]	; 0x65
 800172a:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
 800172e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8001732:	f04f 32ff 	mov.w	r2, #4294967295
		fs->fsi_flag = 0x80;
 8001736:	2180      	movs	r1, #128	; 0x80
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8001738:	2b01      	cmp	r3, #1
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800173a:	e9c4 2204 	strd	r2, r2, [r4, #16]
		fs->fsi_flag = 0x80;
 800173e:	7121      	strb	r1, [r4, #4]
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8001740:	d070      	beq.n	8001824 <find_volume+0x274>
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8001742:	2303      	movs	r3, #3
	fs->id = ++Fsid;		/* Volume mount ID */
 8001744:	4a5f      	ldr	r2, [pc, #380]	; (80018c4 <find_volume+0x314>)
	fs->fs_type = fmt;		/* FAT sub-type */
 8001746:	7023      	strb	r3, [r4, #0]
	fs->id = ++Fsid;		/* Volume mount ID */
 8001748:	8813      	ldrh	r3, [r2, #0]
 800174a:	3301      	adds	r3, #1
 800174c:	b29b      	uxth	r3, r3
 800174e:	8013      	strh	r3, [r2, #0]
 8001750:	80e3      	strh	r3, [r4, #6]
	return FR_OK;
 8001752:	2000      	movs	r0, #0
 8001754:	e746      	b.n	80015e4 <find_volume+0x34>
	if (vol < 0) return FR_INVALID_DRIVE;
 8001756:	200b      	movs	r0, #11
 8001758:	e744      	b.n	80015e4 <find_volume+0x34>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 800175a:	2003      	movs	r0, #3
 800175c:	e742      	b.n	80015e4 <find_volume+0x34>
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 800175e:	4629      	mov	r1, r5
 8001760:	f504 72fe 	add.w	r2, r4, #508	; 0x1fc
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8001764:	f812 3c06 	ldrb.w	r3, [r2, #-6]
 8001768:	b143      	cbz	r3, 800177c <find_volume+0x1cc>
	rv = rv << 8 | ptr[2];
 800176a:	8815      	ldrh	r5, [r2, #0]
	rv = rv << 8 | ptr[1];
 800176c:	f812 0c01 	ldrb.w	r0, [r2, #-1]
	rv = rv << 8 | ptr[0];
 8001770:	f812 3c02 	ldrb.w	r3, [r2, #-2]
	rv = rv << 8 | ptr[1];
 8001774:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
	rv = rv << 8 | ptr[0];
 8001778:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 800177c:	f84d 3021 	str.w	r3, [sp, r1, lsl #2]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 8001780:	3101      	adds	r1, #1
 8001782:	2904      	cmp	r1, #4
 8001784:	f102 0210 	add.w	r2, r2, #16
 8001788:	d1ec      	bne.n	8001764 <find_volume+0x1b4>
 800178a:	2600      	movs	r6, #0
			bsect = br[i];
 800178c:	f85d 5026 	ldr.w	r5, [sp, r6, lsl #2]
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8001790:	3601      	adds	r6, #1
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8001792:	b945      	cbnz	r5, 80017a6 <find_volume+0x1f6>
 8001794:	2003      	movs	r0, #3
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8001796:	2e04      	cmp	r6, #4
 8001798:	d1f8      	bne.n	800178c <find_volume+0x1dc>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 800179a:	2804      	cmp	r0, #4
 800179c:	d00a      	beq.n	80017b4 <find_volume+0x204>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 800179e:	200d      	movs	r0, #13
 80017a0:	e720      	b.n	80015e4 <find_volume+0x34>
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
 80017a2:	200c      	movs	r0, #12
 80017a4:	e71e      	b.n	80015e4 <find_volume+0x34>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 80017a6:	4629      	mov	r1, r5
 80017a8:	4620      	mov	r0, r4
 80017aa:	f7ff feb1 	bl	8001510 <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 80017ae:	2801      	cmp	r0, #1
 80017b0:	d8f1      	bhi.n	8001796 <find_volume+0x1e6>
 80017b2:	e731      	b.n	8001618 <find_volume+0x68>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80017b4:	2001      	movs	r0, #1
 80017b6:	e715      	b.n	80015e4 <find_volume+0x34>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 80017b8:	f640 78f5 	movw	r8, #4085	; 0xff5
 80017bc:	eb07 0c05 	add.w	ip, r7, r5
 80017c0:	eb0e 0005 	add.w	r0, lr, r5
 80017c4:	1c8f      	adds	r7, r1, #2
 80017c6:	4541      	cmp	r1, r8
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 80017c8:	61a7      	str	r7, [r4, #24]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80017ca:	e9c4 5c08 	strd	r5, ip, [r4, #32]
		fs->database = bsect + sysect;					/* Data start sector */
 80017ce:	62e0      	str	r0, [r4, #44]	; 0x2c
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 80017d0:	d816      	bhi.n	8001800 <find_volume+0x250>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 80017d2:	2e00      	cmp	r6, #0
 80017d4:	d0e3      	beq.n	800179e <find_volume+0x1ee>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 80017d6:	f007 0101 	and.w	r1, r7, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80017da:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 80017de:	eb07 0747 	add.w	r7, r7, r7, lsl #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80017e2:	eb01 0757 	add.w	r7, r1, r7, lsr #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 80017e6:	4462      	add	r2, ip
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80017e8:	ebb3 2f57 	cmp.w	r3, r7, lsr #9
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 80017ec:	62a2      	str	r2, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 80017ee:	d3d6      	bcc.n	800179e <find_volume+0x1ee>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 80017f0:	f04f 33ff 	mov.w	r3, #4294967295
		fs->fsi_flag = 0x80;
 80017f4:	2280      	movs	r2, #128	; 0x80
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 80017f6:	e9c4 3304 	strd	r3, r3, [r4, #16]
		fs->fsi_flag = 0x80;
 80017fa:	7122      	strb	r2, [r4, #4]
 80017fc:	2301      	movs	r3, #1
 80017fe:	e7a1      	b.n	8001744 <find_volume+0x194>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8001800:	2e00      	cmp	r6, #0
 8001802:	d0cc      	beq.n	800179e <find_volume+0x1ee>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8001804:	0079      	lsls	r1, r7, #1
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8001806:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 800180a:	4462      	add	r2, ip
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 800180c:	ebb3 2f51 	cmp.w	r3, r1, lsr #9
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8001810:	62a2      	str	r2, [r4, #40]	; 0x28
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8001812:	d3c4      	bcc.n	800179e <find_volume+0x1ee>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8001814:	f04f 33ff 	mov.w	r3, #4294967295
		fs->fsi_flag = 0x80;
 8001818:	2280      	movs	r2, #128	; 0x80
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 800181a:	e9c4 3304 	strd	r3, r3, [r4, #16]
		fs->fsi_flag = 0x80;
 800181e:	7122      	strb	r2, [r4, #4]
 8001820:	2302      	movs	r3, #2
 8001822:	e78f      	b.n	8001744 <find_volume+0x194>
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001824:	6b23      	ldr	r3, [r4, #48]	; 0x30
			&& move_window(fs, bsect + 1) == FR_OK)
 8001826:	1c69      	adds	r1, r5, #1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8001828:	4299      	cmp	r1, r3
 800182a:	d004      	beq.n	8001836 <find_volume+0x286>
 800182c:	4620      	mov	r0, r4
 800182e:	f7ff fcef 	bl	8001210 <move_window.part.6>
			&& move_window(fs, bsect + 1) == FR_OK)
 8001832:	2800      	cmp	r0, #0
 8001834:	d185      	bne.n	8001742 <find_volume+0x192>
	rv = rv << 8 | ptr[0];
 8001836:	f894 2233 	ldrb.w	r2, [r4, #563]	; 0x233
 800183a:	f894 3232 	ldrb.w	r3, [r4, #562]	; 0x232
 800183e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 8001842:	f64a 2255 	movw	r2, #43605	; 0xaa55
			fs->fsi_flag = 0;
 8001846:	2100      	movs	r1, #0
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 8001848:	4293      	cmp	r3, r2
			fs->fsi_flag = 0;
 800184a:	7121      	strb	r1, [r4, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
 800184c:	f47f af79 	bne.w	8001742 <find_volume+0x192>
	rv = rv << 8 | ptr[2];
 8001850:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
	rv = rv << 8 | ptr[1];
 8001852:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
	rv = rv << 8 | ptr[0];
 8001856:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 800185a:	491b      	ldr	r1, [pc, #108]	; (80018c8 <find_volume+0x318>)
	rv = rv << 8 | ptr[1];
 800185c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	rv = rv << 8 | ptr[0];
 8001860:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 8001864:	428b      	cmp	r3, r1
 8001866:	f47f af6c 	bne.w	8001742 <find_volume+0x192>
	rv = rv << 8 | ptr[2];
 800186a:	f8b4 021a 	ldrh.w	r0, [r4, #538]	; 0x21a
	rv = rv << 8 | ptr[1];
 800186e:	f894 2219 	ldrb.w	r2, [r4, #537]	; 0x219
	rv = rv << 8 | ptr[0];
 8001872:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8001876:	f101 51ff 	add.w	r1, r1, #534773760	; 0x1fe00000
 800187a:	f501 5100 	add.w	r1, r1, #8192	; 0x2000
	rv = rv << 8 | ptr[1];
 800187e:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8001882:	3120      	adds	r1, #32
	rv = rv << 8 | ptr[0];
 8001884:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8001888:	428b      	cmp	r3, r1
 800188a:	f47f af5a 	bne.w	8001742 <find_volume+0x192>
	rv = rv << 8 | ptr[2];
 800188e:	f8b4 621e 	ldrh.w	r6, [r4, #542]	; 0x21e
	rv = rv << 8 | ptr[1];
 8001892:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
	rv = rv << 8 | ptr[2];
 8001896:	f8b4 5222 	ldrh.w	r5, [r4, #546]	; 0x222
	rv = rv << 8 | ptr[1];
 800189a:	f894 1221 	ldrb.w	r1, [r4, #545]	; 0x221
	rv = rv << 8 | ptr[0];
 800189e:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
 80018a2:	f894 3220 	ldrb.w	r3, [r4, #544]	; 0x220
	rv = rv << 8 | ptr[1];
 80018a6:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
 80018aa:	ea41 2105 	orr.w	r1, r1, r5, lsl #8
	rv = rv << 8 | ptr[0];
 80018ae:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80018b2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 80018b6:	e9c4 3204 	strd	r3, r2, [r4, #16]
 80018ba:	e742      	b.n	8001742 <find_volume+0x192>
 80018bc:	20000800 	.word	0x20000800
 80018c0:	0ffffff5 	.word	0x0ffffff5
 80018c4:	20000804 	.word	0x20000804
 80018c8:	41615252 	.word	0x41615252
 80018cc:	00000000 	.word	0x00000000

080018d0 <sdc_lld_read_special>:
                          uint8_t cmd, uint32_t arg) {
 80018d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  sdcp->sdio->DTIMER = STM32_SDC_READ_TIMEOUT;
 80018d2:	6c85      	ldr	r5, [r0, #72]	; 0x48
 80018d4:	4e1f      	ldr	r6, [pc, #124]	; (8001954 <sdc_lld_read_special+0x84>)
 80018d6:	626e      	str	r6, [r5, #36]	; 0x24
                          uint8_t cmd, uint32_t arg) {
 80018d8:	b083      	sub	sp, #12
 80018da:	4604      	mov	r4, r0
 80018dc:	460d      	mov	r5, r1
 80018de:	4616      	mov	r6, r2
 80018e0:	461f      	mov	r7, r3
  if (_sdc_wait_for_transfer_state(sdcp))
 80018e2:	f7ff fa6d 	bl	8000dc0 <_sdc_wait_for_transfer_state>
 80018e6:	2800      	cmp	r0, #0
 80018e8:	d132      	bne.n	8001950 <sdc_lld_read_special+0x80>
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 80018ea:	e9d4 2310 	ldrd	r2, r3, [r4, #64]	; 0x40
  dmaStreamSetMemory0(sdcp->dma, buf);
 80018ee:	681b      	ldr	r3, [r3, #0]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80018f0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  dmaStreamSetMemory0(sdcp->dma, buf);
 80018f2:	60dd      	str	r5, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 80018f4:	08b1      	lsrs	r1, r6, #2
 80018f6:	6059      	str	r1, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 80018f8:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 80018fa:	681d      	ldr	r5, [r3, #0]
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 80018fc:	f8df c05c 	ldr.w	ip, [pc, #92]	; 800195c <sdc_lld_read_special+0x8c>
  dmaStreamEnable(sdcp->dma);
 8001900:	f045 0501 	orr.w	r5, r5, #1
 8001904:	601d      	str	r5, [r3, #0]
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 8001906:	220f      	movs	r2, #15
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8001908:	f240 332a 	movw	r3, #810	; 0x32a
  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 800190c:	ad01      	add	r5, sp, #4
  sdcp->sdio->ICR   = STM32_SDIO_ICR_ALL_FLAGS;
 800190e:	f8c0 c038 	str.w	ip, [r0, #56]	; 0x38
  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 8001912:	4639      	mov	r1, r7
  sdcp->sdio->MASK  = SDIO_MASK_DCRCFAILIE |
 8001914:	63c3      	str	r3, [r0, #60]	; 0x3c
  sdcp->sdio->DLEN  = bytes;
 8001916:	6286      	str	r6, [r0, #40]	; 0x28
  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 8001918:	462b      	mov	r3, r5
  sdcp->sdio->DCTRL = SDIO_DCTRL_DTDIR |
 800191a:	62c2      	str	r2, [r0, #44]	; 0x2c
  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 800191c:	9a08      	ldr	r2, [sp, #32]
 800191e:	4620      	mov	r0, r4
 8001920:	f7fe ffd6 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001924:	b138      	cbz	r0, 8001936 <sdc_lld_read_special+0x66>
  sdc_lld_error_cleanup(sdcp, 1, resp);
 8001926:	4620      	mov	r0, r4
 8001928:	462a      	mov	r2, r5
 800192a:	2101      	movs	r1, #1
 800192c:	f7ff f810 	bl	8000950 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 8001930:	2001      	movs	r0, #1
}
 8001932:	b003      	add	sp, #12
 8001934:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 || MMCSD_R1_ERROR(resp[0]))
 8001936:	9a01      	ldr	r2, [sp, #4]
 8001938:	4b07      	ldr	r3, [pc, #28]	; (8001958 <sdc_lld_read_special+0x88>)
 800193a:	4013      	ands	r3, r2
 800193c:	2b00      	cmp	r3, #0
 800193e:	d1f2      	bne.n	8001926 <sdc_lld_read_special+0x56>
  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 8001940:	462a      	mov	r2, r5
 8001942:	2101      	movs	r1, #1
 8001944:	4620      	mov	r0, r4
 8001946:	f7ff fa7b 	bl	8000e40 <sdc_lld_wait_transaction_end>
 800194a:	2800      	cmp	r0, #0
 800194c:	d1eb      	bne.n	8001926 <sdc_lld_read_special+0x56>
 800194e:	e7f0      	b.n	8001932 <sdc_lld_read_special+0x62>
 8001950:	ad01      	add	r5, sp, #4
 8001952:	e7e8      	b.n	8001926 <sdc_lld_read_special+0x56>
 8001954:	016e3600 	.word	0x016e3600
 8001958:	fdffe008 	.word	0xfdffe008
 800195c:	00c007ff 	.word	0x00c007ff

08001960 <myPrintf>:
  palSetPadMode(GPIOC,6U,PAL_MODE_ALTERNATE(8));
  palSetPadMode(GPIOC,7U,PAL_MODE_ALTERNATE(8));
}


int myPrintf(const char *fmt, ...) {
 8001960:	b40f      	push	{r0, r1, r2, r3}
 8001962:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001966:	b087      	sub	sp, #28
 8001968:	ab10      	add	r3, sp, #64	; 0x40
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800196a:	2700      	movs	r7, #0
 800196c:	f853 4b04 	ldr.w	r4, [r3], #4
 8001970:	4ebb      	ldr	r6, [pc, #748]	; (8001c60 <myPrintf+0x300>)
 8001972:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8001976:	e005      	b.n	8001984 <myPrintf+0x24>
    if (c == 0) {
      return n;
    }
    
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8001978:	6833      	ldr	r3, [r6, #0]
 800197a:	48b9      	ldr	r0, [pc, #740]	; (8001c60 <myPrintf+0x300>)
 800197c:	68db      	ldr	r3, [r3, #12]
      n++;
 800197e:	3701      	adds	r7, #1
    c = *fmt++;
 8001980:	462c      	mov	r4, r5
      streamPut(chp, (uint8_t)c);
 8001982:	4798      	blx	r3
    c = *fmt++;
 8001984:	7821      	ldrb	r1, [r4, #0]
 8001986:	1c65      	adds	r5, r4, #1
    if (c == 0) {
 8001988:	2900      	cmp	r1, #0
 800198a:	d073      	beq.n	8001a74 <myPrintf+0x114>
    if (c != '%') {
 800198c:	2925      	cmp	r1, #37	; 0x25
 800198e:	d1f3      	bne.n	8001978 <myPrintf+0x18>
    p = tmpbuf;
    s = tmpbuf;

    /* Alignment mode.*/
    left_align = false;
    if (*fmt == '-') {
 8001990:	7863      	ldrb	r3, [r4, #1]
 8001992:	2b2d      	cmp	r3, #45	; 0x2d
 8001994:	bf03      	ittte	eq
 8001996:	78a3      	ldrbeq	r3, [r4, #2]
      fmt++;
 8001998:	1ca5      	addeq	r5, r4, #2
      left_align = true;
 800199a:	2001      	moveq	r0, #1
    left_align = false;
 800199c:	2000      	movne	r0, #0
    }

    /* Sign mode.*/
    do_sign = false;
    if (*fmt == '+') {
 800199e:	2b2b      	cmp	r3, #43	; 0x2b
 80019a0:	bf03      	ittte	eq
 80019a2:	786b      	ldrbeq	r3, [r5, #1]
      fmt++;
      do_sign = true;
 80019a4:	f04f 0c01 	moveq.w	ip, #1
      fmt++;
 80019a8:	4465      	addeq	r5, ip
    do_sign = false;
 80019aa:	f04f 0c00 	movne.w	ip, #0
    }

    /* Filler mode.*/
    filler = ' ';
    if (*fmt == '0') {
 80019ae:	2b30      	cmp	r3, #48	; 0x30
 80019b0:	bf03      	ittte	eq
 80019b2:	786b      	ldrbeq	r3, [r5, #1]
      fmt++;
      filler = '0';
 80019b4:	f04f 0830 	moveq.w	r8, #48	; 0x30
      fmt++;
 80019b8:	3501      	addeq	r5, #1
    filler = ' ';
 80019ba:	f04f 0820 	movne.w	r8, #32
    }
    
    /* Width modifier.*/
    if ( *fmt == '*') {
 80019be:	2b2a      	cmp	r3, #42	; 0x2a
 80019c0:	d141      	bne.n	8001a46 <myPrintf+0xe6>
      width = va_arg(ap, int);
 80019c2:	9b01      	ldr	r3, [sp, #4]
 80019c4:	f103 0e04 	add.w	lr, r3, #4
 80019c8:	681a      	ldr	r2, [r3, #0]
      ++fmt;
      c = *fmt++;
 80019ca:	786b      	ldrb	r3, [r5, #1]
 80019cc:	1cac      	adds	r4, r5, #2
      }
    }
    
    /* Precision modifier.*/
    precision = 0;
    if (c == '.') {
 80019ce:	2b2e      	cmp	r3, #46	; 0x2e
 80019d0:	f104 0501 	add.w	r5, r4, #1
 80019d4:	d07f      	beq.n	8001ad6 <myPrintf+0x176>
    precision = 0;
 80019d6:	2100      	movs	r1, #0
        }
      }
    }
    
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80019d8:	f003 09df 	and.w	r9, r3, #223	; 0xdf
 80019dc:	f1b9 0f4c 	cmp.w	r9, #76	; 0x4c
 80019e0:	d04e      	beq.n	8001a80 <myPrintf+0x120>
      if (c == 0) {
        return n;
      }
    }
    else {
      is_long = (c >= 'A') && (c <= 'Z');
 80019e2:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
    }

    /* Command decoding.*/
    switch (c) {
 80019e6:	2b63      	cmp	r3, #99	; 0x63
      is_long = (c >= 'A') && (c <= 'Z');
 80019e8:	b2ed      	uxtb	r5, r5
    switch (c) {
 80019ea:	f000 80dc 	beq.w	8001ba6 <myPrintf+0x246>
 80019ee:	d95c      	bls.n	8001aaa <myPrintf+0x14a>
 80019f0:	2b70      	cmp	r3, #112	; 0x70
 80019f2:	f000 811b 	beq.w	8001c2c <myPrintf+0x2cc>
 80019f6:	f240 80a0 	bls.w	8001b3a <myPrintf+0x1da>
 80019fa:	2b75      	cmp	r3, #117	; 0x75
 80019fc:	f000 812d 	beq.w	8001c5a <myPrintf+0x2fa>
 8001a00:	2b78      	cmp	r3, #120	; 0x78
 8001a02:	f000 8113 	beq.w	8001c2c <myPrintf+0x2cc>
 8001a06:	2b73      	cmp	r3, #115	; 0x73
 8001a08:	d15c      	bne.n	8001ac4 <myPrintf+0x164>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0) {
 8001a0a:	f8de 5000 	ldr.w	r5, [lr]
 8001a0e:	f10e 0304 	add.w	r3, lr, #4
 8001a12:	9301      	str	r3, [sp, #4]
 8001a14:	2d00      	cmp	r5, #0
 8001a16:	f000 8191 	beq.w	8001d3c <myPrintf+0x3dc>
 8001a1a:	782b      	ldrb	r3, [r5, #0]
        s = "(null)";
      }
      if (precision == 0) {
 8001a1c:	2900      	cmp	r1, #0
 8001a1e:	f040 8174 	bne.w	8001d0a <myPrintf+0x3aa>
        precision = 32767;
      }
      for (p = s; *p && (--precision >= 0); p++)
 8001a22:	2b00      	cmp	r3, #0
 8001a24:	f000 819a 	beq.w	8001d5c <myPrintf+0x3fc>
 8001a28:	46a9      	mov	r9, r5
 8001a2a:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8001a2e:	464d      	mov	r5, r9
 8001a30:	e001      	b.n	8001a36 <myPrintf+0xd6>
 8001a32:	1c4b      	adds	r3, r1, #1
 8001a34:	d004      	beq.n	8001a40 <myPrintf+0xe0>
 8001a36:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8001a3a:	3901      	subs	r1, #1
 8001a3c:	2b00      	cmp	r3, #0
 8001a3e:	d1f8      	bne.n	8001a32 <myPrintf+0xd2>
      filler = ' ';
 8001a40:	f04f 0820 	mov.w	r8, #32
 8001a44:	e0bc      	b.n	8001bc0 <myPrintf+0x260>
        c = *fmt++;
 8001a46:	1c6c      	adds	r4, r5, #1
        if (c == 0) {
 8001a48:	b1a3      	cbz	r3, 8001a74 <myPrintf+0x114>
        if (c >= '0' && c <= '9') {
 8001a4a:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8001a4e:	b2c9      	uxtb	r1, r1
 8001a50:	2909      	cmp	r1, #9
      width = 0;
 8001a52:	bf98      	it	ls
 8001a54:	2200      	movls	r2, #0
        if (c >= '0' && c <= '9') {
 8001a56:	d902      	bls.n	8001a5e <myPrintf+0xfe>
 8001a58:	e15d      	b.n	8001d16 <myPrintf+0x3b6>
 8001a5a:	2909      	cmp	r1, #9
 8001a5c:	d848      	bhi.n	8001af0 <myPrintf+0x190>
        c = *fmt++;
 8001a5e:	f814 3b01 	ldrb.w	r3, [r4], #1
          width = width * 10 + c;
 8001a62:	eb02 0282 	add.w	r2, r2, r2, lsl #2
        if (c >= '0' && c <= '9') {
 8001a66:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
          width = width * 10 + c;
 8001a6a:	eb01 0242 	add.w	r2, r1, r2, lsl #1
        if (c >= '0' && c <= '9') {
 8001a6e:	b2e9      	uxtb	r1, r5
        if (c == 0) {
 8001a70:	2b00      	cmp	r3, #0
 8001a72:	d1f2      	bne.n	8001a5a <myPrintf+0xfa>
  va_start(ap, fmt);
  formatted_bytes = chvprintf((BaseSequentialStream*)&SD6, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 8001a74:	4638      	mov	r0, r7
 8001a76:	b007      	add	sp, #28
 8001a78:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001a7c:	b004      	add	sp, #16
 8001a7e:	4770      	bx	lr
      c = *fmt++;
 8001a80:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 8001a82:	2b00      	cmp	r3, #0
 8001a84:	d0f6      	beq.n	8001a74 <myPrintf+0x114>
    switch (c) {
 8001a86:	2b63      	cmp	r3, #99	; 0x63
 8001a88:	f000 808c 	beq.w	8001ba4 <myPrintf+0x244>
 8001a8c:	d948      	bls.n	8001b20 <myPrintf+0x1c0>
 8001a8e:	2b70      	cmp	r3, #112	; 0x70
 8001a90:	f000 80cb 	beq.w	8001c2a <myPrintf+0x2ca>
 8001a94:	d97e      	bls.n	8001b94 <myPrintf+0x234>
 8001a96:	2b75      	cmp	r3, #117	; 0x75
 8001a98:	f000 80de 	beq.w	8001c58 <myPrintf+0x2f8>
 8001a9c:	2b78      	cmp	r3, #120	; 0x78
 8001a9e:	f000 80c4 	beq.w	8001c2a <myPrintf+0x2ca>
 8001aa2:	2b73      	cmp	r3, #115	; 0x73
 8001aa4:	d147      	bne.n	8001b36 <myPrintf+0x1d6>
      c = *fmt++;
 8001aa6:	462c      	mov	r4, r5
 8001aa8:	e7af      	b.n	8001a0a <myPrintf+0xaa>
    switch (c) {
 8001aaa:	2b4f      	cmp	r3, #79	; 0x4f
 8001aac:	d04b      	beq.n	8001b46 <myPrintf+0x1e6>
 8001aae:	f240 80e6 	bls.w	8001c7e <myPrintf+0x31e>
 8001ab2:	2b55      	cmp	r3, #85	; 0x55
 8001ab4:	f000 80d1 	beq.w	8001c5a <myPrintf+0x2fa>
 8001ab8:	2b58      	cmp	r3, #88	; 0x58
 8001aba:	f000 80b7 	beq.w	8001c2c <myPrintf+0x2cc>
 8001abe:	2b50      	cmp	r3, #80	; 0x50
 8001ac0:	f000 80b4 	beq.w	8001c2c <myPrintf+0x2cc>
        l = va_arg(ap, unsigned int);
      }
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001ac4:	f10d 0918 	add.w	r9, sp, #24
 8001ac8:	f8cd e004 	str.w	lr, [sp, #4]
 8001acc:	f809 3d0c 	strb.w	r3, [r9, #-12]!
 8001ad0:	f10d 050d 	add.w	r5, sp, #13
 8001ad4:	e074      	b.n	8001bc0 <myPrintf+0x260>
      c = *fmt++;
 8001ad6:	7823      	ldrb	r3, [r4, #0]
      if (c == 0) {
 8001ad8:	2b00      	cmp	r3, #0
 8001ada:	d0cb      	beq.n	8001a74 <myPrintf+0x114>
      if (c == '*') {
 8001adc:	2b2a      	cmp	r3, #42	; 0x2a
 8001ade:	d10a      	bne.n	8001af6 <myPrintf+0x196>
        precision = va_arg(ap, int);
 8001ae0:	f8de 1000 	ldr.w	r1, [lr]
        c = *fmt++;
 8001ae4:	7863      	ldrb	r3, [r4, #1]
 8001ae6:	1ce5      	adds	r5, r4, #3
        precision = va_arg(ap, int);
 8001ae8:	f10e 0e04 	add.w	lr, lr, #4
        c = *fmt++;
 8001aec:	3402      	adds	r4, #2
 8001aee:	e773      	b.n	80019d8 <myPrintf+0x78>
        if (c >= '0' && c <= '9') {
 8001af0:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001af4:	e76b      	b.n	80019ce <myPrintf+0x6e>
    precision = 0;
 8001af6:	2100      	movs	r1, #0
 8001af8:	e006      	b.n	8001b08 <myPrintf+0x1a8>
          c = *fmt++;
 8001afa:	f819 3c01 	ldrb.w	r3, [r9, #-1]
          precision = precision * 10 + c;
 8001afe:	eb04 014a 	add.w	r1, r4, sl, lsl #1
 8001b02:	464d      	mov	r5, r9
          if (c == 0) {
 8001b04:	2b00      	cmp	r3, #0
 8001b06:	d0b5      	beq.n	8001a74 <myPrintf+0x114>
        while (c >= '0' && c <= '9') {
 8001b08:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
 8001b0c:	b2e4      	uxtb	r4, r4
 8001b0e:	2c09      	cmp	r4, #9
 8001b10:	f105 0901 	add.w	r9, r5, #1
          precision = precision * 10 + c;
 8001b14:	eb01 0a81 	add.w	sl, r1, r1, lsl #2
        while (c >= '0' && c <= '9') {
 8001b18:	d9ef      	bls.n	8001afa <myPrintf+0x19a>
 8001b1a:	462c      	mov	r4, r5
 8001b1c:	464d      	mov	r5, r9
 8001b1e:	e75b      	b.n	80019d8 <myPrintf+0x78>
    switch (c) {
 8001b20:	2b4f      	cmp	r3, #79	; 0x4f
 8001b22:	d03d      	beq.n	8001ba0 <myPrintf+0x240>
 8001b24:	f240 80e5 	bls.w	8001cf2 <myPrintf+0x392>
 8001b28:	2b55      	cmp	r3, #85	; 0x55
 8001b2a:	f000 8095 	beq.w	8001c58 <myPrintf+0x2f8>
 8001b2e:	2b58      	cmp	r3, #88	; 0x58
 8001b30:	d07b      	beq.n	8001c2a <myPrintf+0x2ca>
 8001b32:	2b50      	cmp	r3, #80	; 0x50
 8001b34:	d079      	beq.n	8001c2a <myPrintf+0x2ca>
      c = *fmt++;
 8001b36:	462c      	mov	r4, r5
 8001b38:	e7c4      	b.n	8001ac4 <myPrintf+0x164>
    switch (c) {
 8001b3a:	2b69      	cmp	r3, #105	; 0x69
 8001b3c:	f000 80a4 	beq.w	8001c88 <myPrintf+0x328>
 8001b40:	2b6f      	cmp	r3, #111	; 0x6f
 8001b42:	f040 8101 	bne.w	8001d48 <myPrintf+0x3e8>
      c = 8;
 8001b46:	f04f 0908 	mov.w	r9, #8
 8001b4a:	4671      	mov	r1, lr
  q = p + MAX_FILLER;
 8001b4c:	f10d 0517 	add.w	r5, sp, #23
 8001b50:	f851 3b04 	ldr.w	r3, [r1], #4
 8001b54:	9101      	str	r1, [sp, #4]
 8001b56:	4629      	mov	r1, r5
    i = (int)(l % radix);
 8001b58:	fbb3 fef9 	udiv	lr, r3, r9
 8001b5c:	fb09 331e 	mls	r3, r9, lr, r3
    i += '0';
 8001b60:	f103 0c30 	add.w	ip, r3, #48	; 0x30
    if (i > '9') {
 8001b64:	f1bc 0f39 	cmp.w	ip, #57	; 0x39
      i += 'A' - '0' - 10;
 8001b68:	bfc8      	it	gt
 8001b6a:	f103 0c37 	addgt.w	ip, r3, #55	; 0x37
    l /= radix;
 8001b6e:	4673      	mov	r3, lr
    *--q = i;
 8001b70:	f801 cd01 	strb.w	ip, [r1, #-1]!
  } while ((ll /= radix) != 0);
 8001b74:	2b00      	cmp	r3, #0
 8001b76:	d1ef      	bne.n	8001b58 <myPrintf+0x1f8>
  i = (int)(p + MAX_FILLER - q);
 8001b78:	1a6d      	subs	r5, r5, r1
 8001b7a:	f10d 090c 	add.w	r9, sp, #12
 8001b7e:	eb01 0e05 	add.w	lr, r1, r5
 8001b82:	464b      	mov	r3, r9
    *p++ = *q++;
 8001b84:	f811 cb01 	ldrb.w	ip, [r1], #1
 8001b88:	f803 cb01 	strb.w	ip, [r3], #1
  while (--i);
 8001b8c:	4571      	cmp	r1, lr
 8001b8e:	d1f9      	bne.n	8001b84 <myPrintf+0x224>
 8001b90:	444d      	add	r5, r9
 8001b92:	e015      	b.n	8001bc0 <myPrintf+0x260>
    switch (c) {
 8001b94:	2b69      	cmp	r3, #105	; 0x69
 8001b96:	f000 80b1 	beq.w	8001cfc <myPrintf+0x39c>
 8001b9a:	2b6f      	cmp	r3, #111	; 0x6f
 8001b9c:	f040 80d8 	bne.w	8001d50 <myPrintf+0x3f0>
      c = *fmt++;
 8001ba0:	462c      	mov	r4, r5
 8001ba2:	e7d0      	b.n	8001b46 <myPrintf+0x1e6>
 8001ba4:	462c      	mov	r4, r5
      *p++ = va_arg(ap, int);
 8001ba6:	f10d 0918 	add.w	r9, sp, #24
 8001baa:	f8de 3000 	ldr.w	r3, [lr]
 8001bae:	f809 3d0c 	strb.w	r3, [r9, #-12]!
 8001bb2:	f10e 0304 	add.w	r3, lr, #4
 8001bb6:	9301      	str	r3, [sp, #4]
      filler = ' ';
 8001bb8:	f04f 0820 	mov.w	r8, #32
      *p++ = va_arg(ap, int);
 8001bbc:	f10d 050d 	add.w	r5, sp, #13
      break;
    }
    i = (int)(p - s);
 8001bc0:	eba5 0509 	sub.w	r5, r5, r9
 8001bc4:	f105 3aff 	add.w	sl, r5, #4294967295
    if ((width -= i) < 0) {
 8001bc8:	1b55      	subs	r5, r2, r5
 8001bca:	d437      	bmi.n	8001c3c <myPrintf+0x2dc>
      width = 0;
    }
    if (left_align == false) {
 8001bcc:	bb88      	cbnz	r0, 8001c32 <myPrintf+0x2d2>
      width = -width;
 8001bce:	f1c5 0b00 	rsb	fp, r5, #0
    }
    if (width < 0) {
 8001bd2:	b37d      	cbz	r5, 8001c34 <myPrintf+0x2d4>
      if (*s == '-' && filler == '0') {
 8001bd4:	f899 1000 	ldrb.w	r1, [r9]
 8001bd8:	292d      	cmp	r1, #45	; 0x2d
 8001bda:	d043      	beq.n	8001c64 <myPrintf+0x304>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8001bdc:	6833      	ldr	r3, [r6, #0]
 8001bde:	4641      	mov	r1, r8
 8001be0:	68db      	ldr	r3, [r3, #12]
 8001be2:	4630      	mov	r0, r6
 8001be4:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8001be6:	f11b 0b01 	adds.w	fp, fp, #1
 8001bea:	d1f7      	bne.n	8001bdc <myPrintf+0x27c>
    }
    while (--i >= 0) {
 8001bec:	f1ba 0f00 	cmp.w	sl, #0
 8001bf0:	442f      	add	r7, r5
 8001bf2:	f6ff aec7 	blt.w	8001984 <myPrintf+0x24>
      width = -width;
 8001bf6:	4655      	mov	r5, sl
      streamPut(chp, (uint8_t)*s++);
 8001bf8:	6833      	ldr	r3, [r6, #0]
 8001bfa:	f819 1b01 	ldrb.w	r1, [r9], #1
 8001bfe:	68db      	ldr	r3, [r3, #12]
    while (--i >= 0) {
 8001c00:	3d01      	subs	r5, #1
      streamPut(chp, (uint8_t)*s++);
 8001c02:	4630      	mov	r0, r6
 8001c04:	4798      	blx	r3
    while (--i >= 0) {
 8001c06:	1c6b      	adds	r3, r5, #1
 8001c08:	d1f6      	bne.n	8001bf8 <myPrintf+0x298>
 8001c0a:	3701      	adds	r7, #1
 8001c0c:	4457      	add	r7, sl
      n++;
    }

    while (width) {
 8001c0e:	f1bb 0f00 	cmp.w	fp, #0
 8001c12:	f43f aeb7 	beq.w	8001984 <myPrintf+0x24>
 8001c16:	465d      	mov	r5, fp
      streamPut(chp, (uint8_t)filler);
 8001c18:	6833      	ldr	r3, [r6, #0]
 8001c1a:	4641      	mov	r1, r8
 8001c1c:	68db      	ldr	r3, [r3, #12]
 8001c1e:	4630      	mov	r0, r6
 8001c20:	4798      	blx	r3
    while (width) {
 8001c22:	3d01      	subs	r5, #1
 8001c24:	d1f8      	bne.n	8001c18 <myPrintf+0x2b8>
 8001c26:	445f      	add	r7, fp
 8001c28:	e6ac      	b.n	8001984 <myPrintf+0x24>
      c = *fmt++;
 8001c2a:	462c      	mov	r4, r5
      c = 16;
 8001c2c:	f04f 0910 	mov.w	r9, #16
 8001c30:	e78b      	b.n	8001b4a <myPrintf+0x1ea>
    if (left_align == false) {
 8001c32:	46ab      	mov	fp, r5
    while (--i >= 0) {
 8001c34:	f1ba 0f00 	cmp.w	sl, #0
 8001c38:	dadd      	bge.n	8001bf6 <myPrintf+0x296>
 8001c3a:	e7e8      	b.n	8001c0e <myPrintf+0x2ae>
    if (left_align == false) {
 8001c3c:	b928      	cbnz	r0, 8001c4a <myPrintf+0x2ea>
    while (--i >= 0) {
 8001c3e:	f1ba 0f00 	cmp.w	sl, #0
 8001c42:	f6ff ae9f 	blt.w	8001984 <myPrintf+0x24>
      width = -width;
 8001c46:	4683      	mov	fp, r0
 8001c48:	e7d5      	b.n	8001bf6 <myPrintf+0x296>
    while (--i >= 0) {
 8001c4a:	f1ba 0f00 	cmp.w	sl, #0
 8001c4e:	f6ff ae99 	blt.w	8001984 <myPrintf+0x24>
      width = 0;
 8001c52:	f04f 0b00 	mov.w	fp, #0
 8001c56:	e7ce      	b.n	8001bf6 <myPrintf+0x296>
      c = *fmt++;
 8001c58:	462c      	mov	r4, r5
      c = 10;
 8001c5a:	f04f 090a 	mov.w	r9, #10
 8001c5e:	e774      	b.n	8001b4a <myPrintf+0x1ea>
 8001c60:	20000808 	.word	0x20000808
      if (*s == '-' && filler == '0') {
 8001c64:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 8001c68:	d1b8      	bne.n	8001bdc <myPrintf+0x27c>
        streamPut(chp, (uint8_t)*s++);
 8001c6a:	6833      	ldr	r3, [r6, #0]
 8001c6c:	483d      	ldr	r0, [pc, #244]	; (8001d64 <myPrintf+0x404>)
 8001c6e:	68db      	ldr	r3, [r3, #12]
 8001c70:	4798      	blx	r3
 8001c72:	3701      	adds	r7, #1
 8001c74:	f109 0901 	add.w	r9, r9, #1
 8001c78:	f10a 3aff 	add.w	sl, sl, #4294967295
 8001c7c:	e7ae      	b.n	8001bdc <myPrintf+0x27c>
    switch (c) {
 8001c7e:	2b44      	cmp	r3, #68	; 0x44
 8001c80:	d002      	beq.n	8001c88 <myPrintf+0x328>
 8001c82:	2b49      	cmp	r3, #73	; 0x49
 8001c84:	f47f af1e 	bne.w	8001ac4 <myPrintf+0x164>
 8001c88:	4673      	mov	r3, lr
      if (is_long) {
 8001c8a:	2d19      	cmp	r5, #25
 8001c8c:	f853 ab04 	ldr.w	sl, [r3], #4
 8001c90:	9301      	str	r3, [sp, #4]
 8001c92:	d936      	bls.n	8001d02 <myPrintf+0x3a2>
      if (l < 0) {
 8001c94:	f1ba 0f00 	cmp.w	sl, #0
 8001c98:	db41      	blt.n	8001d1e <myPrintf+0x3be>
        if (do_sign) {
 8001c9a:	f1bc 0f00 	cmp.w	ip, #0
 8001c9e:	d049      	beq.n	8001d34 <myPrintf+0x3d4>
          *p++ = '+';
 8001ca0:	232b      	movs	r3, #43	; 0x2b
 8001ca2:	f88d 300c 	strb.w	r3, [sp, #12]
 8001ca6:	f10d 050d 	add.w	r5, sp, #13
 8001caa:	f10d 090c 	add.w	r9, sp, #12
  q = p + MAX_FILLER;
 8001cae:	f105 0c0b 	add.w	ip, r5, #11
 8001cb2:	4696      	mov	lr, r2
 8001cb4:	4661      	mov	r1, ip
 8001cb6:	4652      	mov	r2, sl
    i = (int)(l % radix);
 8001cb8:	4b2b      	ldr	r3, [pc, #172]	; (8001d68 <myPrintf+0x408>)
 8001cba:	fba3 a302 	umull	sl, r3, r3, r2
 8001cbe:	08db      	lsrs	r3, r3, #3
 8001cc0:	eb03 0b83 	add.w	fp, r3, r3, lsl #2
 8001cc4:	469a      	mov	sl, r3
 8001cc6:	eba2 034b 	sub.w	r3, r2, fp, lsl #1
    i += '0';
 8001cca:	3330      	adds	r3, #48	; 0x30
  } while ((ll /= radix) != 0);
 8001ccc:	4652      	mov	r2, sl
    *--q = i;
 8001cce:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while ((ll /= radix) != 0);
 8001cd2:	2a00      	cmp	r2, #0
 8001cd4:	d1f0      	bne.n	8001cb8 <myPrintf+0x358>
  i = (int)(p + MAX_FILLER - q);
 8001cd6:	ebac 0a01 	sub.w	sl, ip, r1
 8001cda:	4672      	mov	r2, lr
 8001cdc:	1e6b      	subs	r3, r5, #1
 8001cde:	eb01 0e0a 	add.w	lr, r1, sl
    *p++ = *q++;
 8001ce2:	f811 cb01 	ldrb.w	ip, [r1], #1
 8001ce6:	f803 cf01 	strb.w	ip, [r3, #1]!
  while (--i);
 8001cea:	4571      	cmp	r1, lr
 8001cec:	d1f9      	bne.n	8001ce2 <myPrintf+0x382>
 8001cee:	4455      	add	r5, sl
 8001cf0:	e766      	b.n	8001bc0 <myPrintf+0x260>
    switch (c) {
 8001cf2:	2b44      	cmp	r3, #68	; 0x44
 8001cf4:	d002      	beq.n	8001cfc <myPrintf+0x39c>
 8001cf6:	2b49      	cmp	r3, #73	; 0x49
 8001cf8:	f47f af1d 	bne.w	8001b36 <myPrintf+0x1d6>
      c = *fmt++;
 8001cfc:	462c      	mov	r4, r5
 8001cfe:	f10e 0304 	add.w	r3, lr, #4
        l = va_arg(ap, long);
 8001d02:	f8de a000 	ldr.w	sl, [lr]
 8001d06:	9301      	str	r3, [sp, #4]
 8001d08:	e7c4      	b.n	8001c94 <myPrintf+0x334>
      for (p = s; *p && (--precision >= 0); p++)
 8001d0a:	b33b      	cbz	r3, 8001d5c <myPrintf+0x3fc>
 8001d0c:	3901      	subs	r1, #1
 8001d0e:	46a9      	mov	r9, r5
 8001d10:	f57f ae8d 	bpl.w	8001a2e <myPrintf+0xce>
 8001d14:	e694      	b.n	8001a40 <myPrintf+0xe0>
        if (c >= '0' && c <= '9') {
 8001d16:	f8dd e004 	ldr.w	lr, [sp, #4]
      width = 0;
 8001d1a:	2200      	movs	r2, #0
 8001d1c:	e657      	b.n	80019ce <myPrintf+0x6e>
        *p++ = '-';
 8001d1e:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8001d22:	f88d 300c 	strb.w	r3, [sp, #12]
        l = -l;
 8001d26:	f1ca 0a00 	rsb	sl, sl, #0
        *p++ = '-';
 8001d2a:	f10d 050d 	add.w	r5, sp, #13
 8001d2e:	f10d 090c 	add.w	r9, sp, #12
 8001d32:	e7bc      	b.n	8001cae <myPrintf+0x34e>
    p = tmpbuf;
 8001d34:	f10d 090c 	add.w	r9, sp, #12
 8001d38:	464d      	mov	r5, r9
 8001d3a:	e7b8      	b.n	8001cae <myPrintf+0x34e>
      if (precision == 0) {
 8001d3c:	b961      	cbnz	r1, 8001d58 <myPrintf+0x3f8>
 8001d3e:	f8df 902c 	ldr.w	r9, [pc, #44]	; 8001d6c <myPrintf+0x40c>
      for (p = s; *p && (--precision >= 0); p++)
 8001d42:	f647 71fe 	movw	r1, #32766	; 0x7ffe
 8001d46:	e672      	b.n	8001a2e <myPrintf+0xce>
    switch (c) {
 8001d48:	2b64      	cmp	r3, #100	; 0x64
 8001d4a:	f47f aebb 	bne.w	8001ac4 <myPrintf+0x164>
 8001d4e:	e79b      	b.n	8001c88 <myPrintf+0x328>
 8001d50:	2b64      	cmp	r3, #100	; 0x64
 8001d52:	d0d3      	beq.n	8001cfc <myPrintf+0x39c>
      c = *fmt++;
 8001d54:	462c      	mov	r4, r5
 8001d56:	e6b5      	b.n	8001ac4 <myPrintf+0x164>
      if (precision == 0) {
 8001d58:	4d04      	ldr	r5, [pc, #16]	; (8001d6c <myPrintf+0x40c>)
 8001d5a:	e7d7      	b.n	8001d0c <myPrintf+0x3ac>
      for (p = s; *p && (--precision >= 0); p++)
 8001d5c:	46a9      	mov	r9, r5
      filler = ' ';
 8001d5e:	f04f 0820 	mov.w	r8, #32
 8001d62:	e72d      	b.n	8001bc0 <myPrintf+0x260>
 8001d64:	20000808 	.word	0x20000808
 8001d68:	cccccccd 	.word	0xcccccccd
 8001d6c:	08004484 	.word	0x08004484

08001d70 <sdcConnect>:
bool sdcConnect(SDCDriver *sdcp) {
 8001d70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001d74:	b084      	sub	sp, #16
  sdcp->sdio->CLKCR  = STM32_SDIO_DIV_LS;
 8001d76:	6c83      	ldr	r3, [r0, #72]	; 0x48
  sdcp->state = BLK_CONNECTING;
 8001d78:	2203      	movs	r2, #3
 8001d7a:	7102      	strb	r2, [r0, #4]
 8001d7c:	2278      	movs	r2, #120	; 0x78
 8001d7e:	605a      	str	r2, [r3, #4]
  sdcp->sdio->POWER |= SDIO_POWER_PWRCTRL_0 | SDIO_POWER_PWRCTRL_1;
 8001d80:	681a      	ldr	r2, [r3, #0]
 8001d82:	f042 0203 	orr.w	r2, r2, #3
 8001d86:	601a      	str	r2, [r3, #0]
  sdcp->sdio->CLKCR |= SDIO_CLKCR_CLKEN;
 8001d88:	685a      	ldr	r2, [r3, #4]
bool sdcConnect(SDCDriver *sdcp) {
 8001d8a:	4604      	mov	r4, r0
 8001d8c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001d90:	605a      	str	r2, [r3, #4]
 8001d92:	af02      	add	r7, sp, #8
 8001d94:	2064      	movs	r0, #100	; 0x64
 8001d96:	f7ff f803 	bl	8000da0 <chThdSleep>
  sdcp->sdio->ARG = arg;
 8001d9a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001d9c:	2100      	movs	r1, #0
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8001d9e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  sdcp->sdio->ARG = arg;
 8001da2:	6091      	str	r1, [r2, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8001da4:	60d3      	str	r3, [r2, #12]
  while ((sdcp->sdio->STA & SDIO_STA_CMDSENT) == 0)
 8001da6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001da8:	0618      	lsls	r0, r3, #24
 8001daa:	d5fc      	bpl.n	8001da6 <sdcConnect+0x36>
  sdcp->sdio->ICR = SDIO_ICR_CMDSENTC;
 8001dac:	2380      	movs	r3, #128	; 0x80
 8001dae:	6393      	str	r3, [r2, #56]	; 0x38
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 8001db0:	2108      	movs	r1, #8
 8001db2:	1d3b      	adds	r3, r7, #4
 8001db4:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 8001db8:	4620      	mov	r0, r4
 8001dba:	f7fe fd89 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001dbe:	b998      	cbnz	r0, 8001de8 <sdcConnect+0x78>
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8001dc0:	687b      	ldr	r3, [r7, #4]
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 8001dc2:	2201      	movs	r2, #1
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8001dc4:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8001dc8:	4293      	cmp	r3, r2
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 8001dca:	6322      	str	r2, [r4, #48]	; 0x30
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8001dcc:	f000 80be 	beq.w	8001f4c <sdcConnect+0x1dc>
 8001dd0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  sdcp->sdio->CLKCR = 0;
 8001dd2:	2200      	movs	r2, #0
  sdcp->state = BLK_ACTIVE;
 8001dd4:	2102      	movs	r1, #2
 8001dd6:	605a      	str	r2, [r3, #4]
  return HAL_FAILED;
 8001dd8:	2501      	movs	r5, #1
  sdcp->sdio->POWER = 0;
 8001dda:	601a      	str	r2, [r3, #0]
  sdcp->state = BLK_ACTIVE;
 8001ddc:	7121      	strb	r1, [r4, #4]
}
 8001dde:	4628      	mov	r0, r5
 8001de0:	3708      	adds	r7, #8
 8001de2:	46bd      	mov	sp, r7
 8001de4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001de8:	1d3b      	adds	r3, r7, #4
 8001dea:	2200      	movs	r2, #0
 8001dec:	2137      	movs	r1, #55	; 0x37
 8001dee:	4620      	mov	r0, r4
 8001df0:	f7fe fd6e 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001df4:	bb08      	cbnz	r0, 8001e3a <sdcConnect+0xca>
        MMCSD_R1_ERROR(resp[0])) {
 8001df6:	6879      	ldr	r1, [r7, #4]
 8001df8:	4ab9      	ldr	r2, [pc, #740]	; (80020e0 <sdcConnect+0x370>)
 8001dfa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001dfc:	400a      	ands	r2, r1
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001dfe:	2a00      	cmp	r2, #0
 8001e00:	f000 80e8 	beq.w	8001fd4 <sdcConnect+0x264>
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 8001e04:	2202      	movs	r2, #2
 8001e06:	6322      	str	r2, [r4, #48]	; 0x30
  sdcp->sdio->ARG = arg;
 8001e08:	f8df 82f4 	ldr.w	r8, [pc, #756]	; 8002100 <sdcConnect+0x390>
bool sdcConnect(SDCDriver *sdcp) {
 8001e0c:	2564      	movs	r5, #100	; 0x64
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8001e0e:	f240 4641 	movw	r6, #1089	; 0x441
  sdcp->sdio->ARG = arg;
 8001e12:	f8c3 8008 	str.w	r8, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8001e16:	60de      	str	r6, [r3, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8001e18:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001e1a:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 8001e1e:	d0fb      	beq.n	8001e18 <sdcConnect+0xa8>
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8001e20:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 8001e22:	074a      	lsls	r2, r1, #29
 8001e24:	d40b      	bmi.n	8001e3e <sdcConnect+0xce>
  *resp = sdcp->sdio->RESP1;
 8001e26:	695a      	ldr	r2, [r3, #20]
    if ((resp[0] & 0x80000000U) != 0U) {
 8001e28:	2a00      	cmp	r2, #0
 8001e2a:	db0e      	blt.n	8001e4a <sdcConnect+0xda>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8001e2c:	3d01      	subs	r5, #1
 8001e2e:	d0d0      	beq.n	8001dd2 <sdcConnect+0x62>
 8001e30:	2064      	movs	r0, #100	; 0x64
 8001e32:	f7fe ffb5 	bl	8000da0 <chThdSleep>
 8001e36:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001e38:	e7eb      	b.n	8001e12 <sdcConnect+0xa2>
 8001e3a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001e3c:	e7e2      	b.n	8001e04 <sdcConnect+0x94>
    sdc_lld_collect_errors(sdcp, sta);
 8001e3e:	f104 0034 	add.w	r0, r4, #52	; 0x34
 8001e42:	f7fe fd05 	bl	8000850 <sdc_lld_collect_errors.isra.0>
 8001e46:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001e48:	e7c3      	b.n	8001dd2 <sdcConnect+0x62>
      if ((resp[0] & 0x40000000U) != 0U) {
 8001e4a:	0052      	lsls	r2, r2, #1
 8001e4c:	d503      	bpl.n	8001e56 <sdcConnect+0xe6>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8001e4e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001e50:	f043 0310 	orr.w	r3, r3, #16
 8001e54:	6323      	str	r3, [r4, #48]	; 0x30
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 8001e56:	f104 0308 	add.w	r3, r4, #8
 8001e5a:	2200      	movs	r2, #0
 8001e5c:	2102      	movs	r1, #2
 8001e5e:	4620      	mov	r0, r4
 8001e60:	f7fe fd16 	bl	8000890 <sdc_lld_send_cmd_long_crc>
 8001e64:	2800      	cmp	r0, #0
 8001e66:	d1b3      	bne.n	8001dd0 <sdcConnect+0x60>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 8001e68:	4602      	mov	r2, r0
 8001e6a:	f104 0338 	add.w	r3, r4, #56	; 0x38
 8001e6e:	2103      	movs	r1, #3
 8001e70:	4620      	mov	r0, r4
 8001e72:	f7fe fd2d 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001e76:	2800      	cmp	r0, #0
 8001e78:	d1aa      	bne.n	8001dd0 <sdcConnect+0x60>
                                sdcp->rca, sdcp->csd)) {
 8001e7a:	f104 0818 	add.w	r8, r4, #24
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8001e7e:	4643      	mov	r3, r8
 8001e80:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001e82:	2109      	movs	r1, #9
 8001e84:	4620      	mov	r0, r4
 8001e86:	f7fe fd03 	bl	8000890 <sdc_lld_send_cmd_long_crc>
 8001e8a:	2800      	cmp	r0, #0
 8001e8c:	d1a0      	bne.n	8001dd0 <sdcConnect+0x60>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 8001e8e:	463b      	mov	r3, r7
 8001e90:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001e92:	2107      	movs	r1, #7
 8001e94:	4620      	mov	r0, r4
 8001e96:	f7fe fd1b 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001e9a:	2800      	cmp	r0, #0
 8001e9c:	d198      	bne.n	8001dd0 <sdcConnect+0x60>
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8001e9e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001ea0:	f003 030f 	and.w	r3, r3, #15
 8001ea4:	2b02      	cmp	r3, #2
 8001ea6:	f000 80a1 	beq.w	8001fec <sdcConnect+0x27c>
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8001eaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8001eac:	466d      	mov	r5, sp
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8001eae:	0f9b      	lsrs	r3, r3, #30
  uint8_t tmp[N];
 8001eb0:	b090      	sub	sp, #64	; 0x40
 8001eb2:	ae02      	add	r6, sp, #8
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8001eb4:	f040 80fa 	bne.w	80020ac <sdcConnect+0x33c>
 8001eb8:	46ad      	mov	sp, r5
  sdcp->sdio->CLKCR = (sdcp->sdio->CLKCR & 0xFFFFFF00U) | STM32_SDIO_DIV_HS;
 8001eba:	6ca1      	ldr	r1, [r4, #72]	; 0x48
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8001ebc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001ebe:	684a      	ldr	r2, [r1, #4]
 8001ec0:	f003 030f 	and.w	r3, r3, #15
 8001ec4:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8001ec8:	2b02      	cmp	r3, #2
 8001eca:	604a      	str	r2, [r1, #4]
 8001ecc:	f000 80be 	beq.w	800204c <sdcConnect+0x2dc>
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8001ed0:	4640      	mov	r0, r8
 8001ed2:	f7fe fd93 	bl	80009fc <_mmcsd_get_capacity>
 8001ed6:	62a0      	str	r0, [r4, #40]	; 0x28
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 8001ed8:	463b      	mov	r3, r7
 8001eda:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001ede:	2110      	movs	r1, #16
 8001ee0:	4620      	mov	r0, r4
 8001ee2:	f7fe fcf5 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001ee6:	4605      	mov	r5, r0
 8001ee8:	2800      	cmp	r0, #0
 8001eea:	f47f af71 	bne.w	8001dd0 <sdcConnect+0x60>
      MMCSD_R1_ERROR(resp[0])) {
 8001eee:	683b      	ldr	r3, [r7, #0]
 8001ef0:	4e7b      	ldr	r6, [pc, #492]	; (80020e0 <sdcConnect+0x370>)
                                 MMCSD_BLOCK_SIZE, resp) ||
 8001ef2:	4233      	tst	r3, r6
 8001ef4:	f47f af6c 	bne.w	8001dd0 <sdcConnect+0x60>
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8001ef8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001efa:	f003 030f 	and.w	r3, r3, #15
 8001efe:	2b01      	cmp	r3, #1
 8001f00:	d97b      	bls.n	8001ffa <sdcConnect+0x28a>
 8001f02:	2b02      	cmp	r3, #2
 8001f04:	f47f af64 	bne.w	8001dd0 <sdcConnect+0x60>
  switch (sdcp->config->bus_width) {
 8001f08:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001f0a:	781b      	ldrb	r3, [r3, #0]
 8001f0c:	2b01      	cmp	r3, #1
 8001f0e:	f000 80be 	beq.w	800208e <sdcConnect+0x31e>
 8001f12:	d318      	bcc.n	8001f46 <sdcConnect+0x1d6>
 8001f14:	2b02      	cmp	r3, #2
 8001f16:	f040 80c3 	bne.w	80020a0 <sdcConnect+0x330>
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 8001f1a:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 8001f1c:	4a71      	ldr	r2, [pc, #452]	; (80020e4 <sdcConnect+0x374>)
 8001f1e:	684b      	ldr	r3, [r1, #4]
 8001f20:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_1;
 8001f24:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001f28:	604b      	str	r3, [r1, #4]
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8001f2a:	1d3b      	adds	r3, r7, #4
 8001f2c:	2106      	movs	r1, #6
 8001f2e:	4620      	mov	r0, r4
 8001f30:	f7fe fcce 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001f34:	2800      	cmp	r0, #0
 8001f36:	f47f af4b 	bne.w	8001dd0 <sdcConnect+0x60>
      MMCSD_R1_ERROR(resp[0])) {
 8001f3a:	687a      	ldr	r2, [r7, #4]
 8001f3c:	4b68      	ldr	r3, [pc, #416]	; (80020e0 <sdcConnect+0x370>)
 8001f3e:	4013      	ands	r3, r2
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8001f40:	2b00      	cmp	r3, #0
 8001f42:	f47f af45 	bne.w	8001dd0 <sdcConnect+0x60>
  sdcp->state = BLK_READY;
 8001f46:	2305      	movs	r3, #5
 8001f48:	7123      	strb	r3, [r4, #4]
 8001f4a:	e748      	b.n	8001dde <sdcConnect+0x6e>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001f4c:	4602      	mov	r2, r0
 8001f4e:	1d3b      	adds	r3, r7, #4
 8001f50:	2137      	movs	r1, #55	; 0x37
 8001f52:	4620      	mov	r0, r4
 8001f54:	f7fe fcbc 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001f58:	2800      	cmp	r0, #0
 8001f5a:	f47f af39 	bne.w	8001dd0 <sdcConnect+0x60>
        MMCSD_R1_ERROR(resp[0])) {
 8001f5e:	687a      	ldr	r2, [r7, #4]
 8001f60:	4b5f      	ldr	r3, [pc, #380]	; (80020e0 <sdcConnect+0x370>)
 8001f62:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001f64:	2b00      	cmp	r3, #0
 8001f66:	f47f af33 	bne.w	8001dd0 <sdcConnect+0x60>
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 8001f6a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001f6c:	f003 030f 	and.w	r3, r3, #15
 8001f70:	2b02      	cmp	r3, #2
 8001f72:	f000 8099 	beq.w	80020a8 <sdcConnect+0x338>
    ocr = SDC_INIT_OCR_V20;
 8001f76:	4e5c      	ldr	r6, [pc, #368]	; (80020e8 <sdcConnect+0x378>)
 8001f78:	4a5c      	ldr	r2, [pc, #368]	; (80020ec <sdcConnect+0x37c>)
 8001f7a:	2b01      	cmp	r3, #1
 8001f7c:	bf08      	it	eq
 8001f7e:	4616      	moveq	r6, r2
        MMCSD_R1_ERROR(resp[0])) {
 8001f80:	f8df 815c 	ldr.w	r8, [pc, #348]	; 80020e0 <sdcConnect+0x370>
    ocr = SDC_INIT_OCR;
 8001f84:	2564      	movs	r5, #100	; 0x64
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001f86:	1d3b      	adds	r3, r7, #4
 8001f88:	2200      	movs	r2, #0
 8001f8a:	2137      	movs	r1, #55	; 0x37
 8001f8c:	4620      	mov	r0, r4
 8001f8e:	f7fe fc9f 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001f92:	2800      	cmp	r0, #0
 8001f94:	f47f af1c 	bne.w	8001dd0 <sdcConnect+0x60>
        MMCSD_R1_ERROR(resp[0])) {
 8001f98:	687a      	ldr	r2, [r7, #4]
 8001f9a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 8001f9c:	ea12 0f08 	tst.w	r2, r8
 8001fa0:	f47f af17 	bne.w	8001dd2 <sdcConnect+0x62>
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8001fa4:	f240 4269 	movw	r2, #1129	; 0x469
  sdcp->sdio->ARG = arg;
 8001fa8:	609e      	str	r6, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_WAITRESP_0 | SDIO_CMD_CPSMEN;
 8001faa:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdio->STA) & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8001fac:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001fae:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 8001fb2:	d0fb      	beq.n	8001fac <sdcConnect+0x23c>
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 8001fb4:	0748      	lsls	r0, r1, #29
  sdcp->sdio->ICR = sta & (SDIO_STA_CMDREND | SDIO_STA_CTIMEOUT |
 8001fb6:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDIO_STA_CTIMEOUT)) != 0) {
 8001fb8:	f53f af41 	bmi.w	8001e3e <sdcConnect+0xce>
  *resp = sdcp->sdio->RESP1;
 8001fbc:	695a      	ldr	r2, [r3, #20]
 8001fbe:	607a      	str	r2, [r7, #4]
    if ((resp[0] & 0x80000000U) != 0U) {
 8001fc0:	2a00      	cmp	r2, #0
 8001fc2:	f6ff af42 	blt.w	8001e4a <sdcConnect+0xda>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8001fc6:	3d01      	subs	r5, #1
 8001fc8:	f43f af03 	beq.w	8001dd2 <sdcConnect+0x62>
 8001fcc:	2064      	movs	r0, #100	; 0x64
 8001fce:	f7fe fee7 	bl	8000da0 <chThdSleep>
 8001fd2:	e7d8      	b.n	8001f86 <sdcConnect+0x216>
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8001fd4:	f44f 6180 	mov.w	r1, #1024	; 0x400
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 8001fd8:	6322      	str	r2, [r4, #48]	; 0x30
  sdcp->sdio->ARG = arg;
 8001fda:	609a      	str	r2, [r3, #8]
  sdcp->sdio->CMD = (uint32_t)cmd | SDIO_CMD_CPSMEN;
 8001fdc:	60d9      	str	r1, [r3, #12]
  while ((sdcp->sdio->STA & SDIO_STA_CMDSENT) == 0)
 8001fde:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001fe0:	0611      	lsls	r1, r2, #24
 8001fe2:	d5fc      	bpl.n	8001fde <sdcConnect+0x26e>
  sdcp->sdio->ICR = SDIO_ICR_CMDSENTC;
 8001fe4:	2280      	movs	r2, #128	; 0x80
 8001fe6:	639a      	str	r2, [r3, #56]	; 0x38
    ocr = SDC_INIT_OCR;
 8001fe8:	4e3f      	ldr	r6, [pc, #252]	; (80020e8 <sdcConnect+0x378>)
 8001fea:	e7c9      	b.n	8001f80 <sdcConnect+0x210>
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 8001fec:	1d3b      	adds	r3, r7, #4
 8001fee:	4a40      	ldr	r2, [pc, #256]	; (80020f0 <sdcConnect+0x380>)
 8001ff0:	2106      	movs	r1, #6
 8001ff2:	4620      	mov	r0, r4
 8001ff4:	f7fe fc6c 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8001ff8:	e75f      	b.n	8001eba <sdcConnect+0x14a>
  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 8001ffa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001ffc:	781a      	ldrb	r2, [r3, #0]
 8001ffe:	2a00      	cmp	r2, #0
 8002000:	d0a1      	beq.n	8001f46 <sdcConnect+0x1d6>
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8002002:	2a01      	cmp	r2, #1
 8002004:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8002006:	f47f aee4 	bne.w	8001dd2 <sdcConnect+0x62>
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 800200a:	6859      	ldr	r1, [r3, #4]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 800200c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800200e:	f421 51c0 	bic.w	r1, r1, #6144	; 0x1800
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_0;
 8002012:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
 8002016:	6059      	str	r1, [r3, #4]
 8002018:	4620      	mov	r0, r4
 800201a:	1d3b      	adds	r3, r7, #4
 800201c:	2137      	movs	r1, #55	; 0x37
 800201e:	f7fe fc57 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 8002022:	2800      	cmp	r0, #0
 8002024:	f47f aed4 	bne.w	8001dd0 <sdcConnect+0x60>
        MMCSD_R1_ERROR(resp[0])) {
 8002028:	687b      	ldr	r3, [r7, #4]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 800202a:	4233      	tst	r3, r6
 800202c:	f47f aed0 	bne.w	8001dd0 <sdcConnect+0x60>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8002030:	1d3b      	adds	r3, r7, #4
 8002032:	2202      	movs	r2, #2
 8002034:	2106      	movs	r1, #6
 8002036:	4620      	mov	r0, r4
 8002038:	f7fe fc4a 	bl	80008d0 <sdc_lld_send_cmd_short_crc>
 800203c:	2800      	cmp	r0, #0
 800203e:	f47f aec7 	bne.w	8001dd0 <sdcConnect+0x60>
        MMCSD_R1_ERROR(resp[0])) {
 8002042:	687b      	ldr	r3, [r7, #4]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8002044:	4233      	tst	r3, r6
 8002046:	f43f af7e 	beq.w	8001f46 <sdcConnect+0x1d6>
 800204a:	e6c1      	b.n	8001dd0 <sdcConnect+0x60>
 800204c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 800204e:	2b00      	cmp	r3, #0
 8002050:	f6bf af3e 	bge.w	8001ed0 <sdcConnect+0x160>
      if (sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 8002054:	2300      	movs	r3, #0
 8002056:	9300      	str	r3, [sp, #0]
 8002058:	f44f 7200 	mov.w	r2, #512	; 0x200
 800205c:	2308      	movs	r3, #8
 800205e:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 8002062:	4620      	mov	r0, r4
 8002064:	f7ff fc34 	bl	80018d0 <sdc_lld_read_special>
 8002068:	2800      	cmp	r0, #0
 800206a:	f47f aeb1 	bne.w	8001dd0 <sdcConnect+0x60>
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 800206e:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
  return ((uint32_t)ext_csd[215] << 24U) +
 8002072:	f894 0123 	ldrb.w	r0, [r4, #291]	; 0x123
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 8002076:	f894 1120 	ldrb.w	r1, [r4, #288]	; 0x120
         ((uint32_t)ext_csd[213] << 8U)  +
 800207a:	f894 2121 	ldrb.w	r2, [r4, #289]	; 0x121
         ((uint32_t)ext_csd[214] << 16U) +
 800207e:	041b      	lsls	r3, r3, #16
  return ((uint32_t)ext_csd[215] << 24U) +
 8002080:	eb03 6300 	add.w	r3, r3, r0, lsl #24
         ((uint32_t)ext_csd[213] << 8U)  +
 8002084:	440b      	add	r3, r1
 8002086:	eb03 2302 	add.w	r3, r3, r2, lsl #8
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 800208a:	62a3      	str	r3, [r4, #40]	; 0x28
 800208c:	e724      	b.n	8001ed8 <sdcConnect+0x168>
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 800208e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 8002090:	4a18      	ldr	r2, [pc, #96]	; (80020f4 <sdcConnect+0x384>)
 8002092:	684b      	ldr	r3, [r1, #4]
 8002094:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
    sdcp->sdio->CLKCR = clk | SDIO_CLKCR_WIDBUS_0;
 8002098:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800209c:	604b      	str	r3, [r1, #4]
 800209e:	e744      	b.n	8001f2a <sdcConnect+0x1ba>
  uint32_t clk = sdcp->sdio->CLKCR & ~SDIO_CLKCR_WIDBUS;
 80020a0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 80020a2:	4a15      	ldr	r2, [pc, #84]	; (80020f8 <sdcConnect+0x388>)
 80020a4:	685b      	ldr	r3, [r3, #4]
 80020a6:	e740      	b.n	8001f2a <sdcConnect+0x1ba>
 80020a8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80020aa:	e6ad      	b.n	8001e08 <sdcConnect+0x98>
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 80020ac:	9000      	str	r0, [sp, #0]
 80020ae:	2306      	movs	r3, #6
 80020b0:	2240      	movs	r2, #64	; 0x40
 80020b2:	4631      	mov	r1, r6
 80020b4:	4620      	mov	r0, r4
 80020b6:	f7ff fc0b 	bl	80018d0 <sdc_lld_read_special>
 80020ba:	b970      	cbnz	r0, 80020da <sdcConnect+0x36a>
  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 80020bc:	7b73      	ldrb	r3, [r6, #13]
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 80020be:	079b      	lsls	r3, r3, #30
 80020c0:	f57f aefa 	bpl.w	8001eb8 <sdcConnect+0x148>
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 80020c4:	4b0d      	ldr	r3, [pc, #52]	; (80020fc <sdcConnect+0x38c>)
 80020c6:	9300      	str	r3, [sp, #0]
 80020c8:	2240      	movs	r2, #64	; 0x40
 80020ca:	2306      	movs	r3, #6
 80020cc:	4631      	mov	r1, r6
 80020ce:	4620      	mov	r0, r4
 80020d0:	f7ff fbfe 	bl	80018d0 <sdc_lld_read_special>
 80020d4:	2800      	cmp	r0, #0
 80020d6:	f43f aeef 	beq.w	8001eb8 <sdcConnect+0x148>
 80020da:	46ad      	mov	sp, r5
 80020dc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80020de:	e678      	b.n	8001dd2 <sdcConnect+0x62>
 80020e0:	fdffe008 	.word	0xfdffe008
 80020e4:	03b70200 	.word	0x03b70200
 80020e8:	80100000 	.word	0x80100000
 80020ec:	50ff8000 	.word	0x50ff8000
 80020f0:	03b90100 	.word	0x03b90100
 80020f4:	03b70100 	.word	0x03b70100
 80020f8:	03b70000 	.word	0x03b70000
 80020fc:	80fffff1 	.word	0x80fffff1
 8002100:	c0ff8000 	.word	0xc0ff8000
	...

08002110 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8002110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002114:	b085      	sub	sp, #20
 8002116:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = oqp->q_notify;
 800211a:	f8d0 901c 	ldr.w	r9, [r0, #28]
 800211e:	f04f 0a20 	mov.w	sl, #32
 8002122:	f38a 8811 	msr	BASEPRI, sl

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8002126:	b33a      	cbz	r2, 8002178 <oqWriteTimeout+0x68>
 8002128:	4604      	mov	r4, r0
 800212a:	460f      	mov	r7, r1
 800212c:	4616      	mov	r6, r2
 800212e:	f04f 0b00 	mov.w	fp, #0
  if (n > oqGetEmptyI(oqp)) {
 8002132:	68a2      	ldr	r2, [r4, #8]
 8002134:	4296      	cmp	r6, r2
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8002136:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
    n = oqGetEmptyI(oqp);
 800213a:	bf8c      	ite	hi
 800213c:	68a5      	ldrhi	r5, [r4, #8]
  if (n > oqGetEmptyI(oqp)) {
 800213e:	4635      	movls	r5, r6
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8002140:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
 8002144:	45a8      	cmp	r8, r5
 8002146:	d840      	bhi.n	80021ca <oqWriteTimeout+0xba>
  else if (n > s1) {
 8002148:	d32b      	bcc.n	80021a2 <oqWriteTimeout+0x92>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 800214a:	462a      	mov	r2, r5
 800214c:	4639      	mov	r1, r7
 800214e:	f7fe f8cd 	bl	80002ec <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8002152:	68e2      	ldr	r2, [r4, #12]
 8002154:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
 8002156:	68a2      	ldr	r2, [r4, #8]
 8002158:	1b52      	subs	r2, r2, r5
 800215a:	60a2      	str	r2, [r4, #8]
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 800215c:	b19d      	cbz	r5, 8002186 <oqWriteTimeout+0x76>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 800215e:	f1b9 0f00 	cmp.w	r9, #0
 8002162:	d001      	beq.n	8002168 <oqWriteTimeout+0x58>
        nfy(oqp);
 8002164:	4620      	mov	r0, r4
 8002166:	47c8      	blx	r9
 8002168:	f38b 8811 	msr	BASEPRI, fp
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 800216c:	1b76      	subs	r6, r6, r5
      bp += done;
 800216e:	442f      	add	r7, r5
 8002170:	f38a 8811 	msr	BASEPRI, sl
  while (n > 0U) {
 8002174:	2e00      	cmp	r6, #0
 8002176:	d1dc      	bne.n	8002132 <oqWriteTimeout+0x22>
  if (n > oqGetEmptyI(oqp)) {
 8002178:	9803      	ldr	r0, [sp, #12]
 800217a:	2300      	movs	r3, #0
 800217c:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8002180:	b005      	add	sp, #20
 8002182:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return chThdEnqueueTimeoutS(tqp, timeout);
 8002186:	9902      	ldr	r1, [sp, #8]
 8002188:	4620      	mov	r0, r4
 800218a:	f7fe fd79 	bl	8000c80 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800218e:	2800      	cmp	r0, #0
 8002190:	d0cf      	beq.n	8002132 <oqWriteTimeout+0x22>
 8002192:	9b03      	ldr	r3, [sp, #12]
 8002194:	1b98      	subs	r0, r3, r6
 8002196:	2300      	movs	r3, #0
 8002198:	f383 8811 	msr	BASEPRI, r3
}
 800219c:	b005      	add	sp, #20
 800219e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    s2 = n - s1;
 80021a2:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80021a6:	4642      	mov	r2, r8
 80021a8:	4639      	mov	r1, r7
    s2 = n - s1;
 80021aa:	9301      	str	r3, [sp, #4]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80021ac:	f7fe f89e 	bl	80002ec <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 80021b0:	eb07 0108 	add.w	r1, r7, r8
 80021b4:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80021b8:	68e0      	ldr	r0, [r4, #12]
 80021ba:	4642      	mov	r2, r8
 80021bc:	f7fe f896 	bl	80002ec <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 80021c0:	68e2      	ldr	r2, [r4, #12]
 80021c2:	4643      	mov	r3, r8
 80021c4:	18d3      	adds	r3, r2, r3
 80021c6:	6163      	str	r3, [r4, #20]
 80021c8:	e7c5      	b.n	8002156 <oqWriteTimeout+0x46>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80021ca:	462a      	mov	r2, r5
 80021cc:	4639      	mov	r1, r7
 80021ce:	f7fe f88d 	bl	80002ec <memcpy>
    oqp->q_wrptr += n;
 80021d2:	6962      	ldr	r2, [r4, #20]
 80021d4:	442a      	add	r2, r5
 80021d6:	6162      	str	r2, [r4, #20]
 80021d8:	e7bd      	b.n	8002156 <oqWriteTimeout+0x46>
 80021da:	bf00      	nop
 80021dc:	0000      	movs	r0, r0
	...

080021e0 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80021e0:	3030      	adds	r0, #48	; 0x30
 80021e2:	f7ff bf95 	b.w	8002110 <oqWriteTimeout>
 80021e6:	bf00      	nop
	...

080021f0 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80021f0:	3030      	adds	r0, #48	; 0x30
 80021f2:	f04f 33ff 	mov.w	r3, #4294967295
 80021f6:	f7ff bf8b 	b.w	8002110 <oqWriteTimeout>
 80021fa:	bf00      	nop
 80021fc:	0000      	movs	r0, r0
	...

08002200 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8002200:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002204:	b085      	sub	sp, #20
 8002206:	e9cd 3202 	strd	r3, r2, [sp, #8]
  qnotify_t nfy = iqp->q_notify;
 800220a:	f8d0 901c 	ldr.w	r9, [r0, #28]
 800220e:	f04f 0a20 	mov.w	sl, #32
 8002212:	f38a 8811 	msr	BASEPRI, sl
  while (n > 0U) {
 8002216:	b33a      	cbz	r2, 8002268 <iqReadTimeout+0x68>
 8002218:	4604      	mov	r4, r0
 800221a:	460f      	mov	r7, r1
 800221c:	4616      	mov	r6, r2
 800221e:	f04f 0b00 	mov.w	fp, #0
  if (n > iqGetFullI(iqp)) {
 8002222:	68a2      	ldr	r2, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8002224:	69a1      	ldr	r1, [r4, #24]
  if (n > iqGetFullI(iqp)) {
 8002226:	4296      	cmp	r6, r2
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8002228:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
 800222a:	bf8c      	ite	hi
 800222c:	68a5      	ldrhi	r5, [r4, #8]
  if (n > iqGetFullI(iqp)) {
 800222e:	4635      	movls	r5, r6
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8002230:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 8002234:	45a8      	cmp	r8, r5
 8002236:	d840      	bhi.n	80022ba <iqReadTimeout+0xba>
  else if (n > s1) {
 8002238:	d32b      	bcc.n	8002292 <iqReadTimeout+0x92>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800223a:	462a      	mov	r2, r5
 800223c:	4638      	mov	r0, r7
 800223e:	f7fe f855 	bl	80002ec <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8002242:	68e2      	ldr	r2, [r4, #12]
 8002244:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
 8002246:	68a2      	ldr	r2, [r4, #8]
 8002248:	1b52      	subs	r2, r2, r5
 800224a:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 800224c:	b19d      	cbz	r5, 8002276 <iqReadTimeout+0x76>
      if (nfy != NULL) {
 800224e:	f1b9 0f00 	cmp.w	r9, #0
 8002252:	d001      	beq.n	8002258 <iqReadTimeout+0x58>
        nfy(iqp);
 8002254:	4620      	mov	r0, r4
 8002256:	47c8      	blx	r9
 8002258:	f38b 8811 	msr	BASEPRI, fp
      n  -= done;
 800225c:	1b76      	subs	r6, r6, r5
      bp += done;
 800225e:	442f      	add	r7, r5
 8002260:	f38a 8811 	msr	BASEPRI, sl
  while (n > 0U) {
 8002264:	2e00      	cmp	r6, #0
 8002266:	d1dc      	bne.n	8002222 <iqReadTimeout+0x22>
  if (n > iqGetFullI(iqp)) {
 8002268:	9803      	ldr	r0, [sp, #12]
 800226a:	2300      	movs	r3, #0
 800226c:	f383 8811 	msr	BASEPRI, r3
}
 8002270:	b005      	add	sp, #20
 8002272:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002276:	9902      	ldr	r1, [sp, #8]
 8002278:	4620      	mov	r0, r4
 800227a:	f7fe fd01 	bl	8000c80 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800227e:	2800      	cmp	r0, #0
 8002280:	d0cf      	beq.n	8002222 <iqReadTimeout+0x22>
 8002282:	9b03      	ldr	r3, [sp, #12]
 8002284:	1b98      	subs	r0, r3, r6
 8002286:	2300      	movs	r3, #0
 8002288:	f383 8811 	msr	BASEPRI, r3
}
 800228c:	b005      	add	sp, #20
 800228e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    s2 = n - s1;
 8002292:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8002296:	4642      	mov	r2, r8
 8002298:	4638      	mov	r0, r7
    s2 = n - s1;
 800229a:	9301      	str	r3, [sp, #4]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 800229c:	f7fe f826 	bl	80002ec <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 80022a0:	eb07 0008 	add.w	r0, r7, r8
 80022a4:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80022a8:	68e1      	ldr	r1, [r4, #12]
 80022aa:	4642      	mov	r2, r8
 80022ac:	f7fe f81e 	bl	80002ec <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 80022b0:	68e2      	ldr	r2, [r4, #12]
 80022b2:	4643      	mov	r3, r8
 80022b4:	18d3      	adds	r3, r2, r3
 80022b6:	61a3      	str	r3, [r4, #24]
 80022b8:	e7c5      	b.n	8002246 <iqReadTimeout+0x46>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 80022ba:	462a      	mov	r2, r5
 80022bc:	4638      	mov	r0, r7
 80022be:	f7fe f815 	bl	80002ec <memcpy>
    iqp->q_rdptr += n;
 80022c2:	69a2      	ldr	r2, [r4, #24]
 80022c4:	442a      	add	r2, r5
 80022c6:	61a2      	str	r2, [r4, #24]
 80022c8:	e7bd      	b.n	8002246 <iqReadTimeout+0x46>
 80022ca:	bf00      	nop
 80022cc:	0000      	movs	r0, r0
	...

080022d0 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80022d0:	300c      	adds	r0, #12
 80022d2:	f7ff bf95 	b.w	8002200 <iqReadTimeout>
 80022d6:	bf00      	nop
	...

080022e0 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80022e0:	300c      	adds	r0, #12
 80022e2:	f04f 33ff 	mov.w	r3, #4294967295
 80022e6:	f7ff bf8b 	b.w	8002200 <iqReadTimeout>
 80022ea:	bf00      	nop
 80022ec:	0000      	movs	r0, r0
	...

080022f0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80022f0:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 80022f4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80022f6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80022fa:	2300      	movs	r3, #0
 80022fc:	f383 8811 	msr	BASEPRI, r3
}
 8002300:	4770      	bx	lr
 8002302:	bf00      	nop
	...

08002310 <chThdExit>:
void chThdExit(msg_t msg) {
 8002310:	b538      	push	{r3, r4, r5, lr}
 8002312:	2220      	movs	r2, #32
 8002314:	4603      	mov	r3, r0
 8002316:	f382 8811 	msr	BASEPRI, r2
  thread_t *tp = currp;
 800231a:	4a10      	ldr	r2, [pc, #64]	; (800235c <chThdExit+0x4c>)
 800231c:	6994      	ldr	r4, [r2, #24]
  return (bool)(tlp->next != (thread_t *)tlp);
 800231e:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  tp->u.exitcode = msg;
 8002320:	6263      	str	r3, [r4, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
 8002322:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8002326:	42a8      	cmp	r0, r5
 8002328:	d006      	beq.n	8002338 <chThdExit+0x28>
  tlp->next = tp->queue.next;
 800232a:	6803      	ldr	r3, [r0, #0]
 800232c:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 800232e:	f7fe fa37 	bl	80007a0 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
 8002332:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
 8002334:	42a8      	cmp	r0, r5
 8002336:	d1f8      	bne.n	800232a <chThdExit+0x1a>
  if ((tp->refs == (trefs_t)0) &&
 8002338:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800233c:	b943      	cbnz	r3, 8002350 <chThdExit+0x40>
 800233e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8002342:	079b      	lsls	r3, r3, #30
 8002344:	d104      	bne.n	8002350 <chThdExit+0x40>
    REG_REMOVE(tp);
 8002346:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 800234a:	611a      	str	r2, [r3, #16]
 800234c:	6922      	ldr	r2, [r4, #16]
 800234e:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
 8002350:	200f      	movs	r0, #15
}
 8002352:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8002356:	f7fe bb73 	b.w	8000a40 <chSchGoSleepS>
 800235a:	bf00      	nop
 800235c:	20000d04 	.word	0x20000d04

08002360 <chSchDoReschedule>:
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 8002360:	4a0e      	ldr	r2, [pc, #56]	; (800239c <chSchDoReschedule+0x3c>)
  thread_t *tp = tqp->next;
 8002362:	6810      	ldr	r0, [r2, #0]
  tqp->next             = tp->queue.next;
 8002364:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleAhead(void) {
 8002366:	b430      	push	{r4, r5}

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002368:	2101      	movs	r1, #1
  thread_t *otp = currp;
 800236a:	6994      	ldr	r4, [r2, #24]
  tqp->next->queue.prev = (thread_t *)tqp;
 800236c:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
 800236e:	2500      	movs	r5, #0
  currp->state = CH_STATE_CURRENT;
 8002370:	f880 1020 	strb.w	r1, [r0, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
 8002374:	68a1      	ldr	r1, [r4, #8]
  tqp->next             = tp->queue.next;
 8002376:	6013      	str	r3, [r2, #0]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002378:	6190      	str	r0, [r2, #24]
  tp->state = CH_STATE_READY;
 800237a:	f884 5020 	strb.w	r5, [r4, #32]
 800237e:	e000      	b.n	8002382 <chSchDoReschedule+0x22>
 8002380:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8002382:	689a      	ldr	r2, [r3, #8]
 8002384:	4291      	cmp	r1, r2
 8002386:	d3fb      	bcc.n	8002380 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
 8002388:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800238a:	4621      	mov	r1, r4
  tp->queue.prev             = cp->queue.prev;
 800238c:	e9c4 3200 	strd	r3, r2, [r4]
  tp->queue.prev->queue.next = tp;
 8002390:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002392:	605c      	str	r4, [r3, #4]
}
 8002394:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
 8002396:	f7fd bf93 	b.w	80002c0 <_port_switch>
 800239a:	bf00      	nop
 800239c:	20000d04 	.word	0x20000d04

080023a0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80023a0:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80023a2:	4d1c      	ldr	r5, [pc, #112]	; (8002414 <chMtxUnlock+0x74>)
 80023a4:	2320      	movs	r3, #32
 80023a6:	69ae      	ldr	r6, [r5, #24]
 80023a8:	f383 8811 	msr	BASEPRI, r3
  return (bool)(tqp->next != (const thread_t *)tqp);
 80023ac:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80023ae:	68c3      	ldr	r3, [r0, #12]
 80023b0:	63b3      	str	r3, [r6, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80023b2:	4284      	cmp	r4, r0
 80023b4:	d027      	beq.n	8002406 <chMtxUnlock+0x66>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80023b6:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80023b8:	b14b      	cbz	r3, 80023ce <chMtxUnlock+0x2e>
 80023ba:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80023bc:	4293      	cmp	r3, r2
 80023be:	d003      	beq.n	80023c8 <chMtxUnlock+0x28>
 80023c0:	6892      	ldr	r2, [r2, #8]
 80023c2:	4291      	cmp	r1, r2
 80023c4:	bf38      	it	cc
 80023c6:	4611      	movcc	r1, r2
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 80023c8:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 80023ca:	2b00      	cmp	r3, #0
 80023cc:	d1f5      	bne.n	80023ba <chMtxUnlock+0x1a>
  tqp->next             = tp->queue.next;
 80023ce:	6822      	ldr	r2, [r4, #0]
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80023d0:	60b1      	str	r1, [r6, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80023d2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80023d4:	6002      	str	r2, [r0, #0]
 80023d6:	4603      	mov	r3, r0
  tqp->next->queue.prev = (thread_t *)tqp;
 80023d8:	6050      	str	r0, [r2, #4]
 80023da:	e9c3 4102 	strd	r4, r1, [r3, #8]

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80023de:	4620      	mov	r0, r4
      tp->mtxlist = mp;
 80023e0:	63a3      	str	r3, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 80023e2:	f7fe f9dd 	bl	80007a0 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 80023e6:	682a      	ldr	r2, [r5, #0]
 80023e8:	69ab      	ldr	r3, [r5, #24]
  if (chSchIsRescRequiredI()) {
 80023ea:	6892      	ldr	r2, [r2, #8]
 80023ec:	689b      	ldr	r3, [r3, #8]
 80023ee:	429a      	cmp	r2, r3
 80023f0:	d803      	bhi.n	80023fa <chMtxUnlock+0x5a>
 80023f2:	2300      	movs	r3, #0
 80023f4:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 80023f8:	bd70      	pop	{r4, r5, r6, pc}
    chSchDoRescheduleAhead();
 80023fa:	f7ff ffb1 	bl	8002360 <chSchDoReschedule>
 80023fe:	2300      	movs	r3, #0
 8002400:	f383 8811 	msr	BASEPRI, r3
 8002404:	bd70      	pop	{r4, r5, r6, pc}
      mp->owner = NULL;
 8002406:	2300      	movs	r3, #0
 8002408:	60a3      	str	r3, [r4, #8]
 800240a:	2300      	movs	r3, #0
 800240c:	f383 8811 	msr	BASEPRI, r3
}
 8002410:	bd70      	pop	{r4, r5, r6, pc}
 8002412:	bf00      	nop
 8002414:	20000d04 	.word	0x20000d04
	...

08002420 <chHeapAllocAligned.constprop.11>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8002420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002422:	1dc6      	adds	r6, r0, #7
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8002424:	4604      	mov	r4, r0
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002426:	08f6      	lsrs	r6, r6, #3
 8002428:	2320      	movs	r3, #32
 800242a:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 800242e:	4831      	ldr	r0, [pc, #196]	; (80024f4 <chHeapAllocAligned.constprop.11+0xd4>)
 8002430:	f7fe fb1e 	bl	8000a70 <chMtxLockS>
 8002434:	2300      	movs	r3, #0
 8002436:	f383 8811 	msr	BASEPRI, r3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 800243a:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 80024fc <chHeapAllocAligned.constprop.11+0xdc>
  while (H_NEXT(qp) != NULL) {
 800243e:	f8dc 2000 	ldr.w	r2, [ip]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8002442:	f102 030f 	add.w	r3, r2, #15
 8002446:	f023 0307 	bic.w	r3, r3, #7

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800244a:	461f      	mov	r7, r3
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800244c:	f102 0e08 	add.w	lr, r2, #8
 8002450:	3b08      	subs	r3, #8
  while (H_NEXT(qp) != NULL) {
 8002452:	b162      	cbz	r2, 800246e <chHeapAllocAligned.constprop.11+0x4e>
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8002454:	6850      	ldr	r0, [r2, #4]
 8002456:	1c41      	adds	r1, r0, #1
 8002458:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
 800245c:	1bcd      	subs	r5, r1, r7
 800245e:	428b      	cmp	r3, r1
 8002460:	ea4f 05e5 	mov.w	r5, r5, asr #3
 8002464:	d201      	bcs.n	800246a <chHeapAllocAligned.constprop.11+0x4a>
 8002466:	42ae      	cmp	r6, r5
 8002468:	d912      	bls.n	8002490 <chHeapAllocAligned.constprop.11+0x70>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 800246a:	4694      	mov	ip, r2
 800246c:	e7e7      	b.n	800243e <chHeapAllocAligned.constprop.11+0x1e>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800246e:	4d22      	ldr	r5, [pc, #136]	; (80024f8 <chHeapAllocAligned.constprop.11+0xd8>)
 8002470:	f105 000c 	add.w	r0, r5, #12
 8002474:	f7ff ff94 	bl	80023a0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8002478:	682f      	ldr	r7, [r5, #0]
 800247a:	b13f      	cbz	r7, 800248c <chHeapAllocAligned.constprop.11+0x6c>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
 800247c:	2208      	movs	r2, #8
 800247e:	00f0      	lsls	r0, r6, #3
 8002480:	4611      	mov	r1, r2
 8002482:	47b8      	blx	r7
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 8002484:	4607      	mov	r7, r0
 8002486:	b108      	cbz	r0, 800248c <chHeapAllocAligned.constprop.11+0x6c>
      hp = ahp - 1U;
      H_HEAP(hp) = heapp;
      H_SIZE(hp) = size;
 8002488:	e940 5402 	strd	r5, r4, [r0, #-8]
      /*lint -restore*/
    }
  }

  return NULL;
}
 800248c:	4638      	mov	r0, r7
 800248e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (ahp > hp) {
 8002490:	429a      	cmp	r2, r3
 8002492:	d318      	bcc.n	80024c6 <chHeapAllocAligned.constprop.11+0xa6>
        if (H_PAGES(hp) == pages) {
 8002494:	4286      	cmp	r6, r0
 8002496:	6813      	ldr	r3, [r2, #0]
 8002498:	d027      	beq.n	80024ea <chHeapAllocAligned.constprop.11+0xca>
          fp = H_BLOCK(hp) + pages;
 800249a:	3601      	adds	r6, #1
 800249c:	eb02 00c6 	add.w	r0, r2, r6, lsl #3
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80024a0:	f100 0508 	add.w	r5, r0, #8
 80024a4:	1b49      	subs	r1, r1, r5
 80024a6:	10c9      	asrs	r1, r1, #3
          H_NEXT(fp) = H_NEXT(hp);
 80024a8:	f842 3036 	str.w	r3, [r2, r6, lsl #3]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80024ac:	4677      	mov	r7, lr
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80024ae:	6041      	str	r1, [r0, #4]
          H_NEXT(qp) = fp;
 80024b0:	4613      	mov	r3, r2
 80024b2:	f8cc 0000 	str.w	r0, [ip]
      H_HEAP(hp) = heapp;
 80024b6:	4810      	ldr	r0, [pc, #64]	; (80024f8 <chHeapAllocAligned.constprop.11+0xd8>)
 80024b8:	e9c3 0400 	strd	r0, r4, [r3]
      H_UNLOCK(heapp);
 80024bc:	300c      	adds	r0, #12
 80024be:	f7ff ff6f 	bl	80023a0 <chMtxUnlock>
}
 80024c2:	4638      	mov	r0, r7
 80024c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 80024c6:	eba3 0e0e 	sub.w	lr, r3, lr
 80024ca:	ea4f 01ee 	mov.w	r1, lr, asr #3
        if (bpages > pages) {
 80024ce:	42ae      	cmp	r6, r5
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 80024d0:	6051      	str	r1, [r2, #4]
        if (bpages > pages) {
 80024d2:	d2f0      	bcs.n	80024b6 <chHeapAllocAligned.constprop.11+0x96>
          fp = H_BLOCK(ahp) + pages;
 80024d4:	1c70      	adds	r0, r6, #1
 80024d6:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 80024da:	43f6      	mvns	r6, r6
 80024dc:	4435      	add	r5, r6
          H_NEXT(fp) = H_NEXT(hp);
 80024de:	6816      	ldr	r6, [r2, #0]
          H_PAGES(fp) = (bpages - pages) - 1U;
 80024e0:	604d      	str	r5, [r1, #4]
          H_NEXT(fp) = H_NEXT(hp);
 80024e2:	f843 6030 	str.w	r6, [r3, r0, lsl #3]
          H_NEXT(hp) = fp;
 80024e6:	6011      	str	r1, [r2, #0]
 80024e8:	e7e5      	b.n	80024b6 <chHeapAllocAligned.constprop.11+0x96>
          H_NEXT(qp) = H_NEXT(hp);
 80024ea:	f8cc 3000 	str.w	r3, [ip]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80024ee:	4677      	mov	r7, lr
          H_NEXT(qp) = H_NEXT(hp);
 80024f0:	4613      	mov	r3, r2
 80024f2:	e7e0      	b.n	80024b6 <chHeapAllocAligned.constprop.11+0x96>
 80024f4:	200010dc 	.word	0x200010dc
 80024f8:	200010d0 	.word	0x200010d0
 80024fc:	200010d4 	.word	0x200010d4

08002500 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8002502:	e950 7302 	ldrd	r7, r3, [r0, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002506:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002508:	08db      	lsrs	r3, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800250a:	f840 3c04 	str.w	r3, [r0, #-4]
  qp = &heapp->header;
 800250e:	1d3d      	adds	r5, r7, #4
void chHeapFree(void *p) {
 8002510:	4606      	mov	r6, r0
  hp = (heap_header_t *)p - 1U;
 8002512:	f1a0 0408 	sub.w	r4, r0, #8

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8002516:	370c      	adds	r7, #12
 8002518:	2320      	movs	r3, #32
 800251a:	f383 8811 	msr	BASEPRI, r3
 800251e:	4638      	mov	r0, r7
 8002520:	f7fe faa6 	bl	8000a70 <chMtxLockS>
 8002524:	2300      	movs	r3, #0
 8002526:	f383 8811 	msr	BASEPRI, r3
  qp = &heapp->header;
 800252a:	462b      	mov	r3, r5

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 800252c:	42ab      	cmp	r3, r5
 800252e:	681a      	ldr	r2, [r3, #0]
 8002530:	d001      	beq.n	8002536 <chHeapFree+0x36>
 8002532:	429c      	cmp	r4, r3
 8002534:	d902      	bls.n	800253c <chHeapFree+0x3c>
 8002536:	b11a      	cbz	r2, 8002540 <chHeapFree+0x40>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002538:	4294      	cmp	r4, r2
 800253a:	d301      	bcc.n	8002540 <chHeapFree+0x40>
void chHeapFree(void *p) {
 800253c:	4613      	mov	r3, r2
 800253e:	e7f5      	b.n	800252c <chHeapFree+0x2c>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002540:	f856 1c04 	ldr.w	r1, [r6, #-4]
      H_NEXT(hp) = H_NEXT(qp);
 8002544:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(qp) = hp;
 8002548:	601c      	str	r4, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800254a:	1c4a      	adds	r2, r1, #1
 800254c:	f856 0c08 	ldr.w	r0, [r6, #-8]
 8002550:	eb04 01c2 	add.w	r1, r4, r2, lsl #3
 8002554:	4281      	cmp	r1, r0
 8002556:	d00a      	beq.n	800256e <chHeapFree+0x6e>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 8002558:	6859      	ldr	r1, [r3, #4]
 800255a:	1c4a      	adds	r2, r1, #1
 800255c:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8002560:	4294      	cmp	r4, r2
 8002562:	d012      	beq.n	800258a <chHeapFree+0x8a>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8002564:	4638      	mov	r0, r7

  return;
}
 8002566:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
 800256a:	f7ff bf19 	b.w	80023a0 <chMtxUnlock>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800256e:	6849      	ldr	r1, [r1, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002570:	f854 0032 	ldr.w	r0, [r4, r2, lsl #3]
 8002574:	f846 0c08 	str.w	r0, [r6, #-8]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002578:	440a      	add	r2, r1
 800257a:	f846 2c04 	str.w	r2, [r6, #-4]
      if ((H_LIMIT(qp) == hp)) {
 800257e:	6859      	ldr	r1, [r3, #4]
 8002580:	1c4a      	adds	r2, r1, #1
 8002582:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8002586:	4294      	cmp	r4, r2
 8002588:	d1ec      	bne.n	8002564 <chHeapFree+0x64>
        H_NEXT(qp) = H_NEXT(hp);
 800258a:	e956 0202 	ldrd	r0, r2, [r6, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800258e:	3201      	adds	r2, #1
 8002590:	4411      	add	r1, r2
        H_NEXT(qp) = H_NEXT(hp);
 8002592:	6018      	str	r0, [r3, #0]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002594:	6059      	str	r1, [r3, #4]
  H_UNLOCK(heapp);
 8002596:	4638      	mov	r0, r7
}
 8002598:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
 800259c:	f7ff bf00 	b.w	80023a0 <chMtxUnlock>

080025a0 <dir_next>:
{
 80025a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 80025a4:	6905      	ldr	r5, [r0, #16]
 80025a6:	3520      	adds	r5, #32
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 80025a8:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
{
 80025ac:	b085      	sub	sp, #20
 80025ae:	4604      	mov	r4, r0
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 80025b0:	d21b      	bcs.n	80025ea <dir_next+0x4a>
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 80025b2:	6983      	ldr	r3, [r0, #24]
 80025b4:	2b00      	cmp	r3, #0
 80025b6:	f000 8174 	beq.w	80028a2 <dir_next+0x302>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 80025ba:	f3c5 0708 	ubfx	r7, r5, #0, #9
	FATFS *fs = dp->obj.fs;
 80025be:	f8d0 8000 	ldr.w	r8, [r0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 80025c2:	b147      	cbz	r7, 80025d6 <dir_next+0x36>
 80025c4:	f108 0634 	add.w	r6, r8, #52	; 0x34
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80025c8:	443e      	add	r6, r7
 80025ca:	61e6      	str	r6, [r4, #28]
	dp->dptr = ofs;						/* Current entry */
 80025cc:	6125      	str	r5, [r4, #16]
	return FR_OK;
 80025ce:	2000      	movs	r0, #0
}
 80025d0:	b005      	add	sp, #20
 80025d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80025d6:	460e      	mov	r6, r1
		if (dp->clust == 0) {	/* Static table */
 80025d8:	6941      	ldr	r1, [r0, #20]
		dp->sect++;				/* Next sector */
 80025da:	3301      	adds	r3, #1
 80025dc:	6183      	str	r3, [r0, #24]
		if (dp->clust == 0) {	/* Static table */
 80025de:	b951      	cbnz	r1, 80025f6 <dir_next+0x56>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 80025e0:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 80025e4:	ebb3 1f55 	cmp.w	r3, r5, lsr #5
 80025e8:	d8ec      	bhi.n	80025c4 <dir_next+0x24>
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 80025ea:	2300      	movs	r3, #0
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 80025ec:	2004      	movs	r0, #4
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
 80025ee:	61a3      	str	r3, [r4, #24]
}
 80025f0:	b005      	add	sp, #20
 80025f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
 80025f6:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 80025fa:	3b01      	subs	r3, #1
 80025fc:	ea13 2355 	ands.w	r3, r3, r5, lsr #9
 8002600:	d1e0      	bne.n	80025c4 <dir_next+0x24>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 8002602:	4640      	mov	r0, r8
 8002604:	f7fe fe1c 	bl	8001240 <get_fat.isra.9>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 8002608:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
 800260a:	4681      	mov	r9, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
 800260c:	d96f      	bls.n	80026ee <dir_next+0x14e>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 800260e:	f1b0 3fff 	cmp.w	r0, #4294967295
 8002612:	f000 808e 	beq.w	8002732 <dir_next+0x192>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
 8002616:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800261a:	4283      	cmp	r3, r0
 800261c:	f240 808b 	bls.w	8002736 <dir_next+0x196>
 8002620:	1e82      	subs	r2, r0, #2
 8002622:	9200      	str	r2, [sp, #0]
 8002624:	f108 0634 	add.w	r6, r8, #52	; 0x34
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002628:	9900      	ldr	r1, [sp, #0]
				dp->clust = clst;		/* Initialize data for new cluster */
 800262a:	f8c4 9014 	str.w	r9, [r4, #20]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800262e:	3b02      	subs	r3, #2
 8002630:	428b      	cmp	r3, r1
 8002632:	460a      	mov	r2, r1
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 8002634:	bf85      	ittet	hi
 8002636:	f8b8 300a 	ldrhhi.w	r3, [r8, #10]
 800263a:	f8d8 202c 	ldrhi.w	r2, [r8, #44]	; 0x2c
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800263e:	2300      	movls	r3, #0
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 8002640:	fb01 2303 	mlahi	r3, r1, r3, r2
				dp->sect = clst2sect(fs, clst);
 8002644:	61a3      	str	r3, [r4, #24]
 8002646:	e7bf      	b.n	80025c8 <dir_next+0x28>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8002648:	4651      	mov	r1, sl
 800264a:	4630      	mov	r0, r6
 800264c:	f7fe fdf8 	bl	8001240 <get_fat.isra.9>
		if (cs < 2) return 1;				/* Test for insanity */
 8002650:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8002652:	4681      	mov	r9, r0
		if (cs < 2) return 1;				/* Test for insanity */
 8002654:	d94b      	bls.n	80026ee <dir_next+0x14e>
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
 8002656:	f1b0 3fff 	cmp.w	r0, #4294967295
 800265a:	d06a      	beq.n	8002732 <dir_next+0x192>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 800265c:	69b3      	ldr	r3, [r6, #24]
 800265e:	4298      	cmp	r0, r3
 8002660:	f0c0 8086 	bcc.w	8002770 <dir_next+0x1d0>
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 8002664:	6972      	ldr	r2, [r6, #20]
 8002666:	2a00      	cmp	r2, #0
 8002668:	d07b      	beq.n	8002762 <dir_next+0x1c2>
			ncl = scl + 1;						/* Test if next cluster is free */
 800266a:	f10a 0901 	add.w	r9, sl, #1
			if (ncl >= fs->n_fatent) ncl = 2;
 800266e:	454b      	cmp	r3, r9
 8002670:	bf98      	it	ls
 8002672:	f04f 0902 	movls.w	r9, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
 8002676:	4649      	mov	r1, r9
 8002678:	6820      	ldr	r0, [r4, #0]
 800267a:	f7fe fde1 	bl	8001240 <get_fat.isra.9>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 800267e:	2801      	cmp	r0, #1
 8002680:	d035      	beq.n	80026ee <dir_next+0x14e>
 8002682:	1c43      	adds	r3, r0, #1
 8002684:	d055      	beq.n	8002732 <dir_next+0x192>
			if (cs != 0) {						/* Not free? */
 8002686:	2800      	cmp	r0, #0
 8002688:	f000 8102 	beq.w	8002890 <dir_next+0x2f0>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
 800268c:	f8d6 b010 	ldr.w	fp, [r6, #16]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 8002690:	69b3      	ldr	r3, [r6, #24]
 8002692:	f1bb 0f01 	cmp.w	fp, #1
 8002696:	f240 8102 	bls.w	800289e <dir_next+0x2fe>
 800269a:	459b      	cmp	fp, r3
 800269c:	bf28      	it	cs
 800269e:	46d3      	movcs	fp, sl
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 80026a0:	46d9      	mov	r9, fp
 80026a2:	e006      	b.n	80026b2 <dir_next+0x112>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
 80026a4:	2801      	cmp	r0, #1
 80026a6:	d022      	beq.n	80026ee <dir_next+0x14e>
 80026a8:	3001      	adds	r0, #1
 80026aa:	d042      	beq.n	8002732 <dir_next+0x192>
				if (ncl == scl) return 0;		/* No free cluster found? */
 80026ac:	45cb      	cmp	fp, r9
 80026ae:	d058      	beq.n	8002762 <dir_next+0x1c2>
 80026b0:	69b3      	ldr	r3, [r6, #24]
				ncl++;							/* Next cluster */
 80026b2:	f109 0901 	add.w	r9, r9, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 80026b6:	4599      	cmp	r9, r3
 80026b8:	d304      	bcc.n	80026c4 <dir_next+0x124>
					if (ncl > scl) return 0;	/* No free cluster found? */
 80026ba:	f1bb 0f01 	cmp.w	fp, #1
 80026be:	d950      	bls.n	8002762 <dir_next+0x1c2>
					ncl = 2;
 80026c0:	f04f 0902 	mov.w	r9, #2
				cs = get_fat(obj, ncl);			/* Get the cluster status */
 80026c4:	4649      	mov	r1, r9
 80026c6:	6820      	ldr	r0, [r4, #0]
 80026c8:	f7fe fdba 	bl	8001240 <get_fat.isra.9>
				if (cs == 0) break;				/* Found a free cluster? */
 80026cc:	2800      	cmp	r0, #0
 80026ce:	d1e9      	bne.n	80026a4 <dir_next+0x104>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 80026d0:	f1b9 0f01 	cmp.w	r9, #1
 80026d4:	d90b      	bls.n	80026ee <dir_next+0x14e>
 80026d6:	69b3      	ldr	r3, [r6, #24]
 80026d8:	4599      	cmp	r9, r3
 80026da:	d208      	bcs.n	80026ee <dir_next+0x14e>
 80026dc:	f04f 32ff 	mov.w	r2, #4294967295
 80026e0:	4649      	mov	r1, r9
 80026e2:	4630      	mov	r0, r6
 80026e4:	f7fe fe74 	bl	80013d0 <put_fat.part.8>
		if (res == FR_OK && clst != 0) {
 80026e8:	b118      	cbz	r0, 80026f2 <dir_next+0x152>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 80026ea:	2801      	cmp	r0, #1
 80026ec:	d021      	beq.n	8002732 <dir_next+0x192>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 80026ee:	2002      	movs	r0, #2
 80026f0:	e76e      	b.n	80025d0 <dir_next+0x30>
		if (res == FR_OK && clst != 0) {
 80026f2:	f1ba 0f00 	cmp.w	sl, #0
 80026f6:	d00c      	beq.n	8002712 <dir_next+0x172>
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 80026f8:	f1ba 0f01 	cmp.w	sl, #1
 80026fc:	d9f7      	bls.n	80026ee <dir_next+0x14e>
 80026fe:	69b3      	ldr	r3, [r6, #24]
 8002700:	459a      	cmp	sl, r3
 8002702:	d2f4      	bcs.n	80026ee <dir_next+0x14e>
 8002704:	4651      	mov	r1, sl
 8002706:	464a      	mov	r2, r9
 8002708:	4630      	mov	r0, r6
 800270a:	f7fe fe61 	bl	80013d0 <put_fat.part.8>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 800270e:	2800      	cmp	r0, #0
 8002710:	d1eb      	bne.n	80026ea <dir_next+0x14a>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8002712:	e9d6 3205 	ldrd	r3, r2, [r6, #20]
 8002716:	3a02      	subs	r2, #2
 8002718:	4293      	cmp	r3, r2
		fs->last_clst = ncl;
 800271a:	f8c6 9010 	str.w	r9, [r6, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800271e:	d801      	bhi.n	8002724 <dir_next+0x184>
 8002720:	3b01      	subs	r3, #1
 8002722:	6173      	str	r3, [r6, #20]
		fs->fsi_flag |= 1;
 8002724:	7933      	ldrb	r3, [r6, #4]
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8002726:	f1b9 3fff 	cmp.w	r9, #4294967295
		fs->fsi_flag |= 1;
 800272a:	f043 0301 	orr.w	r3, r3, #1
 800272e:	7133      	strb	r3, [r6, #4]
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8002730:	d11e      	bne.n	8002770 <dir_next+0x1d0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8002732:	2001      	movs	r0, #1
 8002734:	e74c      	b.n	80025d0 <dir_next+0x30>
					if (!stretch) {								/* If no stretch, report EOT */
 8002736:	2e00      	cmp	r6, #0
 8002738:	f43f af57 	beq.w	80025ea <dir_next+0x4a>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 800273c:	f8d4 a014 	ldr.w	sl, [r4, #20]
	FATFS *fs = obj->fs;
 8002740:	6826      	ldr	r6, [r4, #0]
	if (clst == 0) {	/* Create a new chain */
 8002742:	f1ba 0f00 	cmp.w	sl, #0
 8002746:	f47f af7f 	bne.w	8002648 <dir_next+0xa8>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
 800274a:	f8d6 b010 	ldr.w	fp, [r6, #16]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 800274e:	f1bb 0f00 	cmp.w	fp, #0
 8002752:	d008      	beq.n	8002766 <dir_next+0x1c6>
 8002754:	69b3      	ldr	r3, [r6, #24]
 8002756:	459b      	cmp	fp, r3
 8002758:	bf28      	it	cs
 800275a:	f04f 0b01 	movcs.w	fp, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
 800275e:	6973      	ldr	r3, [r6, #20]
 8002760:	b923      	cbnz	r3, 800276c <dir_next+0x1cc>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8002762:	2007      	movs	r0, #7
 8002764:	e734      	b.n	80025d0 <dir_next+0x30>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8002766:	f04f 0b01 	mov.w	fp, #1
 800276a:	e7f8      	b.n	800275e <dir_next+0x1be>
 800276c:	69b3      	ldr	r3, [r6, #24]
 800276e:	e797      	b.n	80026a0 <dir_next+0x100>
	if (fs->wflag) {	/* Is the disk access window dirty */
 8002770:	f898 3003 	ldrb.w	r3, [r8, #3]
 8002774:	2b00      	cmp	r3, #0
 8002776:	f040 8081 	bne.w	800287c <dir_next+0x2dc>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800277a:	f8d8 3018 	ldr.w	r3, [r8, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 800277e:	f1a9 0202 	sub.w	r2, r9, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002782:	3b02      	subs	r3, #2
 8002784:	429a      	cmp	r2, r3
	clst -= 2;		/* Cluster number is origin from 2 */
 8002786:	9200      	str	r2, [sp, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8002788:	d27f      	bcs.n	800288a <dir_next+0x2ea>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 800278a:	f8b8 200a 	ldrh.w	r2, [r8, #10]
 800278e:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 8002792:	9900      	ldr	r1, [sp, #0]
 8002794:	fb01 3302 	mla	r3, r1, r2, r3
 8002798:	9301      	str	r3, [sp, #4]
	fs->winsect = sect;				/* Set window to top of the cluster */
 800279a:	9b01      	ldr	r3, [sp, #4]
 800279c:	f8c8 3030 	str.w	r3, [r8, #48]	; 0x30
	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 80027a0:	f108 0634 	add.w	r6, r8, #52	; 0x34
	BYTE *d = (BYTE*)dst;
 80027a4:	4633      	mov	r3, r6
 80027a6:	f508 710d 	add.w	r1, r8, #564	; 0x234
		*d++ = (BYTE)val;
 80027aa:	2200      	movs	r2, #0
 80027ac:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 80027b0:	428b      	cmp	r3, r1
 80027b2:	d1fb      	bne.n	80027ac <dir_next+0x20c>
	for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
 80027b4:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 80027b8:	ea4f 2a43 	mov.w	sl, r3, lsl #9
 80027bc:	f5ba 4f00 	cmp.w	sl, #32768	; 0x8000
 80027c0:	d259      	bcs.n	8002876 <dir_next+0x2d6>
 80027c2:	f5ba 7f00 	cmp.w	sl, #512	; 0x200
 80027c6:	d805      	bhi.n	80027d4 <dir_next+0x234>
 80027c8:	e03d      	b.n	8002846 <dir_next+0x2a6>
 80027ca:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
 80027ce:	f5ba 7f00 	cmp.w	sl, #512	; 0x200
 80027d2:	d936      	bls.n	8002842 <dir_next+0x2a2>
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 80027d4:	4650      	mov	r0, sl
 80027d6:	f7ff fe23 	bl	8002420 <chHeapAllocAligned.constprop.11>
 80027da:	2800      	cmp	r0, #0
 80027dc:	d0f5      	beq.n	80027ca <dir_next+0x22a>
 80027de:	4603      	mov	r3, r0
 80027e0:	9002      	str	r0, [sp, #8]
 80027e2:	eb00 010a 	add.w	r1, r0, sl
		*d++ = (BYTE)val;
 80027e6:	2200      	movs	r2, #0
 80027e8:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
 80027ec:	428b      	cmp	r3, r1
 80027ee:	d1fb      	bne.n	80027e8 <dir_next+0x248>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 80027f0:	f8b8 300a 	ldrh.w	r3, [r8, #10]
		szb /= SS(fs);		/* Bytes -> Sectors */
 80027f4:	ea4f 2a5a 	mov.w	sl, sl, lsr #9
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 80027f8:	469b      	mov	fp, r3
 80027fa:	b1bb      	cbz	r3, 800282c <dir_next+0x28c>
 80027fc:	9703      	str	r7, [sp, #12]
 80027fe:	f04f 0b00 	mov.w	fp, #0
 8002802:	9f01      	ldr	r7, [sp, #4]
 8002804:	9401      	str	r4, [sp, #4]
 8002806:	9c02      	ldr	r4, [sp, #8]
 8002808:	e004      	b.n	8002814 <dir_next+0x274>
 800280a:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 800280e:	44d3      	add	fp, sl
 8002810:	459b      	cmp	fp, r3
 8002812:	d209      	bcs.n	8002828 <dir_next+0x288>
 8002814:	4653      	mov	r3, sl
 8002816:	eb07 020b 	add.w	r2, r7, fp
 800281a:	4621      	mov	r1, r4
 800281c:	f898 0001 	ldrb.w	r0, [r8, #1]
 8002820:	f7fe fbf6 	bl	8001010 <disk_write>
 8002824:	2800      	cmp	r0, #0
 8002826:	d0f0      	beq.n	800280a <dir_next+0x26a>
 8002828:	9f03      	ldr	r7, [sp, #12]
 800282a:	9c01      	ldr	r4, [sp, #4]
/*------------------------------------------------------------------------*/
/* Free a memory block                                                    */
/*------------------------------------------------------------------------*/
void ff_memfree(void *mblock) {

  chHeapFree(mblock);
 800282c:	9802      	ldr	r0, [sp, #8]
 800282e:	f7ff fe67 	bl	8002500 <chHeapFree>
 8002832:	f8b8 300a 	ldrh.w	r3, [r8, #10]
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
 8002836:	455b      	cmp	r3, fp
 8002838:	f47f af7b 	bne.w	8002732 <dir_next+0x192>
 800283c:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8002840:	e6f2      	b.n	8002628 <dir_next+0x88>
 8002842:	f8b8 300a 	ldrh.w	r3, [r8, #10]
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 8002846:	2b00      	cmp	r3, #0
 8002848:	d0f8      	beq.n	800283c <dir_next+0x29c>
 800284a:	f04f 0b00 	mov.w	fp, #0
 800284e:	f8dd a004 	ldr.w	sl, [sp, #4]
 8002852:	e003      	b.n	800285c <dir_next+0x2bc>
 8002854:	f10b 0b01 	add.w	fp, fp, #1
 8002858:	459b      	cmp	fp, r3
 800285a:	d2ec      	bcs.n	8002836 <dir_next+0x296>
 800285c:	2301      	movs	r3, #1
 800285e:	eb0a 020b 	add.w	r2, sl, fp
 8002862:	4631      	mov	r1, r6
 8002864:	f898 0001 	ldrb.w	r0, [r8, #1]
 8002868:	f7fe fbd2 	bl	8001010 <disk_write>
 800286c:	f8b8 300a 	ldrh.w	r3, [r8, #10]
 8002870:	2800      	cmp	r0, #0
 8002872:	d0ef      	beq.n	8002854 <dir_next+0x2b4>
 8002874:	e7df      	b.n	8002836 <dir_next+0x296>
	for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
 8002876:	f44f 4a00 	mov.w	sl, #32768	; 0x8000
 800287a:	e7ab      	b.n	80027d4 <dir_next+0x234>
 800287c:	4640      	mov	r0, r8
 800287e:	f7fe fbdf 	bl	8001040 <sync_window.part.5>
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 8002882:	2800      	cmp	r0, #0
 8002884:	f43f af79 	beq.w	800277a <dir_next+0x1da>
 8002888:	e753      	b.n	8002732 <dir_next+0x192>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800288a:	2300      	movs	r3, #0
 800288c:	9301      	str	r3, [sp, #4]
 800288e:	e784      	b.n	800279a <dir_next+0x1fa>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
 8002890:	f1b9 0f00 	cmp.w	r9, #0
 8002894:	f47f af1c 	bne.w	80026d0 <dir_next+0x130>
 8002898:	46d3      	mov	fp, sl
 800289a:	69b3      	ldr	r3, [r6, #24]
 800289c:	e700      	b.n	80026a0 <dir_next+0x100>
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
 800289e:	46d3      	mov	fp, sl
 80028a0:	e6fe      	b.n	80026a0 <dir_next+0x100>
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 80028a2:	2004      	movs	r0, #4
 80028a4:	e694      	b.n	80025d0 <dir_next+0x30>
 80028a6:	bf00      	nop
	...

080028b0 <dir_find>:
{
 80028b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 80028b4:	2100      	movs	r1, #0
{
 80028b6:	b089      	sub	sp, #36	; 0x24
 80028b8:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 80028ba:	6807      	ldr	r7, [r0, #0]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 80028bc:	f7fe fd38 	bl	8001330 <dir_sdi>
	if (res != FR_OK) return res;
 80028c0:	4682      	mov	sl, r0
 80028c2:	2800      	cmp	r0, #0
 80028c4:	d145      	bne.n	8002952 <dir_find+0xa2>
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80028c6:	f04f 33ff 	mov.w	r3, #4294967295
 80028ca:	f04f 0bff 	mov.w	fp, #255	; 0xff
 80028ce:	62eb      	str	r3, [r5, #44]	; 0x2c
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80028d0:	4698      	mov	r8, r3
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80028d2:	46d9      	mov	r9, fp
 80028d4:	e00b      	b.n	80028ee <dir_find+0x3e>
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 80028d6:	2b0f      	cmp	r3, #15
 80028d8:	d03f      	beq.n	800295a <dir_find+0xaa>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 80028da:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
 80028de:	f04f 09ff 	mov.w	r9, #255	; 0xff
		res = dir_next(dp, 0);	/* Next entry */
 80028e2:	2100      	movs	r1, #0
 80028e4:	4628      	mov	r0, r5
 80028e6:	f7ff fe5b 	bl	80025a0 <dir_next>
	} while (res == FR_OK);
 80028ea:	2800      	cmp	r0, #0
 80028ec:	d14c      	bne.n	8002988 <dir_find+0xd8>
		res = move_window(fs, dp->sect);
 80028ee:	69a9      	ldr	r1, [r5, #24]
	if (sector != fs->winsect) {	/* Window offset changed? */
 80028f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80028f2:	4299      	cmp	r1, r3
 80028f4:	d004      	beq.n	8002900 <dir_find+0x50>
 80028f6:	4638      	mov	r0, r7
 80028f8:	f7fe fc8a 	bl	8001210 <move_window.part.6>
		if (res != FR_OK) break;
 80028fc:	2800      	cmp	r0, #0
 80028fe:	d143      	bne.n	8002988 <dir_find+0xd8>
		c = dp->dir[DIR_Name];
 8002900:	69ec      	ldr	r4, [r5, #28]
 8002902:	7826      	ldrb	r6, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8002904:	2e00      	cmp	r6, #0
 8002906:	d05b      	beq.n	80029c0 <dir_find+0x110>
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 8002908:	7ae2      	ldrb	r2, [r4, #11]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 800290a:	2ee5      	cmp	r6, #229	; 0xe5
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 800290c:	f002 033f 	and.w	r3, r2, #63	; 0x3f
 8002910:	71ab      	strb	r3, [r5, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8002912:	d0e2      	beq.n	80028da <dir_find+0x2a>
 8002914:	0712      	lsls	r2, r2, #28
 8002916:	d4de      	bmi.n	80028d6 <dir_find+0x26>
			if (a == AM_LFN) {			/* An LFN entry is found */
 8002918:	2b0f      	cmp	r3, #15
 800291a:	d01e      	beq.n	800295a <dir_find+0xaa>
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 800291c:	f1b9 0f00 	cmp.w	r9, #0
 8002920:	d037      	beq.n	8002992 <dir_find+0xe2>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8002922:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 8002926:	07db      	lsls	r3, r3, #31
 8002928:	d4d7      	bmi.n	80028da <dir_find+0x2a>
		r = *d++ - *s++;
 800292a:	4620      	mov	r0, r4
 800292c:	4629      	mov	r1, r5
 800292e:	f810 3b0b 	ldrb.w	r3, [r0], #11
 8002932:	f811 2f20 	ldrb.w	r2, [r1, #32]!
 8002936:	3401      	adds	r4, #1
 8002938:	1a9b      	subs	r3, r3, r2
	} while (--cnt && r == 0);
 800293a:	2b00      	cmp	r3, #0
 800293c:	d1cd      	bne.n	80028da <dir_find+0x2a>
		r = *d++ - *s++;
 800293e:	f814 3b01 	ldrb.w	r3, [r4], #1
 8002942:	f811 2f01 	ldrb.w	r2, [r1, #1]!
	} while (--cnt && r == 0);
 8002946:	4284      	cmp	r4, r0
		r = *d++ - *s++;
 8002948:	eba3 0302 	sub.w	r3, r3, r2
	} while (--cnt && r == 0);
 800294c:	d1f5      	bne.n	800293a <dir_find+0x8a>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 800294e:	2b00      	cmp	r3, #0
 8002950:	d1c3      	bne.n	80028da <dir_find+0x2a>
}
 8002952:	4650      	mov	r0, sl
 8002954:	b009      	add	sp, #36	; 0x24
 8002956:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 800295a:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 800295e:	065b      	lsls	r3, r3, #25
 8002960:	d4bf      	bmi.n	80028e2 <dir_find+0x32>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 8002962:	0670      	lsls	r0, r6, #25
 8002964:	d527      	bpl.n	80029b6 <dir_find+0x106>
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 8002966:	692b      	ldr	r3, [r5, #16]
						sum = dp->dir[LDIR_Chksum];
 8002968:	f894 b00d 	ldrb.w	fp, [r4, #13]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 800296c:	62eb      	str	r3, [r5, #44]	; 0x2c
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 800296e:	f006 06bf 	and.w	r6, r6, #191	; 0xbf
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8002972:	7b63      	ldrb	r3, [r4, #13]
 8002974:	455b      	cmp	r3, fp
 8002976:	d029      	beq.n	80029cc <dir_find+0x11c>
 8002978:	f04f 09ff 	mov.w	r9, #255	; 0xff
		res = dir_next(dp, 0);	/* Next entry */
 800297c:	2100      	movs	r1, #0
 800297e:	4628      	mov	r0, r5
 8002980:	f7ff fe0e 	bl	80025a0 <dir_next>
	} while (res == FR_OK);
 8002984:	2800      	cmp	r0, #0
 8002986:	d0b2      	beq.n	80028ee <dir_find+0x3e>
 8002988:	4682      	mov	sl, r0
}
 800298a:	4650      	mov	r0, sl
 800298c:	b009      	add	sp, #36	; 0x24
 800298e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002992:	f104 000b 	add.w	r0, r4, #11
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8002996:	4621      	mov	r1, r4
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8002998:	f811 2b01 	ldrb.w	r2, [r1], #1
 800299c:	ea4f 13c9 	mov.w	r3, r9, lsl #7
 80029a0:	ea43 0959 	orr.w	r9, r3, r9, lsr #1
 80029a4:	fa52 f989 	uxtab	r9, r2, r9
	} while (--n);
 80029a8:	4281      	cmp	r1, r0
		sum = (sum >> 1) + (sum << 7) + *dir++;
 80029aa:	fa5f f989 	uxtb.w	r9, r9
	} while (--n);
 80029ae:	d1f3      	bne.n	8002998 <dir_find+0xe8>
				if (ord == 0 && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 80029b0:	45cb      	cmp	fp, r9
 80029b2:	d1b6      	bne.n	8002922 <dir_find+0x72>
 80029b4:	e7cd      	b.n	8002952 <dir_find+0xa2>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80029b6:	45b1      	cmp	r9, r6
 80029b8:	d0db      	beq.n	8002972 <dir_find+0xc2>
 80029ba:	f04f 09ff 	mov.w	r9, #255	; 0xff
 80029be:	e7dd      	b.n	800297c <dir_find+0xcc>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 80029c0:	f04f 0a04 	mov.w	sl, #4
}
 80029c4:	4650      	mov	r0, sl
 80029c6:	b009      	add	sp, #36	; 0x24
 80029c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	rv = rv << 8 | ptr[0];
 80029cc:	7ee2      	ldrb	r2, [r4, #27]
 80029ce:	7ea3      	ldrb	r3, [r4, #26]
	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 80029d0:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 80029d4:	d1d0      	bne.n	8002978 <dir_find+0xc8>
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80029d6:	7822      	ldrb	r2, [r4, #0]
 80029d8:	9206      	str	r2, [sp, #24]
 80029da:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80029de:	3a01      	subs	r2, #1
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80029e0:	68f9      	ldr	r1, [r7, #12]
 80029e2:	4b27      	ldr	r3, [pc, #156]	; (8002a80 <dir_find+0x1d0>)
 80029e4:	9105      	str	r1, [sp, #20]
	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80029e6:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 80029ea:	2101      	movs	r1, #1
 80029ec:	eb02 0280 	add.w	r2, r2, r0, lsl #2
			if (uc != 0xFFFF) return 0;		/* Check filler */
 80029f0:	e9cd b701 	strd	fp, r7, [sp, #4]
 80029f4:	4699      	mov	r9, r3
 80029f6:	e9cd a503 	strd	sl, r5, [sp, #12]
 80029fa:	9f05      	ldr	r7, [sp, #20]
 80029fc:	9607      	str	r6, [sp, #28]
 80029fe:	4625      	mov	r5, r4
 8002a00:	460b      	mov	r3, r1
 8002a02:	4614      	mov	r4, r2
 8002a04:	e011      	b.n	8002a2a <dir_find+0x17a>
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8002a06:	2cfe      	cmp	r4, #254	; 0xfe
 8002a08:	d81d      	bhi.n	8002a46 <dir_find+0x196>
 8002a0a:	f7fd fd79 	bl	8000500 <ff_wtoupper.part.2>
 8002a0e:	4683      	mov	fp, r0
 8002a10:	f837 0014 	ldrh.w	r0, [r7, r4, lsl #1]
 8002a14:	f7fd fd74 	bl	8000500 <ff_wtoupper.part.2>
 8002a18:	4558      	cmp	r0, fp
 8002a1a:	d114      	bne.n	8002a46 <dir_find+0x196>
	rv = rv << 8 | ptr[0];
 8002a1c:	4633      	mov	r3, r6
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8002a1e:	4654      	mov	r4, sl
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8002a20:	4a18      	ldr	r2, [pc, #96]	; (8002a84 <dir_find+0x1d4>)
 8002a22:	454a      	cmp	r2, r9
 8002a24:	d016      	beq.n	8002a54 <dir_find+0x1a4>
 8002a26:	f819 1f01 	ldrb.w	r1, [r9, #1]!
	rv = rv << 8 | ptr[0];
 8002a2a:	5c6e      	ldrb	r6, [r5, r1]
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 8002a2c:	1868      	adds	r0, r5, r1
			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 8002a2e:	f104 0a01 	add.w	sl, r4, #1
	rv = rv << 8 | ptr[0];
 8002a32:	7840      	ldrb	r0, [r0, #1]
 8002a34:	ea46 2600 	orr.w	r6, r6, r0, lsl #8
 8002a38:	4630      	mov	r0, r6
		if (wc != 0) {
 8002a3a:	2b00      	cmp	r3, #0
 8002a3c:	d1e3      	bne.n	8002a06 <dir_find+0x156>
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8002a3e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002a42:	4296      	cmp	r6, r2
 8002a44:	d0ec      	beq.n	8002a20 <dir_find+0x170>
 8002a46:	e9dd b701 	ldrd	fp, r7, [sp, #4]
 8002a4a:	e9dd a503 	ldrd	sl, r5, [sp, #12]
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8002a4e:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8002a52:	e746      	b.n	80028e2 <dir_find+0x32>
 8002a54:	469c      	mov	ip, r3
	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 8002a56:	9b06      	ldr	r3, [sp, #24]
 8002a58:	9e07      	ldr	r6, [sp, #28]
 8002a5a:	0659      	lsls	r1, r3, #25
 8002a5c:	e9dd b701 	ldrd	fp, r7, [sp, #4]
 8002a60:	e9dd a503 	ldrd	sl, r5, [sp, #12]
 8002a64:	d507      	bpl.n	8002a76 <dir_find+0x1c6>
 8002a66:	f1bc 0f00 	cmp.w	ip, #0
 8002a6a:	d004      	beq.n	8002a76 <dir_find+0x1c6>
 8002a6c:	9b05      	ldr	r3, [sp, #20]
 8002a6e:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	d180      	bne.n	8002978 <dir_find+0xc8>
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8002a76:	3e01      	subs	r6, #1
 8002a78:	fa5f f986 	uxtb.w	r9, r6
 8002a7c:	e731      	b.n	80028e2 <dir_find+0x32>
 8002a7e:	bf00      	nop
 8002a80:	08003ff4 	.word	0x08003ff4
 8002a84:	08004000 	.word	0x08004000
	...

08002a90 <main>:

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8002a90:	4b26      	ldr	r3, [pc, #152]	; (8002b2c <main+0x9c>)
  PWR->CR |= PWR_CR_DBP;
 8002a92:	4827      	ldr	r0, [pc, #156]	; (8002b30 <main+0xa0>)
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8002a94:	691a      	ldr	r2, [r3, #16]
 8002a96:	ea6f 52c2 	mvn.w	r2, r2, lsl #23
 8002a9a:	ea6f 52d2 	mvn.w	r2, r2, lsr #23
}

/*
 * Application entry point.
 */
int main(void) {
 8002a9e:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002aa2:	611a      	str	r2, [r3, #16]
 8002aa4:	691a      	ldr	r2, [r3, #16]
 8002aa6:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8002aaa:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8002aac:	f04f 34ff 	mov.w	r4, #4294967295
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8002ab0:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
 8002ab2:	695a      	ldr	r2, [r3, #20]
 8002ab4:	615c      	str	r4, [r3, #20]
 8002ab6:	2200      	movs	r2, #0
 8002ab8:	6959      	ldr	r1, [r3, #20]
 8002aba:	615a      	str	r2, [r3, #20]
 8002abc:	6959      	ldr	r1, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8002abe:	6a19      	ldr	r1, [r3, #32]
 8002ac0:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 8002ac4:	6219      	str	r1, [r3, #32]
 8002ac6:	6a19      	ldr	r1, [r3, #32]
 8002ac8:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
 8002acc:	6219      	str	r1, [r3, #32]
 8002ace:	6a19      	ldr	r1, [r3, #32]
  rccResetAPB2(~0);
 8002ad0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8002ad2:	625c      	str	r4, [r3, #36]	; 0x24
 8002ad4:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8002ad6:	625a      	str	r2, [r3, #36]	; 0x24
 8002ad8:	6a59      	ldr	r1, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8002ada:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8002adc:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8002ae0:	6419      	str	r1, [r3, #64]	; 0x40
 8002ae2:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8002ae4:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8002ae8:	6619      	str	r1, [r3, #96]	; 0x60
 8002aea:	6e19      	ldr	r1, [r3, #96]	; 0x60
  PWR->CR |= PWR_CR_DBP;
 8002aec:	6801      	ldr	r1, [r0, #0]
 8002aee:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8002af2:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8002af4:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8002af6:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8002afa:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8002afe:	b097      	sub	sp, #92	; 0x5c
 8002b00:	d003      	beq.n	8002b0a <main+0x7a>
    RCC->BDCR = RCC_BDCR_BDRST;
 8002b02:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8002b06:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8002b08:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 8002b0a:	4c09      	ldr	r4, [pc, #36]	; (8002b30 <main+0xa0>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 8002b0c:	4909      	ldr	r1, [pc, #36]	; (8002b34 <main+0xa4>)
 8002b0e:	6862      	ldr	r2, [r4, #4]
 8002b10:	4b09      	ldr	r3, [pc, #36]	; (8002b38 <main+0xa8>)
 8002b12:	4d0a      	ldr	r5, [pc, #40]	; (8002b3c <main+0xac>)
 8002b14:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8002b18:	2000      	movs	r0, #0
 8002b1a:	6062      	str	r2, [r4, #4]
 8002b1c:	460f      	mov	r7, r1
 8002b1e:	6008      	str	r0, [r1, #0]
 8002b20:	460a      	mov	r2, r1
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8002b22:	4680      	mov	r8, r0
 8002b24:	f103 01c0 	add.w	r1, r3, #192	; 0xc0
 8002b28:	e00c      	b.n	8002b44 <main+0xb4>
 8002b2a:	bf00      	nop
 8002b2c:	40023800 	.word	0x40023800
 8002b30:	40007000 	.word	0x40007000
 8002b34:	200010ec 	.word	0x200010ec
 8002b38:	08004010 	.word	0x08004010
 8002b3c:	40026010 	.word	0x40026010
 8002b40:	f853 5c0c 	ldr.w	r5, [r3, #-12]
 8002b44:	f8c5 8000 	str.w	r8, [r5]
 8002b48:	330c      	adds	r3, #12
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002b4a:	428b      	cmp	r3, r1
    dma.streams[i].func = NULL;
 8002b4c:	f8c2 8004 	str.w	r8, [r2, #4]
 8002b50:	f102 0208 	add.w	r2, r2, #8
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8002b54:	d1f4      	bne.n	8002b40 <main+0xb0>
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b56:	4ed3      	ldr	r6, [pc, #844]	; (8002ea4 <main+0x414>)
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8002b58:	f8df c394 	ldr.w	ip, [pc, #916]	; 8002ef0 <main+0x460>
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8002b5c:	4ad2      	ldr	r2, [pc, #840]	; (8002ea8 <main+0x418>)
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8002b5e:	4dd3      	ldr	r5, [pc, #844]	; (8002eac <main+0x41c>)
 8002b60:	4cd3      	ldr	r4, [pc, #844]	; (8002eb0 <main+0x420>)
  DMA1->LIFCR = 0xFFFFFFFFU;
 8002b62:	f04f 39ff 	mov.w	r9, #4294967295
 8002b66:	2360      	movs	r3, #96	; 0x60
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b68:	2040      	movs	r0, #64	; 0x40
 8002b6a:	f8cc 9008 	str.w	r9, [ip, #8]
 8002b6e:	f04f 0a80 	mov.w	sl, #128	; 0x80
  DMA1->HIFCR = 0xFFFFFFFFU;
 8002b72:	f8cc 900c 	str.w	r9, [ip, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8002b76:	f8c2 9008 	str.w	r9, [r2, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8002b7a:	f8c2 900c 	str.w	r9, [r2, #12]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b7e:	f886 3306 	strb.w	r3, [r6, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b82:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002b86:	f8c6 0180 	str.w	r0, [r6, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b8a:	6030      	str	r0, [r6, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b8c:	f44f 7000 	mov.w	r0, #512	; 0x200
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b90:	f886 3307 	strb.w	r3, [r6, #775]	; 0x307
 8002b94:	4629      	mov	r1, r5
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b96:	f8c6 a180 	str.w	sl, [r6, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b9a:	f8c6 a000 	str.w	sl, [r6]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b9e:	f886 3308 	strb.w	r3, [r6, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002ba2:	f8c6 2180 	str.w	r2, [r6, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ba6:	6032      	str	r2, [r6, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002ba8:	f886 3309 	strb.w	r3, [r6, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002bac:	f8c6 0180 	str.w	r0, [r6, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002bb0:	6030      	str	r0, [r6, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002bb2:	f44f 6080 	mov.w	r0, #1024	; 0x400
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002bb6:	f886 330a 	strb.w	r3, [r6, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002bba:	f8c6 0180 	str.w	r0, [r6, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002bbe:	6030      	str	r0, [r6, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002bc0:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002bc4:	f886 3317 	strb.w	r3, [r6, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002bc8:	f8c6 0180 	str.w	r0, [r6, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002bcc:	6030      	str	r0, [r6, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002bce:	f886 3328 	strb.w	r3, [r6, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002bd2:	f8c6 2184 	str.w	r2, [r6, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002bd6:	6072      	str	r2, [r6, #4]
 8002bd8:	f841 4b04 	str.w	r4, [r1], #4
  tqp->next = (thread_t *)tqp;
 8002bdc:	f105 020c 	add.w	r2, r5, #12
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8002be0:	f04f 0b01 	mov.w	fp, #1
  iqp->q_buffer  = bp;
 8002be4:	f105 0354 	add.w	r3, r5, #84	; 0x54
  tqp->prev = (thread_t *)tqp;
 8002be8:	e9c5 2203 	strd	r2, r2, [r5, #12]
  oqp->q_notify  = onfy;
 8002bec:	4ab1      	ldr	r2, [pc, #708]	; (8002eb4 <main+0x424>)
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8002bee:	6069      	str	r1, [r5, #4]
  oqp->q_top     = bp + size;
 8002bf0:	f105 0074 	add.w	r0, r5, #116	; 0x74
  oqp->q_counter = size;
 8002bf4:	2110      	movs	r1, #16
  iqp->q_buffer  = bp;
 8002bf6:	61ab      	str	r3, [r5, #24]
  iqp->q_counter = 0;
 8002bf8:	f8c5 8014 	str.w	r8, [r5, #20]
 8002bfc:	f885 b008 	strb.w	fp, [r5, #8]
  iqp->q_wrptr   = bp;
 8002c00:	e9c5 3308 	strd	r3, r3, [r5, #32]
  iqp->q_top     = bp + size;
 8002c04:	f105 0364 	add.w	r3, r5, #100	; 0x64
  oqp->q_notify  = onfy;
 8002c08:	64ea      	str	r2, [r5, #76]	; 0x4c
  tqp->next = (thread_t *)tqp;
 8002c0a:	f105 0230 	add.w	r2, r5, #48	; 0x30
  oqp->q_counter = size;
 8002c0e:	63a9      	str	r1, [r5, #56]	; 0x38
  oqp->q_top     = bp + size;
 8002c10:	6428      	str	r0, [r5, #64]	; 0x40
  SD5.usart = UART5;
#endif

#if STM32_SERIAL_USE_USART6
  sdObjectInit(&SD6, NULL, notify6);
  SD6.usart = USART6;
 8002c12:	49a9      	ldr	r1, [pc, #676]	; (8002eb8 <main+0x428>)
  iqp->q_top     = bp + size;
 8002c14:	61eb      	str	r3, [r5, #28]
  oqp->q_buffer  = bp;
 8002c16:	63eb      	str	r3, [r5, #60]	; 0x3c
  oqp->q_wrptr   = bp;
 8002c18:	e9c5 3311 	strd	r3, r3, [r5, #68]	; 0x44
  tqp->prev = (thread_t *)tqp;
 8002c1c:	e9c5 220c 	strd	r2, r2, [r5, #48]	; 0x30
  iqp->q_link    = link;
 8002c20:	e9c5 850a 	strd	r8, r5, [r5, #40]	; 0x28
  oqp->q_link    = link;
 8002c24:	652d      	str	r5, [r5, #80]	; 0x50
 8002c26:	6769      	str	r1, [r5, #116]	; 0x74
  sdc_lld_init();
 8002c28:	f7fd fe6a 	bl	8000900 <sdc_lld_init>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8002c2c:	4ba3      	ldr	r3, [pc, #652]	; (8002ebc <main+0x42c>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8002c2e:	49a4      	ldr	r1, [pc, #656]	; (8002ec0 <main+0x430>)
  ST_ENABLE_CLOCK();
 8002c30:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  tqp->next = (thread_t *)tqp;
 8002c32:	4ca4      	ldr	r4, [pc, #656]	; (8002ec4 <main+0x434>)
  ch_memcore.basemem = __heap_base__;
 8002c34:	48a4      	ldr	r0, [pc, #656]	; (8002ec8 <main+0x438>)
 8002c36:	f8df c2bc 	ldr.w	ip, [pc, #700]	; 8002ef4 <main+0x464>
 8002c3a:	ea42 020b 	orr.w	r2, r2, fp
 8002c3e:	641a      	str	r2, [r3, #64]	; 0x40
 8002c40:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8002c42:	ea42 020b 	orr.w	r2, r2, fp
 8002c46:	661a      	str	r2, [r3, #96]	; 0x60
 8002c48:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  ST_ENABLE_STOP();
 8002c4a:	688b      	ldr	r3, [r1, #8]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8002c4c:	4a9f      	ldr	r2, [pc, #636]	; (8002ecc <main+0x43c>)
  tqp->prev = (thread_t *)tqp;
 8002c4e:	6064      	str	r4, [r4, #4]
 8002c50:	ea43 030b 	orr.w	r3, r3, fp
 8002c54:	608b      	str	r3, [r1, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8002c56:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002c5a:	f242 01cf 	movw	r1, #8399	; 0x20cf
 8002c5e:	6299      	str	r1, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8002c60:	f8c3 902c 	str.w	r9, [r3, #44]	; 0x2c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c64:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  ch.rlist.prio = NOPRIO;
 8002c68:	f8c4 8008 	str.w	r8, [r4, #8]
  STM32_ST_TIM->CCMR1  = 0;
 8002c6c:	f8c3 8018 	str.w	r8, [r3, #24]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8002c70:	6124      	str	r4, [r4, #16]
  STM32_ST_TIM->CCR[0] = 0;
 8002c72:	f8c3 8034 	str.w	r8, [r3, #52]	; 0x34
  ch.rlist.older = (thread_t *)&ch.rlist;
 8002c76:	6164      	str	r4, [r4, #20]
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8002c78:	f8c3 800c 	str.w	r8, [r3, #12]
  ch.vtlist.delta = (sysinterval_t)-1;
 8002c7c:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
  STM32_ST_TIM->CR2    = 0;
 8002c80:	f8c3 8004 	str.w	r8, [r3, #4]
  ch.vtlist.lasttime = (systime_t)0;
 8002c84:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002c88:	f8c3 b014 	str.w	fp, [r3, #20]
  H_NEXT(&default_heap.header) = NULL;
 8002c8c:	f8c2 8004 	str.w	r8, [r2, #4]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002c90:	f8c3 b000 	str.w	fp, [r3]
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8002c94:	f104 031c 	add.w	r3, r4, #28
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002c98:	f886 a31c 	strb.w	sl, [r6, #796]	; 0x31c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002c9c:	f8c6 1180 	str.w	r1, [r6, #384]	; 0x180
 8002ca0:	61e3      	str	r3, [r4, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ca2:	6031      	str	r1, [r6, #0]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 8002ca4:	498a      	ldr	r1, [pc, #552]	; (8002ed0 <main+0x440>)
 8002ca6:	6011      	str	r1, [r2, #0]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8002ca8:	6223      	str	r3, [r4, #32]
  ch_memcore.topmem  = __heap_end__;
 8002caa:	498a      	ldr	r1, [pc, #552]	; (8002ed4 <main+0x444>)
  tqp->next = (thread_t *)tqp;
 8002cac:	4b8a      	ldr	r3, [pc, #552]	; (8002ed8 <main+0x448>)
  ch_memcore.basemem = __heap_base__;
 8002cae:	f8c0 c000 	str.w	ip, [r0]
 8002cb2:	f102 060c 	add.w	r6, r2, #12
  ch_memcore.topmem  = __heap_end__;
 8002cb6:	6041      	str	r1, [r0, #4]
  tmp->cumulative = (rttime_t)0;
 8002cb8:	2000      	movs	r0, #0
 8002cba:	2100      	movs	r1, #0
  H_PAGES(&default_heap.header) = 0;
 8002cbc:	f8c2 8008 	str.w	r8, [r2, #8]
 8002cc0:	6024      	str	r4, [r4, #0]
 8002cc2:	60d6      	str	r6, [r2, #12]
 8002cc4:	e9cd 010e 	strd	r0, r1, [sp, #56]	; 0x38
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8002cc8:	f103 0010 	add.w	r0, r3, #16
 8002ccc:	f103 0c3c 	add.w	ip, r3, #60	; 0x3c
 8002cd0:	6118      	str	r0, [r3, #16]
 8002cd2:	f103 0040 	add.w	r0, r3, #64	; 0x40
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8002cd6:	2114      	movs	r1, #20
  tmp->last       = (rtcnt_t)0;
 8002cd8:	e9cd 880b 	strd	r8, r8, [sp, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
 8002cdc:	e9c3 3300 	strd	r3, r3, [r3]
 8002ce0:	e9c3 c00f 	strd	ip, r0, [r3, #60]	; 0x3c
 8002ce4:	6116      	str	r6, [r2, #16]
  tmp->best       = (rtcnt_t)-1;
 8002ce6:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
  mp->align = align;
 8002cea:	2604      	movs	r6, #4
 8002cec:	f103 0a24 	add.w	sl, r3, #36	; 0x24
 8002cf0:	f103 0928 	add.w	r9, r3, #40	; 0x28
  mp->owner = NULL;
 8002cf4:	f8c2 8014 	str.w	r8, [r2, #20]
  mp->object_size = size;
 8002cf8:	f04f 0e1c 	mov.w	lr, #28
  mp->provider = provider;
 8002cfc:	4a77      	ldr	r2, [pc, #476]	; (8002edc <main+0x44c>)
  mp->object_size = size;
 8002cfe:	6199      	str	r1, [r3, #24]
 8002d00:	f103 0144 	add.w	r1, r3, #68	; 0x44
  ch.tm.offset = (rtcnt_t)0;
 8002d04:	f8c4 8074 	str.w	r8, [r4, #116]	; 0x74
  tmp->n          = (ucnt_t)0;
 8002d08:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 8002d0c:	f8c3 8008 	str.w	r8, [r3, #8]
  mp->next = NULL;
 8002d10:	f8c3 8014 	str.w	r8, [r3, #20]
 8002d14:	f8c3 802c 	str.w	r8, [r3, #44]	; 0x2c
 8002d18:	f8c3 a024 	str.w	sl, [r3, #36]	; 0x24
 8002d1c:	f8c3 9028 	str.w	r9, [r3, #40]	; 0x28
  mp->object_size = size;
 8002d20:	f8c3 e030 	str.w	lr, [r3, #48]	; 0x30
 8002d24:	6459      	str	r1, [r3, #68]	; 0x44
  mp->align = align;
 8002d26:	61de      	str	r6, [r3, #28]
 8002d28:	635e      	str	r6, [r3, #52]	; 0x34
  mp->provider = provider;
 8002d2a:	621a      	str	r2, [r3, #32]
 8002d2c:	639a      	str	r2, [r3, #56]	; 0x38
    chTMStartMeasurementX(&tm);
 8002d2e:	a80a      	add	r0, sp, #40	; 0x28
 8002d30:	f7fd fcf6 	bl	8000720 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8002d34:	a80a      	add	r0, sp, #40	; 0x28
 8002d36:	f7fd fccb 	bl	80006d0 <chTMStopMeasurementX>
  } while (i > 0U);
 8002d3a:	3e01      	subs	r6, #1
 8002d3c:	d1f7      	bne.n	8002d2e <main+0x29e>
  REG_INSERT(tp);
 8002d3e:	4a68      	ldr	r2, [pc, #416]	; (8002ee0 <main+0x450>)
 8002d40:	f8d4 c014 	ldr.w	ip, [r4, #20]
  ch.tm.offset = tm.best;
 8002d44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002d46:	6763      	str	r3, [r4, #116]	; 0x74
  tp->prio      = prio;
 8002d48:	2080      	movs	r0, #128	; 0x80
  tp->refs      = (trefs_t)1;
 8002d4a:	2101      	movs	r1, #1
  tqp->next = (thread_t *)tqp;
 8002d4c:	f102 032c 	add.w	r3, r2, #44	; 0x2c
  tp->name      = name;
 8002d50:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 8002ef8 <main+0x468>
  tp->prio      = prio;
 8002d54:	63a0      	str	r0, [r4, #56]	; 0x38
  tlp->next = (thread_t *)tlp;
 8002d56:	f102 0e28 	add.w	lr, r2, #40	; 0x28
  tp->realprio  = prio;
 8002d5a:	66e0      	str	r0, [r4, #108]	; 0x6c
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002d5c:	f884 6051 	strb.w	r6, [r4, #81]	; 0x51
  tp->epending  = (eventmask_t)0;
 8002d60:	e9c4 6619 	strd	r6, r6, [r4, #100]	; 0x64
  REG_INSERT(tp);
 8002d64:	e9c4 4c10 	strd	r4, ip, [r4, #64]	; 0x40
  tp->refs      = (trefs_t)1;
 8002d68:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
  tp->name      = name;
 8002d6c:	f8c4 8048 	str.w	r8, [r4, #72]	; 0x48
 8002d70:	2020      	movs	r0, #32
  REG_INSERT(tp);
 8002d72:	f8cc 2010 	str.w	r2, [ip, #16]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8002d76:	e9c4 2205 	strd	r2, r2, [r4, #20]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8002d7a:	f884 1050 	strb.w	r1, [r4, #80]	; 0x50
  currp->wabase = NULL;
 8002d7e:	64e6      	str	r6, [r4, #76]	; 0x4c
  tqp->next = (thread_t *)tqp;
 8002d80:	e9c4 e316 	strd	lr, r3, [r4, #88]	; 0x58
  tqp->prev = (thread_t *)tqp;
 8002d84:	6623      	str	r3, [r4, #96]	; 0x60
 8002d86:	f380 8811 	msr	BASEPRI, r0
  __ASM volatile ("cpsie i" : : : "memory");
 8002d8a:	b662      	cpsie	i
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002d8c:	4b55      	ldr	r3, [pc, #340]	; (8002ee4 <main+0x454>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8002d8e:	f8df c16c 	ldr.w	ip, [pc, #364]	; 8002efc <main+0x46c>
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002d92:	f8d3 e00c 	ldr.w	lr, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002d96:	f64f 08ff 	movw	r8, #63743	; 0xf8ff
 8002d9a:	ea0e 0e08 	and.w	lr, lr, r8
  reg_value  =  (reg_value                                   |
 8002d9e:	ea4e 0c0c 	orr.w	ip, lr, ip
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002da2:	f8df e15c 	ldr.w	lr, [pc, #348]	; 8002f00 <main+0x470>
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8002da6:	f8c3 c00c 	str.w	ip, [r3, #12]
 8002daa:	f8de c00c 	ldr.w	ip, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8002dae:	f8df 8154 	ldr.w	r8, [pc, #340]	; 8002f04 <main+0x474>
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8002db2:	f04c 7c80 	orr.w	ip, ip, #16777216	; 0x1000000
 8002db6:	f8ce c00c 	str.w	ip, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8002dba:	f8d8 c000 	ldr.w	ip, [r8]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002dbe:	f04f 0e10 	mov.w	lr, #16
 8002dc2:	ea4c 0c01 	orr.w	ip, ip, r1
 8002dc6:	f8c8 c000 	str.w	ip, [r8]
 8002dca:	f883 e01f 	strb.w	lr, [r3, #31]
 8002dce:	f883 0022 	strb.w	r0, [r3, #34]	; 0x22
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002dd2:	f386 8811 	msr	BASEPRI, r6
  __ASM volatile ("cpsie i" : : : "memory");
 8002dd6:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002dd8:	f380 8811 	msr	BASEPRI, r0
  tp->wabase = tdp->wbase;
 8002ddc:	4b42      	ldr	r3, [pc, #264]	; (8002ee8 <main+0x458>)
  REG_INSERT(tp);
 8002dde:	6960      	ldr	r0, [r4, #20]
  tp->prio      = prio;
 8002de0:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
  tp->mtxlist   = NULL;
 8002de4:	e9c3 6132 	strd	r6, r1, [r3, #200]	; 0xc8
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002de8:	f883 10b2 	strb.w	r1, [r3, #178]	; 0xb2
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002dec:	f8df c118 	ldr.w	ip, [pc, #280]	; 8002f08 <main+0x478>
 8002df0:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8002f0c <main+0x47c>
  tp->name      = name;
 8002df4:	f8df e118 	ldr.w	lr, [pc, #280]	; 8002f10 <main+0x480>
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002df8:	f8c3 c06c 	str.w	ip, [r3, #108]	; 0x6c
 8002dfc:	f103 016c 	add.w	r1, r3, #108	; 0x6c
 8002e00:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
  REG_INSERT(tp);
 8002e04:	f103 0c90 	add.w	ip, r3, #144	; 0x90
  tp->state     = CH_STATE_WTSTART;
 8002e08:	2102      	movs	r1, #2
 8002e0a:	f8a3 10b0 	strh.w	r1, [r3, #176]	; 0xb0
  REG_INSERT(tp);
 8002e0e:	f8c3 00a4 	str.w	r0, [r3, #164]	; 0xa4
  tp->epending  = (eventmask_t)0;
 8002e12:	f8c3 60c4 	str.w	r6, [r3, #196]	; 0xc4
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002e16:	f8c3 808c 	str.w	r8, [r3, #140]	; 0x8c
  tp->name      = name;
 8002e1a:	f8c3 e0a8 	str.w	lr, [r3, #168]	; 0xa8
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002e1e:	671e      	str	r6, [r3, #112]	; 0x70
  REG_INSERT(tp);
 8002e20:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
  tp->wabase = tdp->wbase;
 8002e24:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  REG_INSERT(tp);
 8002e28:	f8c0 c010 	str.w	ip, [r0, #16]
  thread_t *otp = currp;
 8002e2c:	69a0      	ldr	r0, [r4, #24]
  ntp->u.rdymsg = msg;
 8002e2e:	f8c3 60b4 	str.w	r6, [r3, #180]	; 0xb4
  if (ntp->prio <= otp->prio) {
 8002e32:	f8d0 e008 	ldr.w	lr, [r0, #8]
 8002e36:	f8c4 c014 	str.w	ip, [r4, #20]
  tqp->next = (thread_t *)tqp;
 8002e3a:	f103 01bc 	add.w	r1, r3, #188	; 0xbc
  tlp->next = (thread_t *)tlp;
 8002e3e:	f103 08b8 	add.w	r8, r3, #184	; 0xb8
  tqp->next = (thread_t *)tqp;
 8002e42:	e9c3 812e 	strd	r8, r1, [r3, #184]	; 0xb8
  tqp->prev = (thread_t *)tqp;
 8002e46:	f8c3 10c0 	str.w	r1, [r3, #192]	; 0xc0
 8002e4a:	f1be 0f00 	cmp.w	lr, #0
 8002e4e:	f000 8171 	beq.w	8003134 <main+0x6a4>
  tp->state = CH_STATE_READY;
 8002e52:	f883 60b0 	strb.w	r6, [r3, #176]	; 0xb0
  cp = (thread_t *)&ch.rlist.queue;
 8002e56:	3a30      	subs	r2, #48	; 0x30
    cp = cp->queue.next;
 8002e58:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8002e5a:	6891      	ldr	r1, [r2, #8]
 8002e5c:	2900      	cmp	r1, #0
 8002e5e:	d1fb      	bne.n	8002e58 <main+0x3c8>
  tp->queue.next             = cp;
 8002e60:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  tp->queue.prev             = cp->queue.prev;
 8002e64:	6851      	ldr	r1, [r2, #4]
 8002e66:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
  tp->queue.prev->queue.next = tp;
 8002e6a:	f8c1 c000 	str.w	ip, [r1]
  cp->queue.prev             = tp;
 8002e6e:	f8c2 c004 	str.w	ip, [r2, #4]
 8002e72:	2300      	movs	r3, #0
 8002e74:	f383 8811 	msr	BASEPRI, r3
 8002e78:	2320      	movs	r3, #32
 8002e7a:	f383 8811 	msr	BASEPRI, r3
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8002e7e:	7a2b      	ldrb	r3, [r5, #8]
 8002e80:	2b01      	cmp	r3, #1
 8002e82:	f000 8222 	beq.w	80032ca <main+0x83a>
  USART_TypeDef *u = sdp->usart;
 8002e86:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8002e88:	4a18      	ldr	r2, [pc, #96]	; (8002eec <main+0x45c>)
 8002e8a:	4293      	cmp	r3, r2
 8002e8c:	f000 81c5 	beq.w	800321a <main+0x78a>
 8002e90:	4809      	ldr	r0, [pc, #36]	; (8002eb8 <main+0x428>)
    fck = STM32_PCLK2 / config->speed;
 8002e92:	f240 4245 	movw	r2, #1093	; 0x445
 8002e96:	f640 018b 	movw	r1, #2187	; 0x88b
 8002e9a:	4283      	cmp	r3, r0
 8002e9c:	bf08      	it	eq
 8002e9e:	460a      	moveq	r2, r1
 8002ea0:	e038      	b.n	8002f14 <main+0x484>
 8002ea2:	bf00      	nop
 8002ea4:	e000e100 	.word	0xe000e100
 8002ea8:	40026400 	.word	0x40026400
 8002eac:	20000808 	.word	0x20000808
 8002eb0:	08004634 	.word	0x08004634
 8002eb4:	080004f1 	.word	0x080004f1
 8002eb8:	40011400 	.word	0x40011400
 8002ebc:	40023800 	.word	0x40023800
 8002ec0:	e0042000 	.word	0xe0042000
 8002ec4:	20000d04 	.word	0x20000d04
 8002ec8:	20000ea0 	.word	0x20000ea0
 8002ecc:	200010d0 	.word	0x200010d0
 8002ed0:	080004b1 	.word	0x080004b1
 8002ed4:	20020000 	.word	0x20020000
 8002ed8:	20000d7c 	.word	0x20000d7c
 8002edc:	080006a1 	.word	0x080006a1
 8002ee0:	20000d34 	.word	0x20000d34
 8002ee4:	e000ed00 	.word	0xe000ed00
 8002ee8:	20000dc8 	.word	0x20000dc8
 8002eec:	40011000 	.word	0x40011000
 8002ef0:	40026000 	.word	0x40026000
 8002ef4:	20001770 	.word	0x20001770
 8002ef8:	080040c4 	.word	0x080040c4
 8002efc:	05fa0300 	.word	0x05fa0300
 8002f00:	e000edf0 	.word	0xe000edf0
 8002f04:	e0001000 	.word	0xe0001000
 8002f08:	08000831 	.word	0x08000831
 8002f0c:	080002d1 	.word	0x080002d1
 8002f10:	080043e0 	.word	0x080043e0
  u->BRR = fck;
 8002f14:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002f16:	2040      	movs	r0, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002f18:	2101      	movs	r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002f1a:	f242 122c 	movw	r2, #8492	; 0x212c
  u->SR = 0;
 8002f1e:	2400      	movs	r4, #0
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8002f20:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002f22:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002f24:	60da      	str	r2, [r3, #12]
  u->SR = 0;
 8002f26:	601c      	str	r4, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8002f28:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8002f2a:	685b      	ldr	r3, [r3, #4]
    sdp->rxmask = 0xFF;
 8002f2c:	22ff      	movs	r2, #255	; 0xff

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8002f2e:	2302      	movs	r3, #2
 8002f30:	f885 2078 	strb.w	r2, [r5, #120]	; 0x78
 8002f34:	722b      	strb	r3, [r5, #8]
 8002f36:	f384 8811 	msr	BASEPRI, r4
  palSetPadMode(GPIOC,6U,PAL_MODE_ALTERNATE(8));
 8002f3a:	f7fd fa71 	bl	8000420 <_pal_lld_setgroupmode.constprop.21>
  palSetPadMode(GPIOC,7U,PAL_MODE_ALTERNATE(8));
 8002f3e:	2080      	movs	r0, #128	; 0x80
 8002f40:	f7fd fa6e 	bl	8000420 <_pal_lld_setgroupmode.constprop.21>
   */
  halInit();
  chSysInit();

  initUART();
  myPrintf("Bismillah\r\n");
 8002f44:	48b6      	ldr	r0, [pc, #728]	; (8003220 <main+0x790>)
 8002f46:	f7fe fd0b 	bl	8001960 <myPrintf>
 8002f4a:	f7fd fcd9 	bl	8000900 <sdc_lld_init>
 8002f4e:	2320      	movs	r3, #32
 8002f50:	f383 8811 	msr	BASEPRI, r3
  sdcp->config = config;
 8002f54:	4db3      	ldr	r5, [pc, #716]	; (8003224 <main+0x794>)
 8002f56:	49b4      	ldr	r1, [pc, #720]	; (8003228 <main+0x798>)
  if (sdcp->state == BLK_STOP) {
 8002f58:	792b      	ldrb	r3, [r5, #4]
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
 8002f5a:	4ab4      	ldr	r2, [pc, #720]	; (800322c <main+0x79c>)
 8002f5c:	62e9      	str	r1, [r5, #44]	; 0x2c
  if (sdcp->state == BLK_STOP) {
 8002f5e:	2b01      	cmp	r3, #1
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
 8002f60:	642a      	str	r2, [r5, #64]	; 0x40
  if (sdcp->state == BLK_STOP) {
 8002f62:	f000 8153 	beq.w	800320c <main+0x77c>
  sdcp->sdio->POWER  = 0;
 8002f66:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8002f68:	2400      	movs	r4, #0
  sdcp->state = BLK_ACTIVE;
 8002f6a:	2202      	movs	r2, #2
 8002f6c:	601c      	str	r4, [r3, #0]
  sdcp->sdio->CLKCR  = 0;
 8002f6e:	605c      	str	r4, [r3, #4]
  sdcp->sdio->DCTRL  = 0;
 8002f70:	62dc      	str	r4, [r3, #44]	; 0x2c
 8002f72:	712a      	strb	r2, [r5, #4]
  sdcp->sdio->DTIMER = 0;
 8002f74:	625c      	str	r4, [r3, #36]	; 0x24
 8002f76:	f384 8811 	msr	BASEPRI, r4
  sdcConnect(&SDCD1);
 8002f7a:	48aa      	ldr	r0, [pc, #680]	; (8003224 <main+0x794>)
 8002f7c:	f7fe fef8 	bl	8001d70 <sdcConnect>
  myPrintf("OK\r\n\r\nCard Info\r\n");
 8002f80:	48ab      	ldr	r0, [pc, #684]	; (8003230 <main+0x7a0>)
 8002f82:	f7fe fced 	bl	8001960 <myPrintf>
  myPrintf("CSD      : %08X %8X %08X %08X \r\n",
 8002f86:	69a8      	ldr	r0, [r5, #24]
 8002f88:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8002f8a:	e9d5 3207 	ldrd	r3, r2, [r5, #28]
 8002f8e:	9000      	str	r0, [sp, #0]
 8002f90:	48a8      	ldr	r0, [pc, #672]	; (8003234 <main+0x7a4>)
 8002f92:	f7fe fce5 	bl	8001960 <myPrintf>
  myPrintf("CID      : %08X %8X %08X %08X \r\n",
 8002f96:	68a8      	ldr	r0, [r5, #8]
 8002f98:	6969      	ldr	r1, [r5, #20]
 8002f9a:	e9d5 3203 	ldrd	r3, r2, [r5, #12]
 8002f9e:	9000      	str	r0, [sp, #0]
 8002fa0:	48a5      	ldr	r0, [pc, #660]	; (8003238 <main+0x7a8>)
 8002fa2:	f7fe fcdd 	bl	8001960 <myPrintf>
  myPrintf("Capacity : %DMB\r\n", SDCD1.capacity / 2048);
 8002fa6:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8002fa8:	48a4      	ldr	r0, [pc, #656]	; (800323c <main+0x7ac>)
 8002faa:	0ac9      	lsrs	r1, r1, #11
 8002fac:	f7fe fcd8 	bl	8001960 <myPrintf>
 8002fb0:	4ba3      	ldr	r3, [pc, #652]	; (8003240 <main+0x7b0>)
 8002fb2:	4aa4      	ldr	r2, [pc, #656]	; (8003244 <main+0x7b4>)
 8002fb4:	9209      	str	r2, [sp, #36]	; 0x24
	FRESULT res;
	const TCHAR *rp = path;


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 8002fb6:	a80a      	add	r0, sp, #40	; 0x28
 8002fb8:	9308      	str	r3, [sp, #32]
	const TCHAR *rp = path;
 8002fba:	930a      	str	r3, [sp, #40]	; 0x28
	vol = get_ldnumber(&rp);
 8002fbc:	f7fd fb08 	bl	80005d0 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8002fc0:	2800      	cmp	r0, #0
 8002fc2:	db0f      	blt.n	8002fe4 <main+0x554>
	cfs = FatFs[vol];					/* Pointer to fs object */
 8002fc4:	4da0      	ldr	r5, [pc, #640]	; (8003248 <main+0x7b8>)
 8002fc6:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]

	if (cfs) {
 8002fca:	b103      	cbz	r3, 8002fce <main+0x53e>
		clear_lock(cfs);
#endif
#if FF_FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 8002fcc:	701c      	strb	r4, [r3, #0]
	}

	if (fs) {
 8002fce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002fd0:	b10b      	cbz	r3, 8002fd6 <main+0x546>
		fs->fs_type = 0;				/* Clear new fs object */
 8002fd2:	2200      	movs	r2, #0
 8002fd4:	701a      	strb	r2, [r3, #0]
#if FF_FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 8002fd6:	f845 3020 	str.w	r3, [r5, r0, lsl #2]

	if (opt == 0) return FR_OK;			/* Do not mount now, it will be mounted later */

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 8002fda:	2200      	movs	r2, #0
 8002fdc:	a909      	add	r1, sp, #36	; 0x24
 8002fde:	a808      	add	r0, sp, #32
 8002fe0:	f7fe fae6 	bl	80015b0 <find_volume>
 8002fe4:	4b99      	ldr	r3, [pc, #612]	; (800324c <main+0x7bc>)
 8002fe6:	9307      	str	r3, [sp, #28]

	if (!fp) return FR_INVALID_OBJECT;

	/* Get logical drive number */
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
	res = find_volume(&path, &fs, mode);
 8002fe8:	2201      	movs	r2, #1
 8002fea:	a906      	add	r1, sp, #24
 8002fec:	a807      	add	r0, sp, #28
 8002fee:	f7fe fadf 	bl	80015b0 <find_volume>
	if (res == FR_OK) {
 8002ff2:	2800      	cmp	r0, #0
 8002ff4:	f000 8196 	beq.w	8003324 <main+0x894>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8002ff8:	4d95      	ldr	r5, [pc, #596]	; (8003250 <main+0x7c0>)
 8002ffa:	46aa      	mov	sl, r5
 8002ffc:	2300      	movs	r3, #0
 8002ffe:	f84a 3b28 	str.w	r3, [sl], #40
 8003002:	696a      	ldr	r2, [r5, #20]
 8003004:	68ef      	ldr	r7, [r5, #12]
 8003006:	f8df b25c 	ldr.w	fp, [pc, #604]	; 8003264 <main+0x7d4>
 800300a:	f8cd a00c 	str.w	sl, [sp, #12]

  initSdCard(&sdccfg, &SDC_FS);

  f_open(&currentFile,FILE_NAME,FA_READ);

  uint32_t crc = -1;
 800300e:	f04f 34ff 	mov.w	r4, #4294967295

  while(!f_eof(&currentFile))
 8003012:	42ba      	cmp	r2, r7
 8003014:	f000 8085 	beq.w	8003122 <main+0x692>
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8003018:	f8d5 9000 	ldr.w	r9, [r5]
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 800301c:	2300      	movs	r3, #0
 800301e:	930a      	str	r3, [sp, #40]	; 0x28
	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 8003020:	f1b9 0f00 	cmp.w	r9, #0
 8003024:	d0f5      	beq.n	8003012 <main+0x582>
 8003026:	f899 3000 	ldrb.w	r3, [r9]
 800302a:	2b00      	cmp	r3, #0
 800302c:	d0f1      	beq.n	8003012 <main+0x582>
 800302e:	88a9      	ldrh	r1, [r5, #4]
 8003030:	f8b9 3006 	ldrh.w	r3, [r9, #6]
 8003034:	4299      	cmp	r1, r3
 8003036:	d1ec      	bne.n	8003012 <main+0x582>
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8003038:	f899 0001 	ldrb.w	r0, [r9, #1]
 800303c:	f7fd faf8 	bl	8000630 <disk_initialize>
 8003040:	07c0      	lsls	r0, r0, #31
 8003042:	d4e6      	bmi.n	8003012 <main+0x582>
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8003044:	7c6b      	ldrb	r3, [r5, #17]
 8003046:	2b00      	cmp	r3, #0
 8003048:	d1e3      	bne.n	8003012 <main+0x582>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 800304a:	7c2b      	ldrb	r3, [r5, #16]
 800304c:	07d9      	lsls	r1, r3, #31
 800304e:	d5e0      	bpl.n	8003012 <main+0x582>
	remain = fp->obj.objsize - fp->fptr;
 8003050:	eba7 0802 	sub.w	r8, r7, r2
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 8003054:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
 8003058:	f8df a1f8 	ldr.w	sl, [pc, #504]	; 8003254 <main+0x7c4>
 800305c:	bf28      	it	cs
 800305e:	f44f 6880 	movcs.w	r8, #1024	; 0x400

	for ( ;  btr;								/* Repeat until btr bytes read */
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 8003062:	f3c2 0108 	ubfx	r1, r2, #0, #9
 8003066:	2900      	cmp	r1, #0
 8003068:	f040 808e 	bne.w	8003188 <main+0x6f8>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 800306c:	f8b9 300a 	ldrh.w	r3, [r9, #10]
 8003070:	3b01      	subs	r3, #1
			if (csect == 0) {					/* On the cluster boundary? */
 8003072:	ea13 2352 	ands.w	r3, r3, r2, lsr #9
 8003076:	f040 809e 	bne.w	80031b6 <main+0x726>
				if (fp->fptr == 0) {			/* On the top of the file? */
 800307a:	2a00      	cmp	r2, #0
 800307c:	f040 81f0 	bne.w	8003460 <main+0x9d0>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8003080:	68a8      	ldr	r0, [r5, #8]
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8003082:	2801      	cmp	r0, #1
 8003084:	f240 809f 	bls.w	80031c6 <main+0x736>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8003088:	1c42      	adds	r2, r0, #1
 800308a:	d021      	beq.n	80030d0 <main+0x640>
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 800308c:	f8d9 2018 	ldr.w	r2, [r9, #24]
				fp->clust = clst;				/* Update current cluster */
 8003090:	61a8      	str	r0, [r5, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 8003092:	1e86      	subs	r6, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 8003094:	3a02      	subs	r2, #2
 8003096:	4296      	cmp	r6, r2
 8003098:	f080 8095 	bcs.w	80031c6 <main+0x736>
	return fs->database + fs->csize * clst;		/* Start sector number of the cluster */
 800309c:	f8b9 200a 	ldrh.w	r2, [r9, #10]
 80030a0:	f8d9 102c 	ldr.w	r1, [r9, #44]	; 0x2c
 80030a4:	fb02 1606 	mla	r6, r2, r6, r1
			}
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
			if (sect == 0) ABORT(fs, FR_INT_ERR);
 80030a8:	2e00      	cmp	r6, #0
 80030aa:	f000 808c 	beq.w	80031c6 <main+0x736>
			sect += csect;
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 80030ae:	ea5f 2758 	movs.w	r7, r8, lsr #9
			sect += csect;
 80030b2:	441e      	add	r6, r3
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
 80030b4:	d054      	beq.n	8003160 <main+0x6d0>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 80030b6:	19d9      	adds	r1, r3, r7
 80030b8:	428a      	cmp	r2, r1
					cc = fs->csize - csect;
 80030ba:	bf38      	it	cc
 80030bc:	1ad7      	subcc	r7, r2, r3
				}
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80030be:	463b      	mov	r3, r7
 80030c0:	4632      	mov	r2, r6
 80030c2:	4651      	mov	r1, sl
 80030c4:	f899 0001 	ldrb.w	r0, [r9, #1]
 80030c8:	f7fe f88a 	bl	80011e0 <disk_read>
 80030cc:	2800      	cmp	r0, #0
 80030ce:	d07d      	beq.n	80031cc <main+0x73c>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 80030d0:	f04f 0301 	mov.w	r3, #1
 80030d4:	746b      	strb	r3, [r5, #17]
  {
    f_read(&currentFile, readBuff, buffSize, &bytesRead);
    if(!f_eof(&currentFile))
 80030d6:	696a      	ldr	r2, [r5, #20]
 80030d8:	68ef      	ldr	r7, [r5, #12]
 80030da:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
 80030de:	42ba      	cmp	r2, r7
 80030e0:	f040 8106 	bne.w	80032f0 <main+0x860>
uint32_t crc32_update(const void *data, unsigned int length, uint32_t crc)
{
   const unsigned char *buf = (const unsigned char *)data;
   uint16_t i;

   for (i = 0; i < length; ++i)
 80030e4:	b1ab      	cbz	r3, 8003112 <main+0x682>
 80030e6:	485b      	ldr	r0, [pc, #364]	; (8003254 <main+0x7c4>)
 80030e8:	3b01      	subs	r3, #1
 80030ea:	1c41      	adds	r1, r0, #1
 80030ec:	fa11 f183 	uxtah	r1, r1, r3
   {
      crc ^= buf[i];
 80030f0:	f810 3b01 	ldrb.w	r3, [r0], #1
 80030f4:	405c      	eors	r4, r3
      crc = crc32tab[crc & 0x0f] ^ (crc >> 4);
 80030f6:	f004 030f 	and.w	r3, r4, #15
   for (i = 0; i < length; ++i)
 80030fa:	4288      	cmp	r0, r1
      crc = crc32tab[crc & 0x0f] ^ (crc >> 4);
 80030fc:	f85b 3023 	ldr.w	r3, [fp, r3, lsl #2]
 8003100:	ea83 1314 	eor.w	r3, r3, r4, lsr #4
      crc = crc32tab[crc & 0x0f] ^ (crc >> 4);
 8003104:	f003 040f 	and.w	r4, r3, #15
 8003108:	f85b 4024 	ldr.w	r4, [fp, r4, lsl #2]
 800310c:	ea84 1413 	eor.w	r4, r4, r3, lsr #4
   for (i = 0; i < length; ++i)
 8003110:	d1ee      	bne.n	80030f0 <main+0x660>


/* calculates final crc value, crc is 0xffffffff initially if no prev crc exist */
uint32_t crc32_final(const void *data, unsigned int length, uint32_t crc)
{
   return crc32_update(data, length, crc) ^ 0xffffffff;
 8003112:	4613      	mov	r3, r2
 8003114:	463a      	mov	r2, r7
 8003116:	461f      	mov	r7, r3
  while(!f_eof(&currentFile))
 8003118:	42ba      	cmp	r2, r7
 800311a:	ea6f 0404 	mvn.w	r4, r4
 800311e:	f47f af7b 	bne.w	8003018 <main+0x588>
    {
      crc = crc32_final(readBuff,bytesRead,crc);
    }
  }

  myPrintf("0x%X\r\n",crc);
 8003122:	4621      	mov	r1, r4
 8003124:	484c      	ldr	r0, [pc, #304]	; (8003258 <main+0x7c8>)
 8003126:	f7fe fc1b 	bl	8001960 <myPrintf>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 800312a:	f241 3088 	movw	r0, #5000	; 0x1388
 800312e:	f7fd fe37 	bl	8000da0 <chThdSleep>
 8003132:	e7fa      	b.n	800312a <main+0x69a>
  tp->state = CH_STATE_READY;
 8003134:	f880 6020 	strb.w	r6, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8003138:	3a30      	subs	r2, #48	; 0x30
    cp = cp->queue.next;
 800313a:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio > tp->prio);
 800313c:	6891      	ldr	r1, [r2, #8]
 800313e:	2900      	cmp	r1, #0
 8003140:	d1fb      	bne.n	800313a <main+0x6aa>
  tp->queue.prev             = cp->queue.prev;
 8003142:	6851      	ldr	r1, [r2, #4]
 8003144:	e9c0 2100 	strd	r2, r1, [r0]
  tp->queue.prev->queue.next = tp;
 8003148:	6008      	str	r0, [r1, #0]
  cp->queue.prev             = tp;
 800314a:	6050      	str	r0, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
 800314c:	2201      	movs	r2, #1
    chSysSwitch(ntp, otp);
 800314e:	4601      	mov	r1, r0
    ntp->state = CH_STATE_CURRENT;
 8003150:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
    chSysSwitch(ntp, otp);
 8003154:	4841      	ldr	r0, [pc, #260]	; (800325c <main+0x7cc>)
    currp = ntp;
 8003156:	f8c4 c018 	str.w	ip, [r4, #24]
    chSysSwitch(ntp, otp);
 800315a:	f7fd f8b1 	bl	80002c0 <_port_switch>
 800315e:	e688      	b.n	8002e72 <main+0x3e2>
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
				continue;
			}
#if !FF_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 8003160:	69ea      	ldr	r2, [r5, #28]
 8003162:	4296      	cmp	r6, r2
 8003164:	d00c      	beq.n	8003180 <main+0x6f0>
#if !FF_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8003166:	f995 3010 	ldrsb.w	r3, [r5, #16]
 800316a:	f899 0001 	ldrb.w	r0, [r9, #1]
 800316e:	2b00      	cmp	r3, #0
 8003170:	db32      	blt.n	80031d8 <main+0x748>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
					fp->flag &= (BYTE)~FA_DIRTY;
				}
#endif
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8003172:	2301      	movs	r3, #1
 8003174:	4632      	mov	r2, r6
 8003176:	493a      	ldr	r1, [pc, #232]	; (8003260 <main+0x7d0>)
 8003178:	f7fe f832 	bl	80011e0 <disk_read>
 800317c:	2800      	cmp	r0, #0
 800317e:	d1a7      	bne.n	80030d0 <main+0x640>
 8003180:	6969      	ldr	r1, [r5, #20]
			}
#endif
			fp->sect = sect;
 8003182:	61ee      	str	r6, [r5, #28]
 8003184:	f3c1 0108 	ubfx	r1, r1, #0, #9
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8003188:	f5c1 7700 	rsb	r7, r1, #512	; 0x200
 800318c:	4547      	cmp	r7, r8
 800318e:	9b03      	ldr	r3, [sp, #12]
 8003190:	bf28      	it	cs
 8003192:	4647      	movcs	r7, r8
 8003194:	4419      	add	r1, r3
 8003196:	463a      	mov	r2, r7
 8003198:	4650      	mov	r0, sl
 800319a:	f7fd fa09 	bl	80005b0 <mem_cpy.part.0>
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 800319e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80031a0:	696a      	ldr	r2, [r5, #20]
 80031a2:	443b      	add	r3, r7
 80031a4:	443a      	add	r2, r7
	for ( ;  btr;								/* Repeat until btr bytes read */
 80031a6:	ebb8 0807 	subs.w	r8, r8, r7
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 80031aa:	44ba      	add	sl, r7
 80031ac:	930a      	str	r3, [sp, #40]	; 0x28
 80031ae:	616a      	str	r2, [r5, #20]
	for ( ;  btr;								/* Repeat until btr bytes read */
 80031b0:	f47f af57 	bne.w	8003062 <main+0x5d2>
 80031b4:	e78f      	b.n	80030d6 <main+0x646>
 80031b6:	69a8      	ldr	r0, [r5, #24]
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 80031b8:	f8d9 2018 	ldr.w	r2, [r9, #24]
	clst -= 2;		/* Cluster number is origin from 2 */
 80031bc:	1e86      	subs	r6, r0, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
 80031be:	3a02      	subs	r2, #2
 80031c0:	4296      	cmp	r6, r2
 80031c2:	f4ff af6b 	bcc.w	800309c <main+0x60c>
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 80031c6:	2302      	movs	r3, #2
 80031c8:	746b      	strb	r3, [r5, #17]
 80031ca:	e784      	b.n	80030d6 <main+0x646>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 80031cc:	f995 3010 	ldrsb.w	r3, [r5, #16]
 80031d0:	2b00      	cmp	r3, #0
 80031d2:	db0f      	blt.n	80031f4 <main+0x764>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 80031d4:	027f      	lsls	r7, r7, #9
 80031d6:	e7e2      	b.n	800319e <main+0x70e>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80031d8:	2301      	movs	r3, #1
 80031da:	4921      	ldr	r1, [pc, #132]	; (8003260 <main+0x7d0>)
 80031dc:	f7fd ff18 	bl	8001010 <disk_write>
 80031e0:	2800      	cmp	r0, #0
 80031e2:	f47f af75 	bne.w	80030d0 <main+0x640>
					fp->flag &= (BYTE)~FA_DIRTY;
 80031e6:	7c2b      	ldrb	r3, [r5, #16]
 80031e8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80031ec:	742b      	strb	r3, [r5, #16]
 80031ee:	f899 0001 	ldrb.w	r0, [r9, #1]
 80031f2:	e7be      	b.n	8003172 <main+0x6e2>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 80031f4:	69e8      	ldr	r0, [r5, #28]
 80031f6:	1b80      	subs	r0, r0, r6
 80031f8:	4287      	cmp	r7, r0
 80031fa:	d9eb      	bls.n	80031d4 <main+0x744>
 80031fc:	eb0a 2040 	add.w	r0, sl, r0, lsl #9
 8003200:	f44f 7200 	mov.w	r2, #512	; 0x200
 8003204:	4916      	ldr	r1, [pc, #88]	; (8003260 <main+0x7d0>)
 8003206:	f7fd f9d3 	bl	80005b0 <mem_cpy.part.0>
 800320a:	e7e3      	b.n	80031d4 <main+0x744>
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
    if ((dma.allocated_mask & mask) == 0U) {
 800320c:	683b      	ldr	r3, [r7, #0]
 800320e:	f413 6000 	ands.w	r0, r3, #2048	; 0x800
 8003212:	d029      	beq.n	8003268 <main+0x7d8>
    sdcp->dma = dmaStreamAllocI(STM32_SDC_SDIO_DMA_STREAM,
 8003214:	646c      	str	r4, [r5, #68]	; 0x44
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdio->FIFO);
 8003216:	6823      	ldr	r3, [r4, #0]
 8003218:	deff      	udf	#255	; 0xff
    fck = STM32_PCLK2 / config->speed;
 800321a:	f640 028b 	movw	r2, #2187	; 0x88b
 800321e:	e679      	b.n	8002f14 <main+0x484>
 8003220:	080043e8 	.word	0x080043e8
 8003224:	20000884 	.word	0x20000884
 8003228:	08004530 	.word	0x08004530
 800322c:	08a35420 	.word	0x08a35420
 8003230:	080043f4 	.word	0x080043f4
 8003234:	08004408 	.word	0x08004408
 8003238:	0800442c 	.word	0x0800442c
 800323c:	08004450 	.word	0x08004450
 8003240:	08004464 	.word	0x08004464
 8003244:	20000ad0 	.word	0x20000ad0
 8003248:	20000800 	.word	0x20000800
 800324c:	08004468 	.word	0x08004468
 8003250:	20000ea8 	.word	0x20000ea8
 8003254:	20001170 	.word	0x20001170
 8003258:	0800447c 	.word	0x0800447c
 800325c:	20000e58 	.word	0x20000e58
 8003260:	20000ed0 	.word	0x20000ed0
 8003264:	080040e4 	.word	0x080040e4
      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
        rccEnableDMA1(true);
      }
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
        rccEnableDMA2(true);
 8003268:	4abc      	ldr	r2, [pc, #752]	; (800355c <main+0xacc>)
      dma.allocated_mask  |= mask;
 800326a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800326e:	603b      	str	r3, [r7, #0]
        rccEnableDMA2(true);
 8003270:	6b13      	ldr	r3, [r2, #48]	; 0x30
      dma.streams[i].func  = func;
 8003272:	65f8      	str	r0, [r7, #92]	; 0x5c
        rccEnableDMA2(true);
 8003274:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8003278:	6313      	str	r3, [r2, #48]	; 0x30
 800327a:	6d11      	ldr	r1, [r2, #80]	; 0x50
        rccEnableDMAMUX(true);
      }
#endif

      /* Putting the stream in a safe state.*/
      dmaStreamDisable(dmastp);
 800327c:	4bb8      	ldr	r3, [pc, #736]	; (8003560 <main+0xad0>)
      dma.streams[i].param = param;
 800327e:	6638      	str	r0, [r7, #96]	; 0x60
        rccEnableDMA2(true);
 8003280:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
 8003284:	6511      	str	r1, [r2, #80]	; 0x50
 8003286:	6d12      	ldr	r2, [r2, #80]	; 0x50
      dmaStreamDisable(dmastp);
 8003288:	681a      	ldr	r2, [r3, #0]
 800328a:	f022 021f 	bic.w	r2, r2, #31
 800328e:	601a      	str	r2, [r3, #0]
 8003290:	6819      	ldr	r1, [r3, #0]
 8003292:	f011 0101 	ands.w	r1, r1, #1
 8003296:	d1fb      	bne.n	8003290 <main+0x800>
 8003298:	6ca8      	ldr	r0, [r5, #72]	; 0x48
 800329a:	4cb2      	ldr	r4, [pc, #712]	; (8003564 <main+0xad4>)
    rccEnableSDIO(true);
 800329c:	4aaf      	ldr	r2, [pc, #700]	; (800355c <main+0xacc>)
 800329e:	f04f 6674 	mov.w	r6, #255852544	; 0xf400000
 80032a2:	6026      	str	r6, [r4, #0]
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdio->FIFO);
 80032a4:	3080      	adds	r0, #128	; 0x80
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 80032a6:	6019      	str	r1, [r3, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 80032a8:	2421      	movs	r4, #33	; 0x21
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
 80032aa:	2107      	movs	r1, #7
 80032ac:	615c      	str	r4, [r3, #20]
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdio->FIFO);
 80032ae:	6098      	str	r0, [r3, #8]
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
 80032b0:	6159      	str	r1, [r3, #20]
    rccEnableSDIO(true);
 80032b2:	6c53      	ldr	r3, [r2, #68]	; 0x44
    sdcp->dma = dmaStreamAllocI(STM32_SDC_SDIO_DMA_STREAM,
 80032b4:	49ac      	ldr	r1, [pc, #688]	; (8003568 <main+0xad8>)
 80032b6:	6469      	str	r1, [r5, #68]	; 0x44
    rccEnableSDIO(true);
 80032b8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80032bc:	6453      	str	r3, [r2, #68]	; 0x44
 80032be:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80032c0:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80032c4:	6653      	str	r3, [r2, #100]	; 0x64
 80032c6:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80032c8:	e64d      	b.n	8002f66 <main+0x4d6>
      nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART6
    if (&SD6 == sdp) {
      rccEnableUSART6(true);
 80032ca:	4ba4      	ldr	r3, [pc, #656]	; (800355c <main+0xacc>)
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80032cc:	4aa7      	ldr	r2, [pc, #668]	; (800356c <main+0xadc>)
 80032ce:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80032d0:	f041 0120 	orr.w	r1, r1, #32
 80032d4:	6459      	str	r1, [r3, #68]	; 0x44
 80032d6:	6e59      	ldr	r1, [r3, #100]	; 0x64
 80032d8:	f041 0120 	orr.w	r1, r1, #32
 80032dc:	6659      	str	r1, [r3, #100]	; 0x64
 80032de:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80032e0:	21c0      	movs	r1, #192	; 0xc0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80032e2:	2380      	movs	r3, #128	; 0x80
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80032e4:	f882 1347 	strb.w	r1, [r2, #839]	; 0x347
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80032e8:	f8c2 3188 	str.w	r3, [r2, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80032ec:	6093      	str	r3, [r2, #8]
 80032ee:	e5ca      	b.n	8002e86 <main+0x3f6>
   for (i = 0; i < length; ++i)
 80032f0:	2b00      	cmp	r3, #0
 80032f2:	f43f ae8e 	beq.w	8003012 <main+0x582>
 80032f6:	489e      	ldr	r0, [pc, #632]	; (8003570 <main+0xae0>)
 80032f8:	3b01      	subs	r3, #1
 80032fa:	1c41      	adds	r1, r0, #1
 80032fc:	fa11 f183 	uxtah	r1, r1, r3
      crc ^= buf[i];
 8003300:	f810 3b01 	ldrb.w	r3, [r0], #1
 8003304:	405c      	eors	r4, r3
      crc = crc32tab[crc & 0x0f] ^ (crc >> 4);
 8003306:	f004 030f 	and.w	r3, r4, #15
   for (i = 0; i < length; ++i)
 800330a:	4288      	cmp	r0, r1
      crc = crc32tab[crc & 0x0f] ^ (crc >> 4);
 800330c:	f85b 3023 	ldr.w	r3, [fp, r3, lsl #2]
 8003310:	ea83 1314 	eor.w	r3, r3, r4, lsr #4
      crc = crc32tab[crc & 0x0f] ^ (crc >> 4);
 8003314:	f003 040f 	and.w	r4, r3, #15
 8003318:	f85b 4024 	ldr.w	r4, [fp, r4, lsl #2]
 800331c:	ea84 1413 	eor.w	r4, r4, r3, lsr #4
   for (i = 0; i < length; ++i)
 8003320:	d1ee      	bne.n	8003300 <main+0x870>
 8003322:	e676      	b.n	8003012 <main+0x582>
		dj.obj.fs = fs;
 8003324:	9b06      	ldr	r3, [sp, #24]
 8003326:	930a      	str	r3, [sp, #40]	; 0x28
 8003328:	f44f 7000 	mov.w	r0, #512	; 0x200
 800332c:	f7ff f878 	bl	8002420 <chHeapAllocAligned.constprop.11>
		INIT_NAMBUF(fs);
 8003330:	4607      	mov	r7, r0
 8003332:	2800      	cmp	r0, #0
 8003334:	f000 8107 	beq.w	8003546 <main+0xab6>
 8003338:	9906      	ldr	r1, [sp, #24]
	FATFS *fs = dp->obj.fs;
 800333a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800333c:	9a07      	ldr	r2, [sp, #28]
		INIT_NAMBUF(fs);
 800333e:	60c8      	str	r0, [r1, #12]
	FATFS *fs = dp->obj.fs;
 8003340:	9303      	str	r3, [sp, #12]
 8003342:	4690      	mov	r8, r2
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 8003344:	f812 1b01 	ldrb.w	r1, [r2], #1
 8003348:	292f      	cmp	r1, #47	; 0x2f
 800334a:	d0fa      	beq.n	8003342 <main+0x8b2>
 800334c:	295c      	cmp	r1, #92	; 0x5c
 800334e:	d0f8      	beq.n	8003342 <main+0x8b2>
		dp->obj.sclust = 0;					/* Start from root directory */
 8003350:	2100      	movs	r1, #0
 8003352:	910c      	str	r1, [sp, #48]	; 0x30
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8003354:	f898 2000 	ldrb.w	r2, [r8]
 8003358:	2a1f      	cmp	r2, #31
 800335a:	f240 80b3 	bls.w	80034c4 <main+0xa34>
 800335e:	f103 0234 	add.w	r2, r3, #52	; 0x34
 8003362:	f8df 9218 	ldr.w	r9, [pc, #536]	; 800357c <main+0xaec>
	lfn[di] = 0;							/* LFN is created into the working buffer */
 8003366:	9105      	str	r1, [sp, #20]
 8003368:	9204      	str	r2, [sp, #16]
	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
 800336a:	68dd      	ldr	r5, [r3, #12]
 800336c:	2200      	movs	r2, #0
 800336e:	1ea8      	subs	r0, r5, #2
	wc = (BYTE)*p++;			/* Get a byte */
 8003370:	f818 1b01 	ldrb.w	r1, [r8], #1
 8003374:	b28b      	uxth	r3, r1
	if (wc != 0) {
 8003376:	2b00      	cmp	r3, #0
 8003378:	d179      	bne.n	800346e <main+0x9de>
 800337a:	4641      	mov	r1, r8
	while (*p == '/' || *p == '\\') p++;	/* Skip duplicated separators if exist */
 800337c:	7808      	ldrb	r0, [r1, #0]
 800337e:	282f      	cmp	r0, #47	; 0x2f
 8003380:	4688      	mov	r8, r1
 8003382:	f101 0101 	add.w	r1, r1, #1
 8003386:	d0f9      	beq.n	800337c <main+0x8ec>
 8003388:	285c      	cmp	r0, #92	; 0x5c
 800338a:	d0f7      	beq.n	800337c <main+0x8ec>
	cf = (wc < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 800338c:	2b1f      	cmp	r3, #31
 800338e:	bf8c      	ite	hi
 8003390:	2300      	movhi	r3, #0
 8003392:	2304      	movls	r3, #4
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8003394:	2a00      	cmp	r2, #0
 8003396:	f000 8092 	beq.w	80034be <main+0xa2e>
 800339a:	eb05 0142 	add.w	r1, r5, r2, lsl #1
 800339e:	e002      	b.n	80033a6 <main+0x916>
 80033a0:	3a01      	subs	r2, #1
 80033a2:	f000 808c 	beq.w	80034be <main+0xa2e>
		wc = lfn[di - 1];
 80033a6:	f831 0d02 	ldrh.w	r0, [r1, #-2]!
		if (wc != ' ' && wc != '.') break;
 80033aa:	2820      	cmp	r0, #32
 80033ac:	d0f8      	beq.n	80033a0 <main+0x910>
 80033ae:	282e      	cmp	r0, #46	; 0x2e
 80033b0:	d0f6      	beq.n	80033a0 <main+0x910>
	lfn[di] = 0;							/* LFN is created into the working buffer */
 80033b2:	f8bd 1014 	ldrh.w	r1, [sp, #20]
 80033b6:	f825 1012 	strh.w	r1, [r5, r2, lsl #1]
	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
 80033ba:	8828      	ldrh	r0, [r5, #0]
 80033bc:	2820      	cmp	r0, #32
	lfn[di] = 0;							/* LFN is created into the working buffer */
 80033be:	eb05 0142 	add.w	r1, r5, r2, lsl #1
	for (si = 0; lfn[si] == ' '; si++) ;	/* Remove leading spaces */
 80033c2:	f040 80c4 	bne.w	800354e <main+0xabe>
 80033c6:	4628      	mov	r0, r5
 80033c8:	2400      	movs	r4, #0
 80033ca:	f830 6f02 	ldrh.w	r6, [r0, #2]!
 80033ce:	2e20      	cmp	r6, #32
 80033d0:	f104 0401 	add.w	r4, r4, #1
 80033d4:	d0f9      	beq.n	80033ca <main+0x93a>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 80033d6:	f043 0303 	orr.w	r3, r3, #3
 80033da:	e001      	b.n	80033e0 <main+0x950>
	while (di > 0 && lfn[di - 1] != '.') di--;	/* Find last dot (di<=si: no extension) */
 80033dc:	3a01      	subs	r2, #1
 80033de:	d003      	beq.n	80033e8 <main+0x958>
 80033e0:	f831 0d02 	ldrh.w	r0, [r1, #-2]!
 80033e4:	282e      	cmp	r0, #46	; 0x2e
 80033e6:	d1f9      	bne.n	80033dc <main+0x94c>
		*d++ = (BYTE)val;
 80033e8:	f04f 3120 	mov.w	r1, #538976288	; 0x20202020
 80033ec:	f242 0620 	movw	r6, #8224	; 0x2020
 80033f0:	2020      	movs	r0, #32
	i = b = 0; ni = 8;
 80033f2:	f04f 0c00 	mov.w	ip, #0
		*d++ = (BYTE)val;
 80033f6:	e9cd 1112 	strd	r1, r1, [sp, #72]	; 0x48
 80033fa:	f8ad 6050 	strh.w	r6, [sp, #80]	; 0x50
 80033fe:	f88d 0052 	strb.w	r0, [sp, #82]	; 0x52
	i = b = 0; ni = 8;
 8003402:	4661      	mov	r1, ip
 8003404:	2608      	movs	r6, #8
 8003406:	46ab      	mov	fp, r5
		wc = lfn[si++];					/* Get an LFN character */
 8003408:	f83b 0014 	ldrh.w	r0, [fp, r4, lsl #1]
 800340c:	3401      	adds	r4, #1
		if (wc == 0) break;				/* Break on end of the LFN */
 800340e:	2800      	cmp	r0, #0
 8003410:	f000 80c1 	beq.w	8003596 <main+0xb06>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 8003414:	2820      	cmp	r0, #32
 8003416:	f000 811a 	beq.w	800364e <main+0xbbe>
 800341a:	282e      	cmp	r0, #46	; 0x2e
 800341c:	f000 80fa 	beq.w	8003614 <main+0xb84>
		if (i >= ni || si == di) {		/* End of field? */
 8003420:	45b4      	cmp	ip, r6
 8003422:	f080 80b1 	bcs.w	8003588 <main+0xaf8>
 8003426:	42a2      	cmp	r2, r4
 8003428:	f000 80f6 	beq.w	8003618 <main+0xb88>
		if (wc >= 0x80) {	/* Is this a non-ASCII character? */
 800342c:	287f      	cmp	r0, #127	; 0x7f
 800342e:	f200 8111 	bhi.w	8003654 <main+0xbc4>
 8003432:	f8df e14c 	ldr.w	lr, [pc, #332]	; 8003580 <main+0xaf0>
 8003436:	465d      	mov	r5, fp
	while (*str && *str != chr) str++;
 8003438:	f81e af01 	ldrb.w	sl, [lr, #1]!
 800343c:	f1ba 0f00 	cmp.w	sl, #0
 8003440:	f000 8119 	beq.w	8003676 <main+0xbe6>
 8003444:	4550      	cmp	r0, sl
 8003446:	d1f7      	bne.n	8003438 <main+0x9a8>
 8003448:	46ab      	mov	fp, r5
				wc = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 800344a:	f043 0303 	orr.w	r3, r3, #3
 800344e:	205f      	movs	r0, #95	; 0x5f
		dp->fn[i++] = (BYTE)wc;
 8003450:	ad16      	add	r5, sp, #88	; 0x58
 8003452:	eb05 0e0c 	add.w	lr, r5, ip
 8003456:	f10c 0c01 	add.w	ip, ip, #1
 800345a:	f80e 0c10 	strb.w	r0, [lr, #-16]
 800345e:	e7d3      	b.n	8003408 <main+0x978>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8003460:	69a9      	ldr	r1, [r5, #24]
 8003462:	6828      	ldr	r0, [r5, #0]
 8003464:	9304      	str	r3, [sp, #16]
 8003466:	f7fd feeb 	bl	8001240 <get_fat.isra.9>
 800346a:	9b04      	ldr	r3, [sp, #16]
 800346c:	e609      	b.n	8003082 <main+0x5f2>
	if (oem < 0x80) {	/* ASCII? */
 800346e:	2b7f      	cmp	r3, #127	; 0x7f
 8003470:	d905      	bls.n	800347e <main+0x9ee>
			if (oem < 0x100) c = p[oem - 0x80];
 8003472:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8003476:	3b80      	subs	r3, #128	; 0x80
 8003478:	f839 3013 	ldrh.w	r3, [r9, r3, lsl #1]
		if (wc == 0) return 0xFFFFFFFF;	/* Invalid code? */
 800347c:	b1db      	cbz	r3, 80034b6 <main+0xa26>
		if (wc < ' ' || wc == '/' || wc == '\\') break;	/* Break if end of the path or a separator is found */
 800347e:	2b1f      	cmp	r3, #31
 8003480:	f67f af7b 	bls.w	800337a <main+0x8ea>
 8003484:	2b2f      	cmp	r3, #47	; 0x2f
 8003486:	f43f af78 	beq.w	800337a <main+0x8ea>
 800348a:	2b5c      	cmp	r3, #92	; 0x5c
 800348c:	f43f af75 	beq.w	800337a <main+0x8ea>
		if (wc < 0x80 && chk_chr("\"*:<>\?|\x7F", wc)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 8003490:	2b7f      	cmp	r3, #127	; 0x7f
 8003492:	d905      	bls.n	80034a0 <main+0xa10>
		if (di >= FF_MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 8003494:	2aff      	cmp	r2, #255	; 0xff
 8003496:	d00e      	beq.n	80034b6 <main+0xa26>
		lfn[di++] = wc;					/* Store the Unicode character */
 8003498:	3201      	adds	r2, #1
 800349a:	f820 3f02 	strh.w	r3, [r0, #2]!
 800349e:	e767      	b.n	8003370 <main+0x8e0>
	while (*str && *str != chr) str++;
 80034a0:	2b22      	cmp	r3, #34	; 0x22
 80034a2:	d008      	beq.n	80034b6 <main+0xa26>
 80034a4:	4c33      	ldr	r4, [pc, #204]	; (8003574 <main+0xae4>)
 80034a6:	212a      	movs	r1, #42	; 0x2a
 80034a8:	e003      	b.n	80034b2 <main+0xa22>
 80034aa:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80034ae:	2900      	cmp	r1, #0
 80034b0:	d0f0      	beq.n	8003494 <main+0xa04>
 80034b2:	428b      	cmp	r3, r1
 80034b4:	d1f9      	bne.n	80034aa <main+0xa1a>
 80034b6:	4638      	mov	r0, r7
 80034b8:	f7ff f822 	bl	8002500 <chHeapFree>
 80034bc:	e59c      	b.n	8002ff8 <main+0x568>
	lfn[di] = 0;							/* LFN is created into the working buffer */
 80034be:	2300      	movs	r3, #0
 80034c0:	802b      	strh	r3, [r5, #0]
 80034c2:	e7f8      	b.n	80034b6 <main+0xa26>
		dp->fn[NSFLAG] = NS_NONAME;
 80034c4:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
 80034c6:	a80a      	add	r0, sp, #40	; 0x28
		dp->fn[NSFLAG] = NS_NONAME;
 80034c8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
		res = dir_sdi(dp, 0);
 80034cc:	f7fd ff30 	bl	8001330 <dir_sdi>
		if (res == FR_OK) {
 80034d0:	2800      	cmp	r0, #0
 80034d2:	d1f0      	bne.n	80034b6 <main+0xa26>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 80034d4:	f99d 3053 	ldrsb.w	r3, [sp, #83]	; 0x53
 80034d8:	2b00      	cmp	r3, #0
 80034da:	dbec      	blt.n	80034b6 <main+0xa26>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
 80034dc:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
 80034e0:	06dc      	lsls	r4, r3, #27
 80034e2:	d4e8      	bmi.n	80034b6 <main+0xa26>
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 80034e4:	9906      	ldr	r1, [sp, #24]
			fp->dir_ptr = dj.dir;
 80034e6:	9b11      	ldr	r3, [sp, #68]	; 0x44
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 80034e8:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 80034ea:	4d23      	ldr	r5, [pc, #140]	; (8003578 <main+0xae8>)
			fp->dir_ptr = dj.dir;
 80034ec:	e9c5 2308 	strd	r2, r3, [r5, #32]
	if (fs->fs_type == FS_FAT32) {
 80034f0:	7808      	ldrb	r0, [r1, #0]
	rv = rv << 8 | ptr[0];
 80034f2:	7edc      	ldrb	r4, [r3, #27]
 80034f4:	7e9a      	ldrb	r2, [r3, #26]
	if (fs->fs_type == FS_FAT32) {
 80034f6:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 80034f8:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
	if (fs->fs_type == FS_FAT32) {
 80034fc:	d105      	bne.n	800350a <main+0xa7a>
	rv = rv << 8 | ptr[0];
 80034fe:	7d5c      	ldrb	r4, [r3, #21]
 8003500:	7d18      	ldrb	r0, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8003502:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
 8003506:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
	rv = rv << 8 | ptr[1];
 800350a:	7f58      	ldrb	r0, [r3, #29]
	rv = rv << 8 | ptr[2];
 800350c:	8bdc      	ldrh	r4, [r3, #30]
	rv = rv << 8 | ptr[0];
 800350e:	7f1b      	ldrb	r3, [r3, #28]
	BYTE *d = (BYTE*)dst;
 8003510:	f8df a070 	ldr.w	sl, [pc, #112]	; 8003584 <main+0xaf4>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8003514:	60aa      	str	r2, [r5, #8]
	rv = rv << 8 | ptr[1];
 8003516:	ea40 2204 	orr.w	r2, r0, r4, lsl #8
	rv = rv << 8 | ptr[0];
 800351a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
			fp->obj.id = fs->id;
 800351e:	88c8      	ldrh	r0, [r1, #6]
			fp->obj.fs = fs;	 	/* Validate the file object */
 8003520:	6029      	str	r1, [r5, #0]
			fp->sect = 0;			/* Invalidate current data sector */
 8003522:	2300      	movs	r3, #0
			fp->flag = mode;		/* Set file access mode */
 8003524:	2101      	movs	r1, #1
			fp->obj.id = fs->id;
 8003526:	80a8      	strh	r0, [r5, #4]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8003528:	60ea      	str	r2, [r5, #12]
 800352a:	f50a 7000 	add.w	r0, sl, #512	; 0x200
	BYTE *d = (BYTE*)dst;
 800352e:	4652      	mov	r2, sl
			fp->flag = mode;		/* Set file access mode */
 8003530:	8229      	strh	r1, [r5, #16]
			fp->sect = 0;			/* Invalidate current data sector */
 8003532:	61eb      	str	r3, [r5, #28]
			fp->fptr = 0;			/* Set file pointer top of the file */
 8003534:	616b      	str	r3, [r5, #20]
		*d++ = (BYTE)val;
 8003536:	f802 3b01 	strb.w	r3, [r2], #1
	} while (--cnt);
 800353a:	4282      	cmp	r2, r0
 800353c:	d1fb      	bne.n	8003536 <main+0xaa6>
 800353e:	4638      	mov	r0, r7
 8003540:	f7fe ffde 	bl	8002500 <chHeapFree>
 8003544:	e55d      	b.n	8003002 <main+0x572>
 8003546:	4d0c      	ldr	r5, [pc, #48]	; (8003578 <main+0xae8>)
 8003548:	f105 0a28 	add.w	sl, r5, #40	; 0x28
 800354c:	e559      	b.n	8003002 <main+0x572>
	if (si > 0 || lfn[si] == '.') cf |= NS_LOSS | NS_LFN;	/* Is there any leading space or dot? */
 800354e:	282e      	cmp	r0, #46	; 0x2e
 8003550:	f04f 0400 	mov.w	r4, #0
 8003554:	f47f af44 	bne.w	80033e0 <main+0x950>
 8003558:	e73d      	b.n	80033d6 <main+0x946>
 800355a:	bf00      	nop
 800355c:	40023800 	.word	0x40023800
 8003560:	40026458 	.word	0x40026458
 8003564:	40026408 	.word	0x40026408
 8003568:	08004088 	.word	0x08004088
 800356c:	e000e100 	.word	0xe000e100
 8003570:	20001170 	.word	0x20001170
 8003574:	080043d5 	.word	0x080043d5
 8003578:	20000ea8 	.word	0x20000ea8
 800357c:	08004534 	.word	0x08004534
 8003580:	08004473 	.word	0x08004473
 8003584:	20000ed0 	.word	0x20000ed0
			if (ni == 11) {				/* Name extension overflow? */
 8003588:	2e0b      	cmp	r6, #11
 800358a:	d047      	beq.n	800361c <main+0xb8c>
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Name body overflow? */
 800358c:	42a2      	cmp	r2, r4
 800358e:	d057      	beq.n	8003640 <main+0xbb0>
 8003590:	f043 0303 	orr.w	r3, r3, #3
			if (si > di) break;						/* No name extension? */
 8003594:	d254      	bcs.n	8003640 <main+0xbb0>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8003596:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
 800359a:	2ae5      	cmp	r2, #229	; 0xe5
 800359c:	d045      	beq.n	800362a <main+0xb9a>
	if (ni == 8) b <<= 2;				/* Shift capital flags if no extension */
 800359e:	2e08      	cmp	r6, #8
 80035a0:	bf04      	itt	eq
 80035a2:	0089      	lsleq	r1, r1, #2
 80035a4:	b2c9      	uxtbeq	r1, r1
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 80035a6:	f001 020c 	and.w	r2, r1, #12
 80035aa:	2a0c      	cmp	r2, #12
 80035ac:	d02f      	beq.n	800360e <main+0xb7e>
 80035ae:	f001 0203 	and.w	r2, r1, #3
 80035b2:	2a03      	cmp	r2, #3
 80035b4:	d02b      	beq.n	800360e <main+0xb7e>
	if (!(cf & NS_LFN)) {				/* When LFN is in 8.3 format without extended character, NT flags are created */
 80035b6:	079c      	lsls	r4, r3, #30
 80035b8:	d407      	bmi.n	80035ca <main+0xb3a>
		if (b & 0x01) cf |= NS_EXT;		/* NT flag (Extension has small capital letters only) */
 80035ba:	07c8      	lsls	r0, r1, #31
 80035bc:	bf48      	it	mi
 80035be:	f043 0310 	orrmi.w	r3, r3, #16
		if (b & 0x04) cf |= NS_BODY;	/* NT flag (Body has small capital letters only) */
 80035c2:	074a      	lsls	r2, r1, #29
 80035c4:	bf48      	it	mi
 80035c6:	f043 0308 	orrmi.w	r3, r3, #8
			res = dir_find(dp);				/* Find an object with the segment name */
 80035ca:	a80a      	add	r0, sp, #40	; 0x28
	dp->fn[NSFLAG] = cf;	/* SFN is created into dp->fn[] */
 80035cc:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
			res = dir_find(dp);				/* Find an object with the segment name */
 80035d0:	f7ff f96e 	bl	80028b0 <dir_find>
			ns = dp->fn[NSFLAG];
 80035d4:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
			if (res != FR_OK) {				/* Failed to find the object */
 80035d8:	2800      	cmp	r0, #0
 80035da:	f47f af6c 	bne.w	80034b6 <main+0xa26>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 80035de:	075e      	lsls	r6, r3, #29
 80035e0:	f53f af78 	bmi.w	80034d4 <main+0xa44>
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 80035e4:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
 80035e8:	06dd      	lsls	r5, r3, #27
 80035ea:	f57f af64 	bpl.w	80034b6 <main+0xa26>
	if (fs->fs_type == FS_FAT32) {
 80035ee:	9a03      	ldr	r2, [sp, #12]
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 80035f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	if (fs->fs_type == FS_FAT32) {
 80035f2:	7811      	ldrb	r1, [r2, #0]
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 80035f4:	9a04      	ldr	r2, [sp, #16]
 80035f6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80035fa:	4413      	add	r3, r2
	if (fs->fs_type == FS_FAT32) {
 80035fc:	2903      	cmp	r1, #3
	rv = rv << 8 | ptr[0];
 80035fe:	7ed8      	ldrb	r0, [r3, #27]
 8003600:	7e9a      	ldrb	r2, [r3, #26]
	cl = ld_word(dir + DIR_FstClusLO);
 8003602:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
	if (fs->fs_type == FS_FAT32) {
 8003606:	d014      	beq.n	8003632 <main+0xba2>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8003608:	920c      	str	r2, [sp, #48]	; 0x30
 800360a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800360c:	e6ad      	b.n	800336a <main+0x8da>
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* LFN entry needs to be created if composite capitals */
 800360e:	f043 0302 	orr.w	r3, r3, #2
 8003612:	e7d0      	b.n	80035b6 <main+0xb26>
		if (wc == ' ' || (wc == '.' && si != di)) {	/* Remove embedded spaces and dots */
 8003614:	42a2      	cmp	r2, r4
 8003616:	d11a      	bne.n	800364e <main+0xbbe>
			if (ni == 11) {				/* Name extension overflow? */
 8003618:	2e0b      	cmp	r6, #11
 800361a:	d111      	bne.n	8003640 <main+0xbb0>
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 800361c:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
 8003620:	2ae5      	cmp	r2, #229	; 0xe5
				cf |= NS_LOSS | NS_LFN;
 8003622:	f043 0303 	orr.w	r3, r3, #3
	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8003626:	d1be      	bne.n	80035a6 <main+0xb16>
 8003628:	260b      	movs	r6, #11
 800362a:	2205      	movs	r2, #5
 800362c:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
 8003630:	e7b5      	b.n	800359e <main+0xb0e>
	rv = rv << 8 | ptr[0];
 8003632:	7d59      	ldrb	r1, [r3, #21]
 8003634:	7d1b      	ldrb	r3, [r3, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8003636:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800363a:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 800363e:	e7e3      	b.n	8003608 <main+0xb78>
			si = di; i = 8; ni = 11; b <<= 2;		/* Enter name extension */
 8003640:	0089      	lsls	r1, r1, #2
 8003642:	b2c9      	uxtb	r1, r1
 8003644:	4614      	mov	r4, r2
 8003646:	260b      	movs	r6, #11
 8003648:	f04f 0c08 	mov.w	ip, #8
 800364c:	e6dc      	b.n	8003408 <main+0x978>
			cf |= NS_LOSS | NS_LFN;
 800364e:	f043 0303 	orr.w	r3, r3, #3
 8003652:	e6d9      	b.n	8003408 <main+0x978>
			cf |= NS_LFN;	/* LFN entry needs to be created */
 8003654:	f043 0302 	orr.w	r3, r3, #2
 8003658:	f04f 0e00 	mov.w	lr, #0
 800365c:	465d      	mov	r5, fp
			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
 800365e:	f839 b01e 	ldrh.w	fp, [r9, lr, lsl #1]
 8003662:	4583      	cmp	fp, r0
 8003664:	fa1f fa8e 	uxth.w	sl, lr
 8003668:	d018      	beq.n	800369c <main+0xc0c>
 800366a:	f10e 0e01 	add.w	lr, lr, #1
 800366e:	f1be 0f80 	cmp.w	lr, #128	; 0x80
 8003672:	d1f4      	bne.n	800365e <main+0xbce>
 8003674:	e6e8      	b.n	8003448 <main+0x9b8>
				if (IsUpper(wc)) {		/* ASCII upper case? */
 8003676:	f1a0 0e41 	sub.w	lr, r0, #65	; 0x41
 800367a:	f1be 0f19 	cmp.w	lr, #25
 800367e:	46ab      	mov	fp, r5
 8003680:	d801      	bhi.n	8003686 <main+0xbf6>
					b |= 2;
 8003682:	f041 0102 	orr.w	r1, r1, #2
				if (IsLower(wc)) {		/* ASCII lower case? */
 8003686:	f1a0 0e61 	sub.w	lr, r0, #97	; 0x61
 800368a:	f1be 0f19 	cmp.w	lr, #25
 800368e:	f63f aedf 	bhi.w	8003450 <main+0x9c0>
					b |= 1; wc -= 0x20;
 8003692:	3820      	subs	r0, #32
 8003694:	b280      	uxth	r0, r0
 8003696:	f041 0101 	orr.w	r1, r1, #1
 800369a:	e6d9      	b.n	8003450 <main+0x9c0>
 800369c:	46ab      	mov	fp, r5
			if (wc & 0x80) wc = ExCvt[wc & 0x7F];	/* Convert extended character to upper (SBCS) */
 800369e:	f00a 007f 	and.w	r0, sl, #127	; 0x7f
 80036a2:	4d03      	ldr	r5, [pc, #12]	; (80036b0 <main+0xc20>)
 80036a4:	5c28      	ldrb	r0, [r5, r0]
			if (wc == 0 || chk_chr("+,;=[]", wc)) {	/* Replace illegal characters for SFN if needed */
 80036a6:	2800      	cmp	r0, #0
 80036a8:	f43f aecf 	beq.w	800344a <main+0x9ba>
 80036ac:	e6c1      	b.n	8003432 <main+0x9a2>
 80036ae:	bf00      	nop
 80036b0:	08003f74 	.word	0x08003f74
	...

080036c0 <__early_init>:
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80036c0:	4a7e      	ldr	r2, [pc, #504]	; (80038bc <__early_init+0x1fc>)
  gpiop->OTYPER  = config->otyper;
 80036c2:	487f      	ldr	r0, [pc, #508]	; (80038c0 <__early_init+0x200>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80036c4:	6913      	ldr	r3, [r2, #16]
  gpiop->OTYPER  = config->otyper;
 80036c6:	f8df c24c 	ldr.w	ip, [pc, #588]	; 8003914 <__early_init+0x254>
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80036ca:	f240 11ff 	movw	r1, #511	; 0x1ff
 80036ce:	430b      	orrs	r3, r1
void __early_init(void) {
 80036d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80036d4:	6113      	str	r3, [r2, #16]
 80036d6:	6913      	ldr	r3, [r2, #16]
  gpiop->OTYPER  = config->otyper;
 80036d8:	4e7a      	ldr	r6, [pc, #488]	; (80038c4 <__early_init+0x204>)
  gpiop->PUPDR   = config->pupdr;
 80036da:	f8df e23c 	ldr.w	lr, [pc, #572]	; 8003918 <__early_init+0x258>
  gpiop->AFRL    = config->afrl;
 80036de:	4f7a      	ldr	r7, [pc, #488]	; (80038c8 <__early_init+0x208>)
  gpiop->OTYPER  = config->otyper;
 80036e0:	4d7a      	ldr	r5, [pc, #488]	; (80038cc <__early_init+0x20c>)
 80036e2:	4c7b      	ldr	r4, [pc, #492]	; (80038d0 <__early_init+0x210>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80036e4:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 80036e8:	f023 0301 	bic.w	r3, r3, #1
 80036ec:	6113      	str	r3, [r2, #16]
 80036ee:	6913      	ldr	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 80036f0:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80036f2:	430b      	orrs	r3, r1
 80036f4:	6313      	str	r3, [r2, #48]	; 0x30
 80036f6:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80036f8:	430b      	orrs	r3, r1
 80036fa:	6513      	str	r3, [r2, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
 80036fc:	f46f 41a8 	mvn.w	r1, #21504	; 0x5400
  gpiop->OTYPER  = config->otyper;
 8003700:	2300      	movs	r3, #0
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8003702:	f8d2 8050 	ldr.w	r8, [r2, #80]	; 0x50
  gpiop->OTYPER  = config->otyper;
 8003706:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003708:	6081      	str	r1, [r0, #8]
  gpiop->ODR     = config->odr;
 800370a:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->PUPDR   = config->pupdr;
 800370e:	f8c0 e00c 	str.w	lr, [r0, #12]
  gpiop->AFRH    = config->afrh;
 8003712:	f8df 8208 	ldr.w	r8, [pc, #520]	; 800391c <__early_init+0x25c>
  gpiop->ODR     = config->odr;
 8003716:	6141      	str	r1, [r0, #20]
  gpiop->MODER   = config->moder;
 8003718:	f8df e204 	ldr.w	lr, [pc, #516]	; 8003920 <__early_init+0x260>
  gpiop->AFRL    = config->afrl;
 800371c:	6207      	str	r7, [r0, #32]
  gpiop->OTYPER  = config->otyper;
 800371e:	f44f 7710 	mov.w	r7, #576	; 0x240
  gpiop->AFRH    = config->afrh;
 8003722:	f8c0 8024 	str.w	r8, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003726:	f8c0 e000 	str.w	lr, [r0]
  gpiop->OTYPER  = config->otyper;
 800372a:	6077      	str	r7, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800372c:	f04f 30ff 	mov.w	r0, #4294967295
  gpiop->PUPDR   = config->pupdr;
 8003730:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 8003924 <__early_init+0x264>
  gpiop->OSPEEDR = config->ospeedr;
 8003734:	60b0      	str	r0, [r6, #8]
  gpiop->AFRL    = config->afrl;
 8003736:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
  gpiop->PUPDR   = config->pupdr;
 800373a:	f8c6 e00c 	str.w	lr, [r6, #12]
  gpiop->ODR     = config->odr;
 800373e:	6171      	str	r1, [r6, #20]
  gpiop->AFRH    = config->afrh;
 8003740:	f04f 0e40 	mov.w	lr, #64	; 0x40
  gpiop->AFRL    = config->afrl;
 8003744:	6237      	str	r7, [r6, #32]
  gpiop->MODER   = config->moder;
 8003746:	4f63      	ldr	r7, [pc, #396]	; (80038d4 <__early_init+0x214>)
  gpiop->AFRH    = config->afrh;
 8003748:	f8c6 e024 	str.w	lr, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800374c:	6037      	str	r7, [r6, #0]
  gpiop->PUPDR   = config->pupdr;
 800374e:	f106 56a2 	add.w	r6, r6, #339738624	; 0x14400000
 8003752:	f506 3644 	add.w	r6, r6, #200704	; 0x31000
 8003756:	f506 76aa 	add.w	r6, r6, #340	; 0x154
  gpiop->OTYPER  = config->otyper;
 800375a:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800375c:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 800375e:	60ee      	str	r6, [r5, #12]
  gpiop->AFRL    = config->afrl;
 8003760:	f04f 46c0 	mov.w	r6, #1610612736	; 0x60000000
  gpiop->ODR     = config->odr;
 8003764:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8003766:	622e      	str	r6, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8003768:	4e5b      	ldr	r6, [pc, #364]	; (80038d8 <__early_init+0x218>)
 800376a:	626e      	str	r6, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800376c:	4e5b      	ldr	r6, [pc, #364]	; (80038dc <__early_init+0x21c>)
 800376e:	602e      	str	r6, [r5, #0]
  gpiop->PUPDR   = config->pupdr;
 8003770:	4d5b      	ldr	r5, [pc, #364]	; (80038e0 <__early_init+0x220>)
  gpiop->OTYPER  = config->otyper;
 8003772:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003774:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 8003776:	60e5      	str	r5, [r4, #12]
  gpiop->ODR     = config->odr;
 8003778:	f640 75ff 	movw	r5, #4095	; 0xfff
 800377c:	6165      	str	r5, [r4, #20]
  gpiop->OTYPER  = config->otyper;
 800377e:	4f59      	ldr	r7, [pc, #356]	; (80038e4 <__early_init+0x224>)
 8003780:	4e59      	ldr	r6, [pc, #356]	; (80038e8 <__early_init+0x228>)
  gpiop->MODER   = config->moder;
 8003782:	4d5a      	ldr	r5, [pc, #360]	; (80038ec <__early_init+0x22c>)
  gpiop->AFRL    = config->afrl;
 8003784:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 8003786:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003788:	6025      	str	r5, [r4, #0]
  gpiop->OTYPER  = config->otyper;
 800378a:	f8cc 3004 	str.w	r3, [ip, #4]
 800378e:	4d58      	ldr	r5, [pc, #352]	; (80038f0 <__early_init+0x230>)
  gpiop->OSPEEDR = config->ospeedr;
 8003790:	f8cc 0008 	str.w	r0, [ip, #8]
  gpiop->OTYPER  = config->otyper;
 8003794:	f504 54a0 	add.w	r4, r4, #5120	; 0x1400
  gpiop->PUPDR   = config->pupdr;
 8003798:	f8cc 300c 	str.w	r3, [ip, #12]
  gpiop->ODR     = config->odr;
 800379c:	f8cc 1014 	str.w	r1, [ip, #20]
  gpiop->AFRL    = config->afrl;
 80037a0:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 80037a4:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80037a8:	f8cc e000 	str.w	lr, [ip]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 80037ac:	f5ac 3cd0 	sub.w	ip, ip, #106496	; 0x1a000
  gpiop->OTYPER  = config->otyper;
 80037b0:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80037b2:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80037b4:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 80037b6:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 80037b8:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 80037ba:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80037bc:	603b      	str	r3, [r7, #0]
  gpiop->OTYPER  = config->otyper;
 80037be:	6073      	str	r3, [r6, #4]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80037c0:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
  gpiop->OSPEEDR = config->ospeedr;
 80037c4:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 80037c6:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 80037c8:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 80037ca:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 80037cc:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80037ce:	6033      	str	r3, [r6, #0]
  PWR->CR = STM32_VOS;
 80037d0:	f44f 4640 	mov.w	r6, #49152	; 0xc000
  gpiop->OTYPER  = config->otyper;
 80037d4:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80037d6:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 80037d8:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 80037da:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 80037dc:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 80037de:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80037e0:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
 80037e2:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80037e4:	60a0      	str	r0, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
 80037e6:	60e3      	str	r3, [r4, #12]
  gpiop->ODR     = config->odr;
 80037e8:	6161      	str	r1, [r4, #20]
  gpiop->AFRL    = config->afrl;
 80037ea:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
 80037ec:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80037ee:	6023      	str	r3, [r4, #0]
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 80037f0:	6417      	str	r7, [r2, #64]	; 0x40
  PWR->CR = STM32_VOS;
 80037f2:	f8cc 6000 	str.w	r6, [ip]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80037f6:	6813      	ldr	r3, [r2, #0]
 80037f8:	f043 0301 	orr.w	r3, r3, #1
 80037fc:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80037fe:	6813      	ldr	r3, [r2, #0]
 8003800:	079d      	lsls	r5, r3, #30
 8003802:	d5fc      	bpl.n	80037fe <__early_init+0x13e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8003804:	6893      	ldr	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8003806:	492d      	ldr	r1, [pc, #180]	; (80038bc <__early_init+0x1fc>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8003808:	f023 0303 	bic.w	r3, r3, #3
 800380c:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800380e:	688b      	ldr	r3, [r1, #8]
 8003810:	f013 030c 	ands.w	r3, r3, #12
 8003814:	d1fb      	bne.n	800380e <__early_init+0x14e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8003816:	680a      	ldr	r2, [r1, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8003818:	4828      	ldr	r0, [pc, #160]	; (80038bc <__early_init+0x1fc>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800381a:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 800381e:	600a      	str	r2, [r1, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8003820:	608b      	str	r3, [r1, #8]
  RCC->CR |= RCC_CR_HSEON;
 8003822:	680b      	ldr	r3, [r1, #0]
 8003824:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003828:	600b      	str	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800382a:	6803      	ldr	r3, [r0, #0]
 800382c:	039c      	lsls	r4, r3, #14
 800382e:	d5fc      	bpl.n	800382a <__early_init+0x16a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8003830:	6f43      	ldr	r3, [r0, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8003832:	4a22      	ldr	r2, [pc, #136]	; (80038bc <__early_init+0x1fc>)
  RCC->CSR |= RCC_CSR_LSION;
 8003834:	f043 0301 	orr.w	r3, r3, #1
 8003838:	6743      	str	r3, [r0, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800383a:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800383c:	0799      	lsls	r1, r3, #30
 800383e:	d5fc      	bpl.n	800383a <__early_init+0x17a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8003840:	4b2c      	ldr	r3, [pc, #176]	; (80038f4 <__early_init+0x234>)
 8003842:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8003844:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8003846:	492c      	ldr	r1, [pc, #176]	; (80038f8 <__early_init+0x238>)
  RCC->CR |= RCC_CR_PLLON;
 8003848:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800384c:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800384e:	684b      	ldr	r3, [r1, #4]
 8003850:	045a      	lsls	r2, r3, #17
 8003852:	d5fc      	bpl.n	800384e <__early_init+0x18e>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8003854:	4a19      	ldr	r2, [pc, #100]	; (80038bc <__early_init+0x1fc>)
 8003856:	6813      	ldr	r3, [r2, #0]
 8003858:	019b      	lsls	r3, r3, #6
 800385a:	d5fc      	bpl.n	8003856 <__early_init+0x196>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800385c:	4b27      	ldr	r3, [pc, #156]	; (80038fc <__early_init+0x23c>)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 800385e:	4928      	ldr	r1, [pc, #160]	; (8003900 <__early_init+0x240>)
 8003860:	6091      	str	r1, [r2, #8]
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8003862:	681a      	ldr	r2, [r3, #0]
 8003864:	4b27      	ldr	r3, [pc, #156]	; (8003904 <__early_init+0x244>)
 8003866:	429a      	cmp	r2, r3
 8003868:	d01e      	beq.n	80038a8 <__early_init+0x1e8>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800386a:	4b27      	ldr	r3, [pc, #156]	; (8003908 <__early_init+0x248>)
 800386c:	f240 7205 	movw	r2, #1797	; 0x705
 8003870:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8003872:	4a25      	ldr	r2, [pc, #148]	; (8003908 <__early_init+0x248>)
 8003874:	6813      	ldr	r3, [r2, #0]
 8003876:	f003 030f 	and.w	r3, r3, #15
 800387a:	2b05      	cmp	r3, #5
 800387c:	d1fa      	bne.n	8003874 <__early_init+0x1b4>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800387e:	4a0f      	ldr	r2, [pc, #60]	; (80038bc <__early_init+0x1fc>)
 8003880:	6893      	ldr	r3, [r2, #8]
 8003882:	f043 0302 	orr.w	r3, r3, #2
 8003886:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8003888:	6893      	ldr	r3, [r2, #8]
 800388a:	f003 030c 	and.w	r3, r3, #12
 800388e:	2b08      	cmp	r3, #8
 8003890:	d1fa      	bne.n	8003888 <__early_init+0x1c8>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8003892:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8003894:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003898:	6453      	str	r3, [r2, #68]	; 0x44
 800389a:	6e53      	ldr	r3, [r2, #100]	; 0x64
 800389c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80038a0:	6653      	str	r3, [r2, #100]	; 0x64
 80038a2:	6e53      	ldr	r3, [r2, #100]	; 0x64
}
 80038a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80038a8:	4a18      	ldr	r2, [pc, #96]	; (800390c <__early_init+0x24c>)
 80038aa:	4b19      	ldr	r3, [pc, #100]	; (8003910 <__early_init+0x250>)
 80038ac:	6812      	ldr	r2, [r2, #0]
 80038ae:	429a      	cmp	r2, r3
 80038b0:	d1db      	bne.n	800386a <__early_init+0x1aa>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80038b2:	4b15      	ldr	r3, [pc, #84]	; (8003908 <__early_init+0x248>)
 80038b4:	f240 1205 	movw	r2, #261	; 0x105
 80038b8:	601a      	str	r2, [r3, #0]
 80038ba:	e7da      	b.n	8003872 <__early_init+0x1b2>
 80038bc:	40023800 	.word	0x40023800
 80038c0:	40020000 	.word	0x40020000
 80038c4:	40020400 	.word	0x40020400
 80038c8:	55560000 	.word	0x55560000
 80038cc:	40020800 	.word	0x40020800
 80038d0:	40020c00 	.word	0x40020c00
 80038d4:	00082080 	.word	0x00082080
 80038d8:	00060600 	.word	0x00060600
 80038dc:	02208001 	.word	0x02208001
 80038e0:	00555055 	.word	0x00555055
 80038e4:	40021400 	.word	0x40021400
 80038e8:	40021800 	.word	0x40021800
 80038ec:	55000100 	.word	0x55000100
 80038f0:	40021c00 	.word	0x40021c00
 80038f4:	07405408 	.word	0x07405408
 80038f8:	40007000 	.word	0x40007000
 80038fc:	e0042000 	.word	0xe0042000
 8003900:	38889400 	.word	0x38889400
 8003904:	20006411 	.word	0x20006411
 8003908:	40023c00 	.word	0x40023c00
 800390c:	e000ed00 	.word	0xe000ed00
 8003910:	410fc241 	.word	0x410fc241
 8003914:	40021000 	.word	0x40021000
 8003918:	40010054 	.word	0x40010054
 800391c:	000aaa00 	.word	0x000aaa00
 8003920:	2aa0aa00 	.word	0x2aa0aa00
 8003924:	55514515 	.word	0x55514515
	...

08003930 <Vector15C>:
OSAL_IRQ_HANDLER(STM32_USART6_HANDLER) {
 8003930:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8003934:	4d68      	ldr	r5, [pc, #416]	; (8003ad8 <Vector15C+0x1a8>)
 8003936:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8003938:	f8d6 800c 	ldr.w	r8, [r6, #12]
  uint16_t sr = u->SR;
 800393c:	6833      	ldr	r3, [r6, #0]
  if (sr & USART_SR_LBD) {
 800393e:	05da      	lsls	r2, r3, #23
  uint16_t sr = u->SR;
 8003940:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 8003942:	d47d      	bmi.n	8003a40 <Vector15C+0x110>
 8003944:	2320      	movs	r3, #32
 8003946:	f383 8811 	msr	BASEPRI, r3
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800394a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800394e:	d04d      	beq.n	80039ec <Vector15C+0xbc>
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8003950:	4f62      	ldr	r7, [pc, #392]	; (8003adc <Vector15C+0x1ac>)

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8003952:	f04f 0900 	mov.w	r9, #0
 8003956:	e008      	b.n	800396a <Vector15C+0x3a>
    if (sr & USART_SR_RXNE)
 8003958:	06a1      	lsls	r1, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 800395a:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 800395e:	d41d      	bmi.n	800399c <Vector15C+0x6c>
    sr = u->SR;
 8003960:	6834      	ldr	r4, [r6, #0]
 8003962:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8003964:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8003968:	d040      	beq.n	80039ec <Vector15C+0xbc>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 800396a:	0723      	lsls	r3, r4, #28
 800396c:	d0f4      	beq.n	8003958 <Vector15C+0x28>
    sts |= SD_OVERRUN_ERROR;
 800396e:	f014 0f08 	tst.w	r4, #8
 8003972:	bf0c      	ite	eq
 8003974:	2000      	moveq	r0, #0
 8003976:	2080      	movne	r0, #128	; 0x80
  if (sr & USART_SR_PE)
 8003978:	07e1      	lsls	r1, r4, #31
    sts |= SD_PARITY_ERROR;
 800397a:	bf48      	it	mi
 800397c:	f040 0020 	orrmi.w	r0, r0, #32
  if (sr & USART_SR_FE)
 8003980:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8003982:	bf48      	it	mi
 8003984:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (sr & USART_SR_NE)
 8003988:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 800398a:	bf48      	it	mi
 800398c:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8003990:	f7fc ff1e 	bl	80007d0 <chEvtBroadcastFlagsI.constprop.23>
    if (sr & USART_SR_RXNE)
 8003994:	06a1      	lsls	r1, r4, #26
    b = (uint8_t)u->DR & sdp->rxmask;
 8003996:	f8d6 a004 	ldr.w	sl, [r6, #4]
    if (sr & USART_SR_RXNE)
 800399a:	d5e1      	bpl.n	8003960 <Vector15C+0x30>
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800399c:	696b      	ldr	r3, [r5, #20]
    b = (uint8_t)u->DR & sdp->rxmask;
 800399e:	f895 4078 	ldrb.w	r4, [r5, #120]	; 0x78
 80039a2:	2b00      	cmp	r3, #0
 80039a4:	d03d      	beq.n	8003a22 <Vector15C+0xf2>
  if (!iqIsFullI(iqp)) {
 80039a6:	e9d5 3208 	ldrd	r3, r2, [r5, #32]
 80039aa:	4293      	cmp	r3, r2
 80039ac:	d040      	beq.n	8003a30 <Vector15C+0x100>
    iqp->q_counter++;
 80039ae:	696a      	ldr	r2, [r5, #20]
    *iqp->q_wrptr++ = b;
 80039b0:	1c59      	adds	r1, r3, #1
    iqp->q_counter++;
 80039b2:	3201      	adds	r2, #1
 80039b4:	ea04 0a0a 	and.w	sl, r4, sl
 80039b8:	616a      	str	r2, [r5, #20]
    *iqp->q_wrptr++ = b;
 80039ba:	6229      	str	r1, [r5, #32]
 80039bc:	f883 a000 	strb.w	sl, [r3]
    if (iqp->q_wrptr >= iqp->q_top) {
 80039c0:	e9d5 3207 	ldrd	r3, r2, [r5, #28]
 80039c4:	429a      	cmp	r2, r3
 80039c6:	d301      	bcc.n	80039cc <Vector15C+0x9c>
      iqp->q_wrptr = iqp->q_buffer;
 80039c8:	69ab      	ldr	r3, [r5, #24]
 80039ca:	622b      	str	r3, [r5, #32]
  return (bool)(tqp->next != (const thread_t *)tqp);
 80039cc:	68eb      	ldr	r3, [r5, #12]
 80039ce:	42bb      	cmp	r3, r7
 80039d0:	d0c6      	beq.n	8003960 <Vector15C+0x30>
  tqp->next             = tp->queue.next;
 80039d2:	681a      	ldr	r2, [r3, #0]
 80039d4:	60ea      	str	r2, [r5, #12]
  (void) chSchReadyI(tp);
 80039d6:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 80039d8:	6057      	str	r7, [r2, #4]
  tp->u.rdymsg = msg;
 80039da:	f8c3 9024 	str.w	r9, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80039de:	f7fc fedf 	bl	80007a0 <chSchReadyI>
    sr = u->SR;
 80039e2:	6834      	ldr	r4, [r6, #0]
 80039e4:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80039e6:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80039ea:	d1be      	bne.n	800396a <Vector15C+0x3a>
 80039ec:	2300      	movs	r3, #0
 80039ee:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 80039f2:	f018 0f80 	tst.w	r8, #128	; 0x80
 80039f6:	d001      	beq.n	80039fc <Vector15C+0xcc>
 80039f8:	0622      	lsls	r2, r4, #24
 80039fa:	d42f      	bmi.n	8003a5c <Vector15C+0x12c>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 80039fc:	f018 0f40 	tst.w	r8, #64	; 0x40
 8003a00:	d00b      	beq.n	8003a1a <Vector15C+0xea>
 8003a02:	0663      	lsls	r3, r4, #25
 8003a04:	d509      	bpl.n	8003a1a <Vector15C+0xea>
 8003a06:	2320      	movs	r3, #32
 8003a08:	f383 8811 	msr	BASEPRI, r3
    if (oqIsEmptyI(&sdp->oqueue)) {
 8003a0c:	e9d5 2311 	ldrd	r2, r3, [r5, #68]	; 0x44
 8003a10:	429a      	cmp	r2, r3
 8003a12:	d048      	beq.n	8003aa6 <Vector15C+0x176>
 8003a14:	2300      	movs	r3, #0
 8003a16:	f383 8811 	msr	BASEPRI, r3
}
 8003a1a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8003a1e:	f7fc be17 	b.w	8000650 <_port_irq_epilogue>
 8003a22:	2004      	movs	r0, #4
 8003a24:	f7fc fed4 	bl	80007d0 <chEvtBroadcastFlagsI.constprop.23>
  if (!iqIsFullI(iqp)) {
 8003a28:	e9d5 3208 	ldrd	r3, r2, [r5, #32]
 8003a2c:	4293      	cmp	r3, r2
 8003a2e:	d1be      	bne.n	80039ae <Vector15C+0x7e>
 8003a30:	696a      	ldr	r2, [r5, #20]
 8003a32:	2a00      	cmp	r2, #0
 8003a34:	d0bb      	beq.n	80039ae <Vector15C+0x7e>
 8003a36:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8003a3a:	f7fc fec9 	bl	80007d0 <chEvtBroadcastFlagsI.constprop.23>
 8003a3e:	e78f      	b.n	8003960 <Vector15C+0x30>
 8003a40:	2320      	movs	r3, #32
 8003a42:	f383 8811 	msr	BASEPRI, r3
 8003a46:	f44f 7000 	mov.w	r0, #512	; 0x200
 8003a4a:	f7fc fec1 	bl	80007d0 <chEvtBroadcastFlagsI.constprop.23>
    u->SR = ~USART_SR_LBD;
 8003a4e:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8003a52:	6033      	str	r3, [r6, #0]
 8003a54:	2300      	movs	r3, #0
 8003a56:	f383 8811 	msr	BASEPRI, r3
 8003a5a:	e773      	b.n	8003944 <Vector15C+0x14>
 8003a5c:	2320      	movs	r3, #32
 8003a5e:	f383 8811 	msr	BASEPRI, r3
  if (!oqIsEmptyI(oqp)) {
 8003a62:	e9d5 2311 	ldrd	r2, r3, [r5, #68]	; 0x44
 8003a66:	429a      	cmp	r2, r3
 8003a68:	d029      	beq.n	8003abe <Vector15C+0x18e>
    oqp->q_counter++;
 8003a6a:	6baa      	ldr	r2, [r5, #56]	; 0x38
    if (oqp->q_rdptr >= oqp->q_top) {
 8003a6c:	6c29      	ldr	r1, [r5, #64]	; 0x40
    b = *oqp->q_rdptr++;
 8003a6e:	1c58      	adds	r0, r3, #1
    oqp->q_counter++;
 8003a70:	3201      	adds	r2, #1
 8003a72:	63aa      	str	r2, [r5, #56]	; 0x38
    b = *oqp->q_rdptr++;
 8003a74:	64a8      	str	r0, [r5, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 8003a76:	4288      	cmp	r0, r1
    b = *oqp->q_rdptr++;
 8003a78:	781f      	ldrb	r7, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8003a7a:	d301      	bcc.n	8003a80 <Vector15C+0x150>
      oqp->q_rdptr = oqp->q_buffer;
 8003a7c:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8003a7e:	64ab      	str	r3, [r5, #72]	; 0x48
  return (bool)(tqp->next != (const thread_t *)tqp);
 8003a80:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003a82:	4a17      	ldr	r2, [pc, #92]	; (8003ae0 <Vector15C+0x1b0>)
 8003a84:	4293      	cmp	r3, r2
 8003a86:	d009      	beq.n	8003a9c <Vector15C+0x16c>
  tqp->next             = tp->queue.next;
 8003a88:	6819      	ldr	r1, [r3, #0]
 8003a8a:	6329      	str	r1, [r5, #48]	; 0x30
  tp->u.rdymsg = msg;
 8003a8c:	f04f 0c00 	mov.w	ip, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8003a90:	604a      	str	r2, [r1, #4]
  (void) chSchReadyI(tp);
 8003a92:	4618      	mov	r0, r3
  tp->u.rdymsg = msg;
 8003a94:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8003a98:	f7fc fe82 	bl	80007a0 <chSchReadyI>
      u->DR = b;
 8003a9c:	6077      	str	r7, [r6, #4]
 8003a9e:	2300      	movs	r3, #0
 8003aa0:	f383 8811 	msr	BASEPRI, r3
 8003aa4:	e7aa      	b.n	80039fc <Vector15C+0xcc>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8003aa6:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8003aa8:	2b00      	cmp	r3, #0
 8003aaa:	d0b3      	beq.n	8003a14 <Vector15C+0xe4>
 8003aac:	2010      	movs	r0, #16
 8003aae:	f7fc fe8f 	bl	80007d0 <chEvtBroadcastFlagsI.constprop.23>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003ab2:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8003ab6:	ea08 0303 	and.w	r3, r8, r3
 8003aba:	60f3      	str	r3, [r6, #12]
 8003abc:	e7aa      	b.n	8003a14 <Vector15C+0xe4>
  if (!oqIsEmptyI(oqp)) {
 8003abe:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8003ac0:	2a00      	cmp	r2, #0
 8003ac2:	d0d2      	beq.n	8003a6a <Vector15C+0x13a>
 8003ac4:	2008      	movs	r0, #8
 8003ac6:	f7fc fe83 	bl	80007d0 <chEvtBroadcastFlagsI.constprop.23>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8003aca:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8003ace:	ea08 0303 	and.w	r3, r8, r3
 8003ad2:	60f3      	str	r3, [r6, #12]
 8003ad4:	e7e3      	b.n	8003a9e <Vector15C+0x16e>
 8003ad6:	bf00      	nop
 8003ad8:	20000808 	.word	0x20000808
 8003adc:	20000814 	.word	0x20000814
 8003ae0:	20000838 	.word	0x20000838
	...

08003af0 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8003af0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8003af4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 8003af8:	693b      	ldr	r3, [r7, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8003afa:	68fa      	ldr	r2, [r7, #12]
 8003afc:	4013      	ands	r3, r2
 8003afe:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;
 8003b00:	43d2      	mvns	r2, r2

  if ((sr & TIM_SR_CC1IF) != 0U)
 8003b02:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 8003b04:	613a      	str	r2, [r7, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8003b06:	d403      	bmi.n	8003b10 <VectorB0+0x20>
}
 8003b08:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8003b0c:	f7fc bda0 	b.w	8000650 <_port_irq_epilogue>
 8003b10:	2320      	movs	r3, #32
 8003b12:	f383 8811 	msr	BASEPRI, r3
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8003b16:	4c1e      	ldr	r4, [pc, #120]	; (8003b90 <VectorB0+0xa0>)
 8003b18:	46a1      	mov	r9, r4
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8003b1a:	f04f 0800 	mov.w	r8, #0
  vtp = ch.vtlist.next;
 8003b1e:	f859 3f1c 	ldr.w	r3, [r9, #28]!
 8003b22:	689a      	ldr	r2, [r3, #8]
  return (systime_t)STM32_ST_TIM->CNT;
 8003b24:	6a78      	ldr	r0, [r7, #36]	; 0x24
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8003b26:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  return (sysinterval_t)((systime_t)(end - start));
 8003b28:	1a45      	subs	r5, r0, r1
    if (nowdelta < vtp->delta) {
 8003b2a:	42aa      	cmp	r2, r5
 8003b2c:	d81c      	bhi.n	8003b68 <VectorB0+0x78>
 8003b2e:	2620      	movs	r6, #32
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003b30:	6818      	ldr	r0, [r3, #0]
      fn = vtp->func;
 8003b32:	f8d3 a00c 	ldr.w	sl, [r3, #12]
      ch.vtlist.lasttime += vtp->delta;
 8003b36:	4411      	add	r1, r2

      /* If the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003b38:	4548      	cmp	r0, r9
      ch.vtlist.lasttime += vtp->delta;
 8003b3a:	62a1      	str	r1, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;
 8003b3c:	eba5 0502 	sub.w	r5, r5, r2
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003b40:	f8c0 9004 	str.w	r9, [r0, #4]
      ch.vtlist.next = vtp->next;
 8003b44:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
 8003b46:	f8c3 800c 	str.w	r8, [r3, #12]
  STM32_ST_TIM->DIER = 0U;
 8003b4a:	bf08      	it	eq
 8003b4c:	f8c7 800c 	streq.w	r8, [r7, #12]
 8003b50:	f388 8811 	msr	BASEPRI, r8
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8003b54:	6918      	ldr	r0, [r3, #16]
 8003b56:	47d0      	blx	sl
 8003b58:	f386 8811 	msr	BASEPRI, r6
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8003b5c:	69e3      	ldr	r3, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
 8003b5e:	689a      	ldr	r2, [r3, #8]
 8003b60:	4295      	cmp	r5, r2
 8003b62:	d3df      	bcc.n	8003b24 <VectorB0+0x34>
 8003b64:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8003b66:	e7e3      	b.n	8003b30 <VectorB0+0x40>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003b68:	69e2      	ldr	r2, [r4, #28]
 8003b6a:	454a      	cmp	r2, r9
 8003b6c:	d009      	beq.n	8003b82 <VectorB0+0x92>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8003b6e:	6891      	ldr	r1, [r2, #8]
  ch.vtlist.lasttime += nowdelta;
 8003b70:	62a0      	str	r0, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8003b72:	1b4d      	subs	r5, r1, r5
 8003b74:	6095      	str	r5, [r2, #8]
  return systime + (systime_t)interval;
 8003b76:	689b      	ldr	r3, [r3, #8]
 8003b78:	2b02      	cmp	r3, #2
 8003b7a:	bf2c      	ite	cs
 8003b7c:	18c0      	addcs	r0, r0, r3
 8003b7e:	3002      	addcc	r0, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8003b80:	6378      	str	r0, [r7, #52]	; 0x34
 8003b82:	2300      	movs	r3, #0
 8003b84:	f383 8811 	msr	BASEPRI, r3
}
 8003b88:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8003b8c:	f7fc bd60 	b.w	8000650 <_port_irq_epilogue>
 8003b90:	20000d04 	.word	0x20000d04
	...

08003ba0 <Vector104>:
OSAL_IRQ_HANDLER(STM32_SDIO_HANDLER) {
 8003ba0:	b508      	push	{r3, lr}
 8003ba2:	2320      	movs	r3, #32
 8003ba4:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 8003ba8:	4908      	ldr	r1, [pc, #32]	; (8003bcc <Vector104+0x2c>)
  SDIO->MASK = 0;
 8003baa:	4809      	ldr	r0, [pc, #36]	; (8003bd0 <Vector104+0x30>)
 8003bac:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8003bae:	2200      	movs	r2, #0
 8003bb0:	63c2      	str	r2, [r0, #60]	; 0x3c
 8003bb2:	b123      	cbz	r3, 8003bbe <Vector104+0x1e>
    *trp = NULL;
 8003bb4:	63ca      	str	r2, [r1, #60]	; 0x3c
    (void) chSchReadyI(tp);
 8003bb6:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
 8003bb8:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8003bba:	f7fc fdf1 	bl	80007a0 <chSchReadyI>
 8003bbe:	2300      	movs	r3, #0
 8003bc0:	f383 8811 	msr	BASEPRI, r3
}
 8003bc4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8003bc8:	f7fc bd42 	b.w	8000650 <_port_irq_epilogue>
 8003bcc:	20000884 	.word	0x20000884
 8003bd0:	40012c00 	.word	0x40012c00
	...

08003be0 <Vector158>:
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003be0:	4b08      	ldr	r3, [pc, #32]	; (8003c04 <Vector158+0x24>)
  if (dma.streams[15].func)
 8003be2:	4809      	ldr	r0, [pc, #36]	; (8003c08 <Vector158+0x28>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003be4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[15].func)
 8003be6:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003be8:	0d89      	lsrs	r1, r1, #22
 8003bea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8003bee:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
 8003bf0:	058c      	lsls	r4, r1, #22
 8003bf2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
 8003bf4:	b112      	cbz	r2, 8003bfc <Vector158+0x1c>
    dma.streams[15].func(dma.streams[15].param, flags);
 8003bf6:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 8003bfa:	4790      	blx	r2
}
 8003bfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003c00:	f7fc bd26 	b.w	8000650 <_port_irq_epilogue>
 8003c04:	40026400 	.word	0x40026400
 8003c08:	200010ec 	.word	0x200010ec
 8003c0c:	00000000 	.word	0x00000000

08003c10 <Vector154>:
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003c10:	4b08      	ldr	r3, [pc, #32]	; (8003c34 <Vector154+0x24>)
  if (dma.streams[14].func)
 8003c12:	4809      	ldr	r0, [pc, #36]	; (8003c38 <Vector154+0x28>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003c14:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[14].func)
 8003c16:	6f42      	ldr	r2, [r0, #116]	; 0x74
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003c18:	0c09      	lsrs	r1, r1, #16
 8003c1a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8003c1e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
 8003c20:	040c      	lsls	r4, r1, #16
 8003c22:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
 8003c24:	b10a      	cbz	r2, 8003c2a <Vector154+0x1a>
    dma.streams[14].func(dma.streams[14].param, flags);
 8003c26:	6f80      	ldr	r0, [r0, #120]	; 0x78
 8003c28:	4790      	blx	r2
}
 8003c2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003c2e:	f7fc bd0f 	b.w	8000650 <_port_irq_epilogue>
 8003c32:	bf00      	nop
 8003c34:	40026400 	.word	0x40026400
 8003c38:	200010ec 	.word	0x200010ec
 8003c3c:	00000000 	.word	0x00000000

08003c40 <Vector150>:
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003c40:	4b08      	ldr	r3, [pc, #32]	; (8003c64 <Vector150+0x24>)
  if (dma.streams[13].func)
 8003c42:	4809      	ldr	r0, [pc, #36]	; (8003c68 <Vector150+0x28>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003c44:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[13].func)
 8003c46:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003c48:	0989      	lsrs	r1, r1, #6
 8003c4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8003c4e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
 8003c50:	018c      	lsls	r4, r1, #6
 8003c52:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
 8003c54:	b10a      	cbz	r2, 8003c5a <Vector150+0x1a>
    dma.streams[13].func(dma.streams[13].param, flags);
 8003c56:	6f00      	ldr	r0, [r0, #112]	; 0x70
 8003c58:	4790      	blx	r2
}
 8003c5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003c5e:	f7fc bcf7 	b.w	8000650 <_port_irq_epilogue>
 8003c62:	bf00      	nop
 8003c64:	40026400 	.word	0x40026400
 8003c68:	200010ec 	.word	0x200010ec
 8003c6c:	00000000 	.word	0x00000000

08003c70 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8003c70:	b508      	push	{r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003c72:	4b07      	ldr	r3, [pc, #28]	; (8003c90 <Vector130+0x20>)
  if (dma.streams[12].func)
 8003c74:	4807      	ldr	r0, [pc, #28]	; (8003c94 <Vector130+0x24>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003c76:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 8003c78:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003c7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8003c7e:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 8003c80:	b10a      	cbz	r2, 8003c86 <Vector130+0x16>
    dma.streams[12].func(dma.streams[12].param, flags);
 8003c82:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8003c84:	4790      	blx	r2
}
 8003c86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8003c8a:	f7fc bce1 	b.w	8000650 <_port_irq_epilogue>
 8003c8e:	bf00      	nop
 8003c90:	40026400 	.word	0x40026400
 8003c94:	200010ec 	.word	0x200010ec
	...

08003ca0 <Vector12C>:
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003ca0:	4b08      	ldr	r3, [pc, #32]	; (8003cc4 <Vector12C+0x24>)
  if (dma.streams[11].func)
 8003ca2:	4809      	ldr	r0, [pc, #36]	; (8003cc8 <Vector12C+0x28>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003ca4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[11].func)
 8003ca6:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003ca8:	0d89      	lsrs	r1, r1, #22
 8003caa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8003cae:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
 8003cb0:	058c      	lsls	r4, r1, #22
 8003cb2:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
 8003cb4:	b10a      	cbz	r2, 8003cba <Vector12C+0x1a>
    dma.streams[11].func(dma.streams[11].param, flags);
 8003cb6:	6e00      	ldr	r0, [r0, #96]	; 0x60
 8003cb8:	4790      	blx	r2
}
 8003cba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003cbe:	f7fc bcc7 	b.w	8000650 <_port_irq_epilogue>
 8003cc2:	bf00      	nop
 8003cc4:	40026400 	.word	0x40026400
 8003cc8:	200010ec 	.word	0x200010ec
 8003ccc:	00000000 	.word	0x00000000

08003cd0 <Vector128>:
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003cd0:	4b08      	ldr	r3, [pc, #32]	; (8003cf4 <Vector128+0x24>)
  if (dma.streams[10].func)
 8003cd2:	4809      	ldr	r0, [pc, #36]	; (8003cf8 <Vector128+0x28>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003cd4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[10].func)
 8003cd6:	6d42      	ldr	r2, [r0, #84]	; 0x54
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003cd8:	0c09      	lsrs	r1, r1, #16
 8003cda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8003cde:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
 8003ce0:	040c      	lsls	r4, r1, #16
 8003ce2:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
 8003ce4:	b10a      	cbz	r2, 8003cea <Vector128+0x1a>
    dma.streams[10].func(dma.streams[10].param, flags);
 8003ce6:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8003ce8:	4790      	blx	r2
}
 8003cea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003cee:	f7fc bcaf 	b.w	8000650 <_port_irq_epilogue>
 8003cf2:	bf00      	nop
 8003cf4:	40026400 	.word	0x40026400
 8003cf8:	200010ec 	.word	0x200010ec
 8003cfc:	00000000 	.word	0x00000000

08003d00 <Vector124>:
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003d00:	4b08      	ldr	r3, [pc, #32]	; (8003d24 <Vector124+0x24>)
  if (dma.streams[9].func)
 8003d02:	4809      	ldr	r0, [pc, #36]	; (8003d28 <Vector124+0x28>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003d04:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[9].func)
 8003d06:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003d08:	0989      	lsrs	r1, r1, #6
 8003d0a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8003d0e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
 8003d10:	018c      	lsls	r4, r1, #6
 8003d12:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
 8003d14:	b10a      	cbz	r2, 8003d1a <Vector124+0x1a>
    dma.streams[9].func(dma.streams[9].param, flags);
 8003d16:	6d00      	ldr	r0, [r0, #80]	; 0x50
 8003d18:	4790      	blx	r2
}
 8003d1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003d1e:	f7fc bc97 	b.w	8000650 <_port_irq_epilogue>
 8003d22:	bf00      	nop
 8003d24:	40026400 	.word	0x40026400
 8003d28:	200010ec 	.word	0x200010ec
 8003d2c:	00000000 	.word	0x00000000

08003d30 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8003d30:	b508      	push	{r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003d32:	4b07      	ldr	r3, [pc, #28]	; (8003d50 <Vector120+0x20>)
  if (dma.streams[8].func)
 8003d34:	4807      	ldr	r0, [pc, #28]	; (8003d54 <Vector120+0x24>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003d36:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 8003d38:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003d3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8003d3e:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 8003d40:	b10a      	cbz	r2, 8003d46 <Vector120+0x16>
    dma.streams[8].func(dma.streams[8].param, flags);
 8003d42:	6c80      	ldr	r0, [r0, #72]	; 0x48
 8003d44:	4790      	blx	r2
}
 8003d46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8003d4a:	f7fc bc81 	b.w	8000650 <_port_irq_epilogue>
 8003d4e:	bf00      	nop
 8003d50:	40026400 	.word	0x40026400
 8003d54:	200010ec 	.word	0x200010ec
	...

08003d60 <VectorFC>:
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003d60:	4b08      	ldr	r3, [pc, #32]	; (8003d84 <VectorFC+0x24>)
  if (dma.streams[7].func)
 8003d62:	4809      	ldr	r0, [pc, #36]	; (8003d88 <VectorFC+0x28>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003d64:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[7].func)
 8003d66:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003d68:	0d89      	lsrs	r1, r1, #22
 8003d6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8003d6e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
 8003d70:	058c      	lsls	r4, r1, #22
 8003d72:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
 8003d74:	b10a      	cbz	r2, 8003d7a <VectorFC+0x1a>
    dma.streams[7].func(dma.streams[7].param, flags);
 8003d76:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8003d78:	4790      	blx	r2
}
 8003d7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003d7e:	f7fc bc67 	b.w	8000650 <_port_irq_epilogue>
 8003d82:	bf00      	nop
 8003d84:	40026000 	.word	0x40026000
 8003d88:	200010ec 	.word	0x200010ec
 8003d8c:	00000000 	.word	0x00000000

08003d90 <Vector84>:
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003d90:	4b08      	ldr	r3, [pc, #32]	; (8003db4 <Vector84+0x24>)
  if (dma.streams[6].func)
 8003d92:	4809      	ldr	r0, [pc, #36]	; (8003db8 <Vector84+0x28>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003d94:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[6].func)
 8003d96:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003d98:	0c09      	lsrs	r1, r1, #16
 8003d9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8003d9e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
 8003da0:	040c      	lsls	r4, r1, #16
 8003da2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
 8003da4:	b10a      	cbz	r2, 8003daa <Vector84+0x1a>
    dma.streams[6].func(dma.streams[6].param, flags);
 8003da6:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8003da8:	4790      	blx	r2
}
 8003daa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003dae:	f7fc bc4f 	b.w	8000650 <_port_irq_epilogue>
 8003db2:	bf00      	nop
 8003db4:	40026000 	.word	0x40026000
 8003db8:	200010ec 	.word	0x200010ec
 8003dbc:	00000000 	.word	0x00000000

08003dc0 <Vector80>:
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003dc0:	4b08      	ldr	r3, [pc, #32]	; (8003de4 <Vector80+0x24>)
  if (dma.streams[5].func)
 8003dc2:	4809      	ldr	r0, [pc, #36]	; (8003de8 <Vector80+0x28>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003dc4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[5].func)
 8003dc6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003dc8:	0989      	lsrs	r1, r1, #6
 8003dca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8003dce:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
 8003dd0:	018c      	lsls	r4, r1, #6
 8003dd2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
 8003dd4:	b10a      	cbz	r2, 8003dda <Vector80+0x1a>
    dma.streams[5].func(dma.streams[5].param, flags);
 8003dd6:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003dd8:	4790      	blx	r2
}
 8003dda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003dde:	f7fc bc37 	b.w	8000650 <_port_irq_epilogue>
 8003de2:	bf00      	nop
 8003de4:	40026000 	.word	0x40026000
 8003de8:	200010ec 	.word	0x200010ec
 8003dec:	00000000 	.word	0x00000000

08003df0 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8003df0:	b508      	push	{r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003df2:	4b07      	ldr	r3, [pc, #28]	; (8003e10 <Vector7C+0x20>)
  if (dma.streams[4].func)
 8003df4:	4807      	ldr	r0, [pc, #28]	; (8003e14 <Vector7C+0x24>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003df6:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 8003df8:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003dfa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8003dfe:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 8003e00:	b10a      	cbz	r2, 8003e06 <Vector7C+0x16>
    dma.streams[4].func(dma.streams[4].param, flags);
 8003e02:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8003e04:	4790      	blx	r2
}
 8003e06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8003e0a:	f7fc bc21 	b.w	8000650 <_port_irq_epilogue>
 8003e0e:	bf00      	nop
 8003e10:	40026000 	.word	0x40026000
 8003e14:	200010ec 	.word	0x200010ec
	...

08003e20 <Vector78>:
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003e20:	4b08      	ldr	r3, [pc, #32]	; (8003e44 <Vector78+0x24>)
  if (dma.streams[3].func)
 8003e22:	4809      	ldr	r0, [pc, #36]	; (8003e48 <Vector78+0x28>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003e24:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[3].func)
 8003e26:	69c2      	ldr	r2, [r0, #28]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003e28:	0d89      	lsrs	r1, r1, #22
 8003e2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8003e2e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
 8003e30:	058c      	lsls	r4, r1, #22
 8003e32:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
 8003e34:	b10a      	cbz	r2, 8003e3a <Vector78+0x1a>
    dma.streams[3].func(dma.streams[3].param, flags);
 8003e36:	6a00      	ldr	r0, [r0, #32]
 8003e38:	4790      	blx	r2
}
 8003e3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003e3e:	f7fc bc07 	b.w	8000650 <_port_irq_epilogue>
 8003e42:	bf00      	nop
 8003e44:	40026000 	.word	0x40026000
 8003e48:	200010ec 	.word	0x200010ec
 8003e4c:	00000000 	.word	0x00000000

08003e50 <Vector74>:
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003e50:	4b08      	ldr	r3, [pc, #32]	; (8003e74 <Vector74+0x24>)
  if (dma.streams[2].func)
 8003e52:	4809      	ldr	r0, [pc, #36]	; (8003e78 <Vector74+0x28>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003e54:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[2].func)
 8003e56:	6942      	ldr	r2, [r0, #20]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003e58:	0c09      	lsrs	r1, r1, #16
 8003e5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8003e5e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
 8003e60:	040c      	lsls	r4, r1, #16
 8003e62:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
 8003e64:	b10a      	cbz	r2, 8003e6a <Vector74+0x1a>
    dma.streams[2].func(dma.streams[2].param, flags);
 8003e66:	6980      	ldr	r0, [r0, #24]
 8003e68:	4790      	blx	r2
}
 8003e6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003e6e:	f7fc bbef 	b.w	8000650 <_port_irq_epilogue>
 8003e72:	bf00      	nop
 8003e74:	40026000 	.word	0x40026000
 8003e78:	200010ec 	.word	0x200010ec
 8003e7c:	00000000 	.word	0x00000000

08003e80 <Vector70>:
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003e80:	4b08      	ldr	r3, [pc, #32]	; (8003ea4 <Vector70+0x24>)
  if (dma.streams[1].func)
 8003e82:	4809      	ldr	r0, [pc, #36]	; (8003ea8 <Vector70+0x28>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003e84:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[1].func)
 8003e86:	68c2      	ldr	r2, [r0, #12]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003e88:	0989      	lsrs	r1, r1, #6
 8003e8a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8003e8e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
 8003e90:	018c      	lsls	r4, r1, #6
 8003e92:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
 8003e94:	b10a      	cbz	r2, 8003e9a <Vector70+0x1a>
    dma.streams[1].func(dma.streams[1].param, flags);
 8003e96:	6900      	ldr	r0, [r0, #16]
 8003e98:	4790      	blx	r2
}
 8003e9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8003e9e:	f7fc bbd7 	b.w	8000650 <_port_irq_epilogue>
 8003ea2:	bf00      	nop
 8003ea4:	40026000 	.word	0x40026000
 8003ea8:	200010ec 	.word	0x200010ec
 8003eac:	00000000 	.word	0x00000000

08003eb0 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8003eb0:	b508      	push	{r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003eb2:	4b07      	ldr	r3, [pc, #28]	; (8003ed0 <Vector6C+0x20>)
  if (dma.streams[0].func)
 8003eb4:	4807      	ldr	r0, [pc, #28]	; (8003ed4 <Vector6C+0x24>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003eb6:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 8003eb8:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003eba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8003ebe:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 8003ec0:	b10a      	cbz	r2, 8003ec6 <Vector6C+0x16>
    dma.streams[0].func(dma.streams[0].param, flags);
 8003ec2:	6880      	ldr	r0, [r0, #8]
 8003ec4:	4790      	blx	r2
}
 8003ec6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8003eca:	f7fc bbc1 	b.w	8000650 <_port_irq_epilogue>
 8003ece:	bf00      	nop
 8003ed0:	40026000 	.word	0x40026000
 8003ed4:	200010ec 	.word	0x200010ec
	...

08003ee0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003ee0:	b4f0      	push	{r4, r5, r6, r7}
 8003ee2:	4e14      	ldr	r6, [pc, #80]	; (8003f34 <__init_ram_areas+0x54>)
 8003ee4:	4d14      	ldr	r5, [pc, #80]	; (8003f38 <__init_ram_areas+0x58>)
 8003ee6:	4c15      	ldr	r4, [pc, #84]	; (8003f3c <__init_ram_areas+0x5c>)
 8003ee8:	4b15      	ldr	r3, [pc, #84]	; (8003f40 <__init_ram_areas+0x60>)
 8003eea:	4916      	ldr	r1, [pc, #88]	; (8003f44 <__init_ram_areas+0x64>)
 8003eec:	f106 0c70 	add.w	ip, r6, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003ef0:	2700      	movs	r7, #0
    while (p < rap->clear_area) {
 8003ef2:	429c      	cmp	r4, r3
 8003ef4:	d911      	bls.n	8003f1a <__init_ram_areas+0x3a>
 8003ef6:	3904      	subs	r1, #4
 8003ef8:	461a      	mov	r2, r3
      *p = *tp;
 8003efa:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8003efe:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
 8003f02:	4294      	cmp	r4, r2
 8003f04:	d8f9      	bhi.n	8003efa <__init_ram_areas+0x1a>
 8003f06:	43da      	mvns	r2, r3
 8003f08:	4414      	add	r4, r2
 8003f0a:	f024 0403 	bic.w	r4, r4, #3
 8003f0e:	3404      	adds	r4, #4
 8003f10:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
 8003f12:	429d      	cmp	r5, r3
 8003f14:	d903      	bls.n	8003f1e <__init_ram_areas+0x3e>
      *p = 0;
 8003f16:	f843 7b04 	str.w	r7, [r3], #4
    while (p < rap->no_init_area) {
 8003f1a:	429d      	cmp	r5, r3
 8003f1c:	d8fb      	bhi.n	8003f16 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8003f1e:	4566      	cmp	r6, ip
 8003f20:	d005      	beq.n	8003f2e <__init_ram_areas+0x4e>
 8003f22:	e9d6 1304 	ldrd	r1, r3, [r6, #16]
 8003f26:	e9d6 4506 	ldrd	r4, r5, [r6, #24]
 8003f2a:	3610      	adds	r6, #16
 8003f2c:	e7e1      	b.n	8003ef2 <__init_ram_areas+0x12>
#endif
}
 8003f2e:	bcf0      	pop	{r4, r5, r6, r7}
 8003f30:	4770      	bx	lr
 8003f32:	bf00      	nop
 8003f34:	0800448c 	.word	0x0800448c
 8003f38:	20001770 	.word	0x20001770
 8003f3c:	20001770 	.word	0x20001770
 8003f40:	20001770 	.word	0x20001770
 8003f44:	0800465c 	.word	0x0800465c
	...

08003f50 <__default_exit>:
void __default_exit(void) {
 8003f50:	e7fe      	b.n	8003f50 <__default_exit>
 8003f52:	bf00      	nop
	...

08003f60 <__late_init>:
 8003f60:	4770      	bx	lr
 8003f62:	bf00      	nop
	...

08003f70 <__core_init>:
}
 8003f70:	4770      	bx	lr
 8003f72:	bf00      	nop
